<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux系统管理--文件系统管理</title>
      <link href="2020/11/13/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>2020/11/13/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘配额"><a class="markdownIt-Anchor" href="#磁盘配额"></a> 磁盘配额</h2><h3 id="磁盘配额概念"><a class="markdownIt-Anchor" href="#磁盘配额概念"></a> 磁盘配额概念</h3><blockquote><p>磁盘配额是计算机中指定磁盘的储存限制，就是管理员可以为用户所能使用的磁盘空间进行配额限制，每一用户只能使用最大配额范围内的磁盘空间。</p></blockquote><h3 id="磁盘配额条件"><a class="markdownIt-Anchor" href="#磁盘配额条件"></a> 磁盘配额条件</h3><ul><li>内核必须支持磁盘配额</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep CONFIG_QUOTA &#x2F;boot&#x2F;config-2.6.32-279.el6.i686 CONFIG_QUOTA&#x3D;y</span><br><span class="line">CONFIG_QUOTA_NETLINK_INTERFACE&#x3D;y</span><br><span class="line"># CONFIG_QUOTA_DEBUG is not set</span><br><span class="line">CONFIG_QUOTA_TREE&#x3D;y</span><br><span class="line">CONFIG_QUOTACTL&#x3D;y</span><br></pre></td></tr></table></figure><ul><li>系统中必须安装了 quota 工具，我们的Linux默认是安装了 quota 工具的，查看命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm  -qa  |  grep  quota</span><br><span class="line">quota-3.17-16.el6.i686</span><br></pre></td></tr></table></figure><p>要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认开启。</p><h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>1）用户配额和组配额<br />2）磁盘容量限制和文件个数限制<br />3）软限制和硬限制<br />4）宽限时间</p><blockquote><p>如果用户的空间占用数处于软限制和硬限制之间，系统会在用户登陆时警告用户磁盘将满，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级成为硬限制。</p></blockquote><h3 id="磁盘配额规划"><a class="markdownIt-Anchor" href="#磁盘配额规划"></a> 磁盘配额规划</h3>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--文件系统管理</title>
      <link href="2020/11/01/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
      <url>2020/11/01/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="硬盘结构"><a class="markdownIt-Anchor" href="#硬盘结构"></a> 硬盘结构</h2><h3 id="硬盘的逻辑结构"><a class="markdownIt-Anchor" href="#硬盘的逻辑结构"></a> 硬盘的逻辑结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201107223121846.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />每个扇区的大小都是固定的，位512Byte。扇区也是磁盘的最小存储单位。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020110722323061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><p>磁盘的大小是使用**“磁头数X柱面数X扇区数X每个扇区大小”** 这样的公式来计算的。其中磁头数(Heads) 表示硬盘总共有几个磁头，也可以理解为硬盘有几个盘面，然后乘以二；柱面数(Cylinders) 表示硬盘每一面盘片有几条磁条；扇区数(Sectors)表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。</p><h3 id="硬盘接口"><a class="markdownIt-Anchor" href="#硬盘接口"></a> 硬盘接口</h3><ul><li>IDE硬盘接口（Integrated Drive Electronics，并口，即电子集成驱动）也称作“ATA硬盘”<br />或“PATA硬盘”，是最早机械硬盘的主要接口，ATA133硬盘的理论速度可以达到<strong>133MB/s</strong>（此速度为理论平均值）。</li><li>SATA接口（Serial ATA，串口）是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是STATA三代，理论传输速度达到<strong>600MB/s</strong>（此速度为理论平均值）。</li><li>SCSI接口（Small Computer System Interface，小型计算机系统接口）广泛应用在服务器上，具备应用范围广、多任务、带宽大、CPU占用率低及支持热插拔等优点，理论传输速度达到320MB/s。</li></ul><h2 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h2><h3 id="linux文件系统的特性"><a class="markdownIt-Anchor" href="#linux文件系统的特性"></a> Linux文件系统的特性</h3><ul><li>super block（超级块）：记录整个文件系统信息，包括block和inode 的总量。已经使用的block和inode的数量，未使用的block和inode的数量，block与inode的大小，文件系统的挂载时间，最近一次的写入时间，最近一次的磁盘检验时间等。</li><li>date block（数据块，也称做block）：用来实际保存数据的（相当于柜子的隔断），block的大小（1KB、2KB或4KB）和数量在格式化后就已经决定，不能改变，除非重新格式化。每个block只能保存一个文件的数据，要是文件数据小于一个block，那么这个block的剩余空间也不能被其他文件使用；要是文件数据大于一个block块，则占用多个block块。Windows中磁盘碎片整理工具的原理就是把一个文件占用的多个block块尽量整理到一起，这样可以加快读写速度。</li><li>inode（i节点，相当于柜子的标签）：用来记录文件的权限（r、w、x），文件的所有者和属组，文件的大小，文件的状态改变时间（ctime），文件的最近一次读取时间（atime），文件的最近一次修改时间（mtime），文件的数据整整保存的block编号。每个文件需要占用一个inode。</li></ul><h3 id="linux常见文件系统"><a class="markdownIt-Anchor" href="#linux常见文件系统"></a> linux常见文件系统</h3><table><thead><tr><th>文件系统</th><th>描述</th></tr></thead><tbody><tr><td>ext</td><td>Linux最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。</td></tr><tr><td>ext2</td><td>是 ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是ext2文件系统。于1993年发布，支持最大16TB的分区和最大2TB的文件。</td></tr><tr><td>ext3</td><td>是ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件。</td></tr><tr><td>ext4</td><td>是ext3文件系统的升级版本。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久预分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启动barrier等。它是CentOS6.x的默认文件系统。</td></tr><tr><td>xfs</td><td>XFS最早针对IRIX操作系统开发，是一个高性能的日志型文件系统，能够在断电以及操作系统崩溃的情况下保证文件系统数据的一致性。它是一个64位的文件系统，后来进行开源并且移植到了Linux操作系统中，目前CentOS7.x将XFS+LVM作为默认的文件系统。据官方所称，XFS对于大文件的读写性能较好。</td></tr><tr><td>swap</td><td>swap是Linux中用于交换分区的文件系统（类似于Windows中的虚拟内存），当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的2倍，但是不要超过2GB。它是Linux的必须分区。</td></tr><tr><td>NFS</td><td>是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件共享的一种网络服务，本机可以通过挂载的方式使用远程共享的资源。</td></tr><tr><td>ios9660</td><td>光盘的标准文件系统。Linux要想使用光盘，必须支持iso9660文件系统。</td></tr><tr><td>fat</td><td>就是Windows下的fat16 文件系统，在Linux中识别为fat。</td></tr><tr><td>vfat</td><td>就是windows下的fat32文件系统，在Linux中识别为vfat.支持最大32GB的分区和最大4GB的文件</td></tr><tr><td>NTFS</td><td>就是Windows下的NTFS文件系统，不过Linux默认是不能识别NTFS文件系统的，如果需要识别，则需要重新编译内核才能支持，就算是重新编译内核也是只读的。它比fat32 文件系统更加安全，速度更快，支持最大2TB的分区和最大64GB的文件。</td></tr><tr><td>ufs</td><td>Sun 公司的操作系统Solaris和SuxOS所采用的文件系统。</td></tr><tr><td>proc</td><td>Linux中基于内存的虚拟文件系统，用来管理内存存储目录/proc</td></tr><tr><td>sysfs</td><td>和proc一样，也是基于内存的虚拟文件系统，用来管理内存存储目录/sysfs</td></tr><tr><td>tmpfs</td><td>也是一种基于内存的虚拟文件系统，不过也可以使用swap交换分区。</td></tr></tbody></table><h2 id="常用的硬盘管理命令"><a class="markdownIt-Anchor" href="#常用的硬盘管理命令"></a> 常用的硬盘管理命令</h2><h3 id="df命令"><a class="markdownIt-Anchor" href="#df命令"></a> df命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -ahT</span><br><span class="line">-a  显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如&#x2F;proc，因为是挂载在内存中，所以占用量都是0</span><br><span class="line">-h  单位不再只用KB，而是换算成习惯单位</span><br><span class="line">-T  多出了文件系统类型一例</span><br></pre></td></tr></table></figure><h3 id="du命令"><a class="markdownIt-Anchor" href="#du命令"></a> du命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du  [选项]  [目录或文件名] </span><br><span class="line">选项：</span><br><span class="line">-a  显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占有量</span><br><span class="line">-s  统计总占用量，而不列出子目录和子文件的占用量</span><br></pre></td></tr></table></figure><p>du 和 df 的区别：du 是用于统计文件大小的，统计的文件大小是准确的；df 是用于统计空间大小的，统计的剩余空间是准确的<br />lsof | grp deleted   查看被删除的文件，然后一个进程一个进程的手工kill也是可以的</p><h3 id="fsck文件系统修复命令"><a class="markdownIt-Anchor" href="#fsck文件系统修复命令"></a> fsck文件系统修复命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fsck -y &#x2F;dev&#x2F;sdb1</span><br><span class="line">#自动修复</span><br></pre></td></tr></table></figure><h3 id="显示磁盘状态-dumpe2fs"><a class="markdownIt-Anchor" href="#显示磁盘状态-dumpe2fs"></a> 显示磁盘状态 dumpe2fs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs &#x2F;dev&#x2F;sda3 </span><br><span class="line">dumpe2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;    👈卷标名</span><br><span class="line">Last mounted on:          &#x2F;                       👈挂载点</span><br><span class="line">Filesystem UUID:          c2ca6f57-b15c-43ea-bca0-f239083d8bd2UUID </span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem  features:            has_journal  ext_attr  resize_inode  dir_index  filetype  needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash  </span><br><span class="line">Default mount options:    user_xattr acl          👈挂载参数</span><br><span class="line">Filesystem state:         clean                     👈文件系统状态，正常</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              1826816             👈inode总数</span><br><span class="line">Block count:              7300864           👈块总素</span><br><span class="line">Reserved block count:     365043</span><br><span class="line">Free blocks:              6634637</span><br><span class="line">Free inodes:              1753533</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096                 👈块大小</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Reserved GDT blocks:      1022</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8192</span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Mon Nov 12 22:30:41 2012</span><br><span class="line">Last mount time:          Tue Apr  9 23:53:29 2013</span><br><span class="line">Last write time:         Mon Nov 12 22:45:55 2012</span><br><span class="line">Mount count:             3</span><br><span class="line">Maximum mount count:     -1</span><br><span class="line">Last checked:              Mon Nov 12 22:30:41 2012</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          3199 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11Inode size:               256👈inode的大小</span><br><span class="line">...省略部分输出... </span><br><span class="line">Group 0: (Blocks 0-32767) [ITABLE_ZEROED]           👈第一个数据组的内容</span><br><span class="line">校验和 0xcb85,8179个未使用的inode</span><br><span class="line">主 superblock at 0, Group descriptors at 1-2 </span><br><span class="line">保留的GDT块位于 3-1024  </span><br><span class="line">Block bitmap at 1025 (+1025), Inode bitmap at 1041 (+1041)  </span><br><span class="line">Inode表位于 1057-1568 (+1057)  </span><br><span class="line">23513 free blocks, 8179 free inodes, 2 directories, 8179个未使用的inodes</span><br><span class="line">可用块数: 9255-32767</span><br><span class="line">可用inode数: 14-8192</span><br><span class="line">...省略部分输出... </span><br></pre></td></tr></table></figure><h3 id="查看文件的详细时间"><a class="markdownIt-Anchor" href="#查看文件的详细时间"></a> 查看文件的详细时间</h3><p>stat    文件名     查看文件的详细时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@192 ~]# stat testfile </span><br><span class="line">  File：&quot;testfile&quot;</span><br><span class="line">  Size：18968     Blocks：40         IO Blocks：4096   regular file</span><br><span class="line">  #文件大小             占用块                   系统分区块大小</span><br><span class="line">Device：fd00h&#x2F;64768dInode：33575012    Links(硬链接)：1</span><br><span class="line"> #存放文件的设备 Inode 号                               硬链接数</span><br><span class="line">Access：(0644&#x2F;-rw-r--r--)  Uid：(    0&#x2F;    root)   Gid：(    0&#x2F;    root)</span><br><span class="line"># 权限       属主       属组</span><br><span class="line">Context：unconfined_u:object_r:admin_home_t:s0</span><br><span class="line">Access：2020-10-30 16:10:44.549238248 +0800</span><br><span class="line">Modify：2020-10-30 16:10:44.549238248 +0800</span><br><span class="line">Change：2020-10-30 16:10:44.549238248 +0800</span><br><span class="line"></span><br><span class="line">#Context环境        access访问时间            modify数据修改时间            change状态修改时间</span><br></pre></td></tr></table></figure><h3 id="判断文件类型"><a class="markdownIt-Anchor" href="#判断文件类型"></a> 判断文件类型</h3><p>file  文件名                     判断文件类型<br />type 命令名                   判断命令类型</p><h2 id="fdisk-命令手工分区"><a class="markdownIt-Anchor" href="#fdisk-命令手工分区"></a> fdisk 命令手工分区</h2><h3 id="fdisk-l"><a class="markdownIt-Anchor" href="#fdisk-l"></a> fdisk -l</h3><p>查看系统所有硬盘及分区</p><h3 id="fdisk-devsdb-进行磁盘分区-分区还没有分区号"><a class="markdownIt-Anchor" href="#fdisk-devsdb-进行磁盘分区-分区还没有分区号"></a> fdisk  /dev/sdb 进行磁盘分区 （分区还没有分区号）</h3><p>fdisk 交互指令说明：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">设置可引导标记</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">编辑bsd此怕标签</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">设置DOS操作系统兼容标记</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">删除一个分区</td></tr><tr><td style="text-align:center">l</td><td style="text-align:center">显示已知的文件系统类型。82为linux swap分区，83为Linux分区</td></tr><tr><td style="text-align:center">m</td><td style="text-align:center">显示帮助菜单</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">新建分区</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">建立空白DOS分区列表</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">显示分区列表</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">不保存退出</td></tr><tr><td style="text-align:center">s</td><td style="text-align:center">新建空白SUN磁盘标签</td></tr><tr><td style="text-align:center">t</td><td style="text-align:center">改变一个分区的系统ID</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">改变显示记录单位</td></tr><tr><td style="text-align:center">v</td><td style="text-align:center">验证分区表</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">保存退出</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">附加功能</td></tr></tbody></table><blockquote><p>n—p主----1分区号----1起始柱面-----分区大小+100M-----w<br />n—e扩展—2分区号—124起始柱面----1024柱面（所有剩余空间都分配给扩展分区）<br />n—1逻辑—不用指定分区号—124起始柱面----+100M（指定大小）-----w</p></blockquote><p>有时因为系统的分区表正忙，则需要重新重启系统之后才能使新的分区表生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): w 👈保存退出</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Device or resource busy. </span><br><span class="line">The kernel still uses the old table.</span><br><span class="line">The new table will be used at the next reboot. 👈要求重启动，才能格式化</span><br><span class="line">Syncing disks</span><br></pre></td></tr></table></figure><h3 id="partprobe-非必须"><a class="markdownIt-Anchor" href="#partprobe-非必须"></a> partprobe （非必须）</h3><p>强制重读所有分区文件，重新挂载分区文件内所有分区。这不是分区必须命令，如果没有提示重启，可以不执行，也可以重启系统。</p><blockquote><p>（Warning: Unable to open /dev/hdc read-write (Read-only file system).  /dev/hdc has been opened read-only.<br />光盘只读挂载，不是报错。</p></blockquote><p>如果这个命令不存在请安装parted-2.1-18.el6.i686这个软件包</p><h3 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h3><p>格式化 建立文件系统    ext4是linux默认文件系统<br />mkfs  -f  ext4  /dev/sdb1<br />mkfs  -f  ext4  /dev/sdb5<br />mkfs 命令简单易用，不过是不能调整分区的默认参数的（比如块大小是4096），这些默认参数除非特殊情况下，否则不需要调整，如果想要调整就需要使用 mke2fs 命令进行重新格式化，命令格式化如下(不建议修改）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs  [选项]  分区设备文件名</span><br><span class="line">选项：</span><br><span class="line">-t  文件系统：  指定格式化成哪个文件系统，如ext2 、ext3、ext4</span><br><span class="line">-b 字节：  指定block块的大小</span><br><span class="line">-i 字节：  指定“字节&#x2F;inode”的比例，也就是多少个字节分配一个inode</span><br><span class="line">-j： 建立带有ext3日志功能的文件系统</span><br><span class="line">-L：卷标名：给文件系统设置卷标名，就不使用e2label 命令设定了</span><br><span class="line"></span><br><span class="line">举个例子：</span><br><span class="line">[root@localhost ~]# mke2fs -t ext4 -b 2048 &#x2F;dev&#x2F;sdb6</span><br><span class="line">#格式化分区，并指定block的大小为2048</span><br></pre></td></tr></table></figure><h3 id="挂载"><a class="markdownIt-Anchor" href="#挂载"></a> 挂载</h3><p>mdir /disk1 #建立挂载点   👉   /dev/sdb1     #把 sdb1 打算挂载到 /disk1 目录中<br />mkdir /disk5          👉    /dev/sdb5</p><p>mount  /dev/sdb1  /disk1     #把sdb1挂载到 /disk1 目录下<br />mount  /dev/sdb5  /disk5</p><h3 id="查看"><a class="markdownIt-Anchor" href="#查看"></a> 查看</h3><p>mount   查看所有已经挂载的分区和光盘<br />fdisk  -l   查看系统分区<br />df   查看分区占用百分比</p><h3 id="自动挂载"><a class="markdownIt-Anchor" href="#自动挂载"></a> 自动挂载</h3><p>修改分区自动挂载文件<br />vi  /etc/fstab       注意：此文件直接参与系统启动，如果修改错误，系统启动报错</p><p>/dev/sdb1/disk1ext3  defaults1   2<br />第一列：设备文件名<br />第二列：挂载点<br />第三列：文件系统<br />第四列：挂载选项<br />第五列： 1  是否可以被备份    0不备份   1每天备份   2不定期备份<br />第六列： 2 是否检测磁盘fsck  0不检测   1启动时检测  2启动后检测</p><p>也可以使用UUID进行挂载，UUID（硬盘通用唯一识别码，可以理解为硬盘的ID）</p><ul><li>这个字段在CentOS 5.5的系统当中是写入分区的卷标名或分区设备文件名的，现在变成了硬盘的UUID，这样的好处是当硬盘增加了新的分区，或者分区的顺序改变，再或者内核升级后，仍然能够保证分区能够正确加载，而至于造成启动障碍</li><li>那么每个分区的UUID到底是什么呢？我们讲过的dumpe2fs命令是可以查看到的，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs  &#x2F;dev&#x2F;sdb5</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# ls  -l  &#x2F;dev&#x2F;disk&#x2F;by-uuid&#x2F;</span><br></pre></td></tr></table></figure><h3 id="重启测试"><a class="markdownIt-Anchor" href="#重启测试"></a> 重启测试</h3><p>mount  -a 重新挂载所有内容，用它进行测试</p><h2 id="etcfstab-文件修复"><a class="markdownIt-Anchor" href="#etcfstab-文件修复"></a> /etc/fstab/ 文件修复</h2><p>/etc/fstab配置文件内容输入错误，重启会发生报错：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201112203125750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><p>首先要拿到报错本机（看上图），输入root密码似乎能解决。输入root密码后进入系统把文件修改正确，这时会发现无法修改该文件。<br />分析原因：我们不是对这个文件没有写权限，而是在挂载之后整个分区被挂载为只读，导致无法写入。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201112204406772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="vim编辑器内报错" /><br />那么我们只要把 / 分区重新挂载下，挂载为读写权限就可以了，操作命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount  -o  remount,rw  &#x2F;</span><br></pre></td></tr></table></figure><p>接下来再去修改/etc/fstab文件，改正确系统就可以正常启动了。</p><h2 id="parted-命令分区"><a class="markdownIt-Anchor" href="#parted-命令分区"></a> parted 命令分区</h2><p>Linux系统中有两种常见的分区表MBR分区表（主引导记录分区表）和GPT分区表（GUID分区表），其中：</p><ul><li>MBR分区表：支持的最大分区是2TB；最多支持4个主分区，或3个主分区1个扩展分区。</li><li>GPT分区表：支持最大的18EB的分区（1EB=1024PB，1PB=1024TB）；最多支持128个分区，其中1个系统保留分区，127个用户自定义分区。</li></ul><p>不过parted命令也有点小问题，就是命令自身分区的时候只能格式化成 ext2 文件系统，不支持 ext3和etx4 文件系统（截至CentOS 6.8 还是这样，这里只是指不能用 parted 命令把分区格式化成 ext4 文件系统，但是 parted 命令还是可以识别ext4文件系统的）。不过没有太大影响，因为我们可以先分区再用 mkfs 进行格式化。</p><h3 id="parted交互模式"><a class="markdownIt-Anchor" href="#parted交互模式"></a> parted交互模式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted  &#x2F;dev&#x2F;sdb</span><br><span class="line">#打算继续划分 &#x2F;dev&#x2F;sdb硬盘</span><br><span class="line">GUN  Parted  2.1</span><br><span class="line">使用  &#x2F;dev&#x2F;sdb</span><br><span class="line">Welcome to GNU Parted! Type &#39;help&#39; to view a list of commands.</span><br><span class="line">(parted)       👈parted 的等待输入交互命令的位置</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">parted交互命令</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">check NUMBER</td><td style="text-align:center">做一次简单的文件系统检测</td></tr><tr><td style="text-align:center">cp [FROM-DEVICE] FROM-NUMBER TO-NUMBER</td><td style="text-align:center">复制文件系统到另一个分区</td></tr><tr><td style="text-align:center">help [COMMAND]</td><td style="text-align:center">显示所有的命令帮助</td></tr><tr><td style="text-align:center">mklabel,mktable LABEL-TYPE</td><td style="text-align:center">创建新的磁盘卷标（分区表）</td></tr><tr><td style="text-align:center">mkfs NUMBER FS-TYPE</td><td style="text-align:center">在分区上建立文件系统</td></tr><tr><td style="text-align:center">mkpart PART-TYPE [FS-TYPE] START END</td><td style="text-align:center">创建一个分区</td></tr><tr><td style="text-align:center">mkpartfs PART-TYPE FS-TYPE START END</td><td style="text-align:center">创建分区，并建立文件系统</td></tr><tr><td style="text-align:center">move NUMBER START END</td><td style="text-align:center">移动分区</td></tr><tr><td style="text-align:center">name NUMBER NAME</td><td style="text-align:center">给分区命名</td></tr><tr><td style="text-align:center">print [devices</td><td style="text-align:center">free</td></tr><tr><td style="text-align:center">quit</td><td style="text-align:center">退出</td></tr><tr><td style="text-align:center">rescue START END</td><td style="text-align:center">修复丢失的分区</td></tr><tr><td style="text-align:center">resize NUMBER START END</td><td style="text-align:center">修改分区大小</td></tr><tr><td style="text-align:center">rm NUMBER</td><td style="text-align:center">删除分区</td></tr><tr><td style="text-align:center">select DEVICE</td><td style="text-align:center">选择需要编辑的设备</td></tr><tr><td style="text-align:center">set NUMBER FLAG STATE</td><td style="text-align:center">改变分区标记</td></tr><tr><td style="text-align:center">toggle [NUMBER [FLAG]]</td><td style="text-align:center">切换分区表的状态</td></tr><tr><td style="text-align:center">unit UNIT</td><td style="text-align:center">设置默认的单位</td></tr><tr><td style="text-align:center">Version</td><td style="text-align:center">显示版本</td></tr></tbody></table><h3 id="建立分区"><a class="markdownIt-Anchor" href="#建立分区"></a> 建立分区</h3><h4 id="查看分区"><a class="markdownIt-Anchor" href="#查看分区"></a> 查看分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(parted) print</span><br><span class="line">#输入 print 指令</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)    👈 ying&#39;pan&#39;ca</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5GB            👈硬盘大小</span><br><span class="line">Sector size (logical&#x2F;physical): 512B&#x2F;512B    👈扇区大小</span><br><span class="line">Partition Table: msdos    👈分区表类型，就是MBR分区</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    Type      File system  标志</span><br><span class="line"> 1      32.3kB  5379MB  5379MB  primary</span><br><span class="line"> 2      5379MB  21.5GB  16.1GB  extended</span><br><span class="line"> 5      5379MB  7534MB  2155MB  logical   ext4</span><br><span class="line"> 6      7534MB  9689MB  2155MB  logical   ext4</span><br><span class="line">#看到了我们使用的 fdisk 分的区，其中 1 分区没有格式化， 2 分区是扩展分区不能格式化</span><br></pre></td></tr></table></figure><p>使用print 可以查看分区表信息，包括硬盘参数，扇区大小，分区表类型和分区信息。分区信息总共七列，分别是：</p><ul><li>Number：分区号</li><li>Start：分区起始位置，这里不再像 fdisk 用柱面表示，而是使用 Byte 更加直观</li><li>End：分区结束位置</li><li>Type：分区类型</li><li>File system：文件系统类型，之前说过 parted 不支持 etx4 。注意，之前一直说的都是 parted 不能直接把分区直接格式化成 etx4 文件系统，但是它是可以识别的。</li><li>标志：Flages，就是分区的标记</li></ul><h4 id="修改gpt分区表"><a class="markdownIt-Anchor" href="#修改gpt分区表"></a> 修改GPT分区表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(parted) mklabel  gpt</span><br><span class="line">#修改分区命令</span><br><span class="line">警告：正在使用 &#x2F;dev&#x2F;sdb 上的分区。       👈由于 &#x2F;dev&#x2F;sdb 分区已经挂载，所以有警告</span><br><span class="line">                                       👈注意如果强制修改，原有分区及数据会消失</span><br><span class="line">忽略&#x2F;Ignore&#x2F; 放弃&#x2F;Cancel？ ignore       👈输入 ignore 忽略报错</span><br><span class="line">警告：The existing disk label on &#x2F;dev&#x2F;sdb will be destroyed and all data on this disk will</span><br><span class="line">be lost. Do you  want to continue?</span><br><span class="line">是&#x2F;Yes&#x2F;否&#x2F;No？ yes             👈输入yes</span><br><span class="line">警告：WARNING: the kernel failed to re-read the partition table on &#x2F;dev&#x2F;sdb (设备或资源忙).  As a result, it may not reflect all of your changes until after reboot.    👈下次重启后，才能生效</span><br><span class="line"></span><br><span class="line">(parted) print                 👈查看下分区表吧</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk  &#x2F;dev&#x2F;sdb：21.5G</span><br><span class="line">Sector size (logical&#x2F;physical): 512B&#x2F;512B</span><br><span class="line">Partition Table: gpt            👈分区表已经变成GPT</span><br><span class="line"></span><br><span class="line">Number Start End Size File system Name 标志</span><br><span class="line">                                           👈所有分区都消失了</span><br></pre></td></tr></table></figure><p>修改了分区表，如果这块硬盘已经有了分区，那么原有分区和分区中的书籍都会消失，而且需要重启系统才会生效。<br />还又我们转换分区表的目的是为了支持大于2TB的分区，如果分区并没有大于2TB，那么这步是不可以执行的。</p><blockquote><p>注意：一定要把 /etc/fstab 文件中和原有分区的内容删除掉，才能重启动。否则系统启动就一定会报错的。</p></blockquote><h4 id="建立分区-2"><a class="markdownIt-Anchor" href="#建立分区-2"></a> 建立分区</h4><p>因为修改过了分区表，所以 /dev/sdb 中的所有数据都消失了，所以我们可以重新对这块硬盘分区了。不过建立分区时，默认文件系统就只能建立成 etx2 了，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(parted)  mkpart</span><br><span class="line">#输入创建分区命令，后面不要参数，全部靠交互指令</span><br><span class="line">分区名称？  [ ]? disk1         👈分区名称，我起名叫disk1 </span><br><span class="line">文件系统类型？  [ext2]?       👈文件系统类型，直接回车，使用默认ext2 </span><br><span class="line">起始点？ 1MB                  👈分区从1MB开始</span><br><span class="line">结束点？ 5GB      👈分区到5GB结束</span><br><span class="line">#分区完成</span><br><span class="line">(parted) print              查看下吧</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5GB</span><br><span class="line">Sector size (logical&#x2F;physical): 512B&#x2F;512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Number  Start   End     Size    File system  Name  标志</span><br><span class="line">1      1049kB  5000MB  4999MB               disk1分区1已经出现</span><br></pre></td></tr></table></figure><p>注意，我们现在的 print 查看的分区，和第一次查看MBR 分区表的分区时有些不一样了，少了Type这个字段，也就是分区类型的字段，多了 Name 分区名字段。分区类型是标识主分区、扩展分区和逻辑分区的，不过这种标识只在 MBR 分区表中使用，我们现在已经变成了GPT分区表了，所以不再有 Type 类型了。</p><h4 id="建立文件系统"><a class="markdownIt-Anchor" href="#建立文件系统"></a> 建立文件系统</h4><p>分区完毕，我们还需要格式化。不过我们已经知道如果使用 parted 交互命令格式化的话，只能格式化成ext2文件系统。我们这里是要演示下 parted 命令的格式化方法，所以就格式化成 ext2 ，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkfs</span><br><span class="line">#格式化命令（很奇怪也是 mkfs ，但是这只是parted的交互命令）</span><br><span class="line">WARNING: you are attempting to use parted to operate on (mkfs) a file system.parted&#39;s file system manipulation code is not as robust as what you&#39;ll find indedicated, file-system-specific packages like e2fsprogs.  We recommend you use parted only to manipulate partition tables, whenever possible. Support for performing most operations on most types of file systemswill be removed in an upcoming release.</span><br><span class="line">警告： The existing file system will be destroyed and all data on the partition will be lost. Do you want to continue?</span><br><span class="line">是&#x2F;Yes&#x2F;否&#x2F;No？ yes     👈警告你格式化数据会丢失。</span><br><span class="line">分区编号？ 1</span><br><span class="line">文件系统类型？ [ext2]      👈指定文件系统类型，写别的也没有用</span><br><span class="line"></span><br><span class="line">(parted) print      👈格式化完成，查看下结构</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk：&#x2F;dev&#x2F;sdb：21.5G</span><br><span class="line">Sector size （logical&#x2F;physical）：512B&#x2F;512B</span><br><span class="line">Partition Table：gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name   标志</span><br><span class="line">1          1049KB  5000MB  4999MB  ext2     disk        👈拥有了文件系统</span><br></pre></td></tr></table></figure><p>如果要格式成 ext4 文件系统，请 mkfs 命令帮忙（注意这里不是parted交互命令中的 mkfs ，而是系统命令 mkfs）。</p><h4 id="调整分区大小"><a class="markdownIt-Anchor" href="#调整分区大小"></a> 调整分区大小</h4><p>parted 命令还有一大优势，就是可以调整分区大小（windows中也可以实现，不过要不需要转换成动态磁盘<br />，要不需要依赖第三方工具，如硬盘分区魔术师）。起始 Linux 中 LVM 和 RAID 是可以支持分区调整的，不过这两种方法也可以看成是动态磁盘方法，这个会在下一章介绍。使用parted命令调整分区要更加简单。</p><blockquote><p>注意：parted调整已经挂载使用的分区时，是不会影响分区中的数据的，也就是说数据不会丢失。但是一定要<strong>先卸载分区</strong>，在调整分区大小，否则数据是会出现问题的。还有要调整大小的分区必须已经建立了文件系统（格式化），否则会报错。</p></blockquote><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(parted) resize</span><br><span class="line">分区编号？ 1    👈指定要修改的分区编号</span><br><span class="line">起始点？ [1049KB]? 1MB     👈分区起始位置</span><br><span class="line">结束点？ [5000MB]？ 6GB     👈分区结束位置</span><br><span class="line">(parted) print         👈查看下</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5GB</span><br><span class="line">Sector size (logical&#x2F;physical): 512B&#x2F;512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name   标志</span><br><span class="line"> 1      1049kB  6000MB  5999MB  ext2         disk1       👈分区大小改变</span><br></pre></td></tr></table></figure><h4 id="删除分区"><a class="markdownIt-Anchor" href="#删除分区"></a> 删除分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(parted) rm</span><br><span class="line">#删除分区命令</span><br><span class="line">分区编号？ 1     👈指定分区号</span><br><span class="line">(parted) print    👈查看下</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk &#x2F;dev&#x2F;sdb: 21.5GB</span><br><span class="line">Sector size (logical&#x2F;physical): 512B&#x2F;512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  标志    👈分区消失</span><br></pre></td></tr></table></figure><p>注意：parted中所有的操作都是立即生效，没有保存的概念。这点和 fdiskjiaohuml明显不同，所以所有操作要加倍小心。<br />那么到底是使用 fdisk 进行分区还是 parted 命令，这个完全看个人习惯，这里更习惯于fdisk命令。</p><h2 id="分配swap-分区"><a class="markdownIt-Anchor" href="#分配swap-分区"></a> 分配swap 分区</h2><h3 id="分区并修改为-swap-分区-id"><a class="markdownIt-Anchor" href="#分区并修改为-swap-分区-id"></a> 分区，并修改为 swap 分区 ID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk  &#x2F;dev&#x2F;sdb</span><br><span class="line">#拿 &#x2F;dev&#x2F;sdb 分区</span><br><span class="line">Command (m for help): t    👈修改分区的系统ID</span><br><span class="line">Selected partition 1    👈只有一个分区，所以不用选择分区了</span><br><span class="line">Hex code (type L to list codes): 82    👈改为swap的ID</span><br><span class="line">Changed system type of partition 1 to 82 (Linux swap &#x2F; Solaris)</span><br></pre></td></tr></table></figure><h3 id="格式化-2"><a class="markdownIt-Anchor" href="#格式化-2"></a> 格式化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkswap  &#x2F;dev&#x2F;sdb1</span><br><span class="line">Setting up swapspace version 1, size &#x3D; 522076 KiBno label, UUID&#x3D;c3351dc3-f403-419a-9666-c24615e170fb</span><br></pre></td></tr></table></figure><h3 id="使用-swap-分区"><a class="markdownIt-Anchor" href="#使用-swap-分区"></a> 使用 swap 分区</h3><p>在使用 swap 分区之前，我们先说说 free 命令，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free</span><br><span class="line">             total       used       free     shared    buffers(缓冲)     cached(缓存)</span><br><span class="line">Mem:        1030796     130792     900004          0      15292      55420</span><br><span class="line">-&#x2F;+ buffers&#x2F;cache:      60080     970716</span><br><span class="line">Swap:      2047992          0    2047992</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# swapon  分区设备文件名</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">[root@localhost ~]# swapon  &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure><p>让 swap 分区开机之后自动挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdb1               swap               swap      defaults         0  0</span><br><span class="line">#加入新 swap 分区的相关内容，我这里是直接使用的分区的设备文件名，大家当然也可以使用UUID号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--权限管理</title>
      <link href="2020/10/26/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>2020/10/26/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="acl权限"><a class="markdownIt-Anchor" href="#acl权限"></a> ACL权限</h2><h3 id="acl概述-acl是用于解决用户对文件身份不足的问题"><a class="markdownIt-Anchor" href="#acl概述-acl是用于解决用户对文件身份不足的问题"></a> ACL概述: ACL是用于解决用户对文件身份不足的问题</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201026180339672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h3 id="开启acl"><a class="markdownIt-Anchor" href="#开启acl"></a> 开启ACL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs -h &#x2F;dev&#x2F;sda3</span><br><span class="line">#dumpe2fs 命令是查询指定分区详细文件系统信息的命令</span><br><span class="line">选项：</span><br><span class="line">-h      仅显示超级块中信息，而不显示磁盘块组的详细信息。</span><br><span class="line">...省略部分输出...</span><br><span class="line">Default mount options:         user_xattr acl</span><br><span class="line">...省略部分输出...</span><br></pre></td></tr></table></figure><p>如果没有开启，手工开启分区的ACL权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,acl &#x2F;</span><br><span class="line">#重新挂载根分区，并挂载加入acl权限</span><br></pre></td></tr></table></figure><p>也可以通过修改/etc/fstab 文件，永久开启ACL权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;fstab</span><br><span class="line">UUID&#x3D;c2ca6f57-b15c-43ea-bca0-f239083d8bd2  &#x2F;   ext4    defaults,acl1  1 </span><br><span class="line">#加入 acl</span><br><span class="line">[root@localhost ~]# mount -o remount &#x2F;</span><br><span class="line">#重新挂载文件系统或重启系统，时修改生效</span><br></pre></td></tr></table></figure><h3 id="acl-基本命令"><a class="markdownIt-Anchor" href="#acl-基本命令"></a> ACL 基本命令</h3><p>getfacl     文件名      查询文件的ACL权限<br />setfacl     选项      文件名     设定ACL权限<br />选项：<br />-m   设定ACL权限<br />-b  删除ACL权限<br />-x:用户     删除单个用户的ACL权限<br />setfacl  -m  u:用户名:权限    文件名<br />setfacl  -m  g:组名:权限   文件名<br />setfacl  -m u:aa:rwx  /test    给test目录赋予aa是读写执行的ACL权限<br />setfacl  -m  u:cc:rx  -R  soft/    赋予递归ACL权限，只能赋予目录<br />-R   递归</p><p>setfacl  -m d:u:aa:rwx -R /testACL默认权限。注意：默认权限只能赋予目录<br />注意：如果给目录赋予acl权限，两条命令都要输入<br />递归与默认的区别：<br />setfacl  -m  u:cc:rx  -R  soft/                        只对已经存在的文件生效<br />setfacl  -m d:u:aa:rwx  -R  /test                        只对以后新建的文件生效</p><h3 id="最大有效权限-mask"><a class="markdownIt-Anchor" href="#最大有效权限-mask"></a> 最大有效权限 mask</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#setfacl  -m  m:rx  project</span><br><span class="line">#设定mask权限为r-x。使用&quot;m:权限&quot; 格式</span><br><span class="line">[root@localhost ~]# getfacl project&#x2F;</span><br><span class="line"># file: project&#x2F;</span><br><span class="line">#owner:  root</span><br><span class="line">#group: tgroup</span><br><span class="line">user: :rwx</span><br><span class="line">group: :rwx                  #effective: r-x</span><br><span class="line">mask: :r-x</span><br><span class="line">#mask 权限变为了r-x</span><br><span class="line">other: :---</span><br></pre></td></tr></table></figure><h3 id="删除acl权限"><a class="markdownIt-Anchor" href="#删除acl权限"></a> 删除ACL权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost &#x2F;]# setfacl  -x  u:st  &#x2F;project&#x2F;</span><br><span class="line">#删除指定用户和用户组的ACL权限</span><br><span class="line">[root@localhost &#x2F;]# setfacl  -b  project&#x2F;</span><br><span class="line">#会删除文件的所有的ACL权限</span><br></pre></td></tr></table></figure><h2 id="sudo-授权给普通用户赋予部分管理员权限"><a class="markdownIt-Anchor" href="#sudo-授权给普通用户赋予部分管理员权限"></a> sudo 授权：给普通用户赋予部分管理员权限</h2><blockquote><p>/sbin/        在此目录下命令只有超级用户才能使用<br />/usr/sbin/</p></blockquote><h3 id="root身份"><a class="markdownIt-Anchor" href="#root身份"></a> root身份</h3><p>visudo：赋予普通用户权限命令，命令执行后和vi一样使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root        ALL&#x3D;(ALL)              ALL</span><br><span class="line">#用户名      被管理主机的地址&#x3D;(可使用的身份)        授权命令(绝对路径)</span><br><span class="line"># %wheel            ALL&#x3D;(ALL)           ALL</span><br><span class="line">#%组名       被管理主机的地址&#x3D;(可使用的身份)    授权命令(绝对路径)</span><br></pre></td></tr></table></figure><ul><li>用户名/组名：代表root给哪个用户或用户组赋予命令，注意组名前加 “%”</li><li>用户可用指定的命令管理指定IP地址的服务器。如果写ALL，代表可用管理任何主机，如果写固定IP，代表可用管理指定的服务器。如果我们这里写本机IP地址，不代表只允许本机的用户使用指定命令，而代表指定的用户可用从任何IP地址来管理当前服务器。</li><li>可使用身份：就是把来源用户切换成什么身份使用，(ALL)代表可以切换成任意身份。这个字段可用省略。</li><li>授权命令：代表root把什么命令授权给普通用户。默认是ALL，代表任何命令，这个当然不行。如果需要给哪个命令授权，写入命令名即可，不过需要注意一定要命令写成绝对路径。</li></ul><h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3><p>1)例一，比如授权用户user1可用重启服务器，则由root用户添加如下行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1     ALL&#x3D; &#x2F;sbin&#x2F;shutdown -r now</span><br><span class="line">[user1@localhost ~]$ sudo -l</span><br><span class="line">#查看可用的授权</span><br></pre></td></tr></table></figure><p>2)例二,授权一个用户管理Web服务器，不用自己插手，以后修改设置更新网页都不用管，首先要分析授权用户管理Apache至少要实现哪些基本授权：<br />1、可以使用Apache管理脚本<br />2、可用修改Apache配置文件<br />3、可用更新网页内容<br />假设Apache管理脚本程序为/etc/rc.d/init.d/httpd<br />为满足条件一，用visudo进行授权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1      192.168.0.156&#x3D;&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd reload, \</span><br><span class="line">&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd configtest</span><br></pre></td></tr></table></figure><p>授权用户user1可用连接192.168.0.156上的Apache服务器，通过Apache管理脚本重新读取配置文件让更改的设置生效（reload）和可以检测Apache配置文件语法错误（configtest），但不允许执行关闭（stop）、重启（restart）等操作。（&quot;&quot;的意思是一行没有完成，下面的内容和上一行是同一行。）<br />为满足条件二，同样使用visudo授权：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1     192.168.0.156&#x3D;&#x2F;binvi &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br></pre></td></tr></table></figure><blockquote><p>授权用户user1可以用root身份使用vi编辑Apache配置文件。<br />以上两种速冻的设置，要特别注意，很多人使用sudo会犯两个错误：第一，授权命令没有细化到选项和参数；第二，认为只能授权管理员执行命令。</p></blockquote><p>条件三则比较简单，假设网页存放目录为/var/www/html ，则只需要授权user1对此目录具有写权限或者索性更改目录所有者为user1即可。如果需要，还可以设置user1可用通过FTP等文件共享服务更新网页。</p><p>3）授权aa用户可以添加其他普通用户<br />aa  ALL=/usr/sbin/useradd             赋予aa添加用户权限，命令必须写绝对路径</p><p>aa  ALL=/usr/bin/passwd        👈赋予改密码权限，权限过大，不允许这么做。</p><p>aa  ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd “”, !/usr/bin/passwd root</p><p>aa身份            sudo  /usr/sbin/useradd  ee普通用户使用sudo命令执行超级用户命令</p><h2 id="文件特殊权限-setuid-setgid-sticky-bit"><a class="markdownIt-Anchor" href="#文件特殊权限-setuid-setgid-sticky-bit"></a> 文件特殊权限 SetUID、SetGID、Sticky BIT</h2><h3 id="setuid-了解"><a class="markdownIt-Anchor" href="#setuid-了解"></a> SetUID （了解）</h3><ol><li>什么是SetUID</li></ol><ul><li>只有可执行的二进制程序才能设定SUID权限</li><li>命令执行者要对该程序拥有&quot; x &quot;（执行）权限</li><li>命令执行者在执行该程序时获得该程序文件属主的身份</li><li>SetUID权限只在改程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</li></ul><ol start="2"><li>举例</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll &#x2F;etc&#x2F;passwd</span><br><span class="line">-rw-r--r--. 1 root root 2823 10月 30 16:11 &#x2F;etc&#x2F;passwd</span><br><span class="line">[root@localhost ~]# ll &#x2F;etc&#x2F;shadow</span><br><span class="line">----------. 1 root root 1574 10月 30 16:11 &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure><p>因为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll &#x2F;usr&#x2F;bin&#x2F;passwd</span><br><span class="line">-rwsr-xr-x. 1 root root 27856 8月   9 2019 &#x2F;usr&#x2F;bin&#x2F;passwd</span><br></pre></td></tr></table></figure><p>/usr/bin/passwd 命令拥有特殊权限SetUID，也就是在属主的权限位的执行权限上是&quot; s &quot;。可以这样来理解：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。/usr/bin/passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，实际是在用passwd命令所有者root的身份在执行passwd命令，root当然也可以将密码写入/etc/passwd文件,所以普通用户也可以修改/etc/passwd文件，命令执行完成后该身份也随之消失，如果消失SetUID权限，则普通用户就不能修改自己的密码了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20201031150310625.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><ol start="3"><li>危险的SetUID</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod u+s &#x2F;usr&#x2F;bin&#x2F;vim</span><br><span class="line">[root@localhost ~]# ll &#x2F;usr&#x2F;bin&#x2F;vim</span><br><span class="line">-rwsr-xr-x 1 root root 1847752 4月5 2012 &#x2F;usr&#x2F;bin&#x2F;vim</span><br></pre></td></tr></table></figure><ol start="4"><li>几点建议：</li></ol><ul><li>关键目录应严格控制写权限。比如&quot;/&quot; 、&quot;/usr&quot;  等</li><li>用户的密码设置要严格遵守密码三原则</li><li>对系统中默认应具有SetUID 权限的文件作以列表，定时检查有没有这之外的文件被设置了SetUID权限。</li></ul><ol start="5"><li>检测SetUID的脚本（参考）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi suidcheck.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Author: shenchao （E0-mail: shenchao@atguigu.com）</span><br><span class="line"></span><br><span class="line">find &#x2F; -perm -4000 -o -perm -2000 &gt; &#x2F;tmp&#x2F;setuid.check</span><br><span class="line">#搜索系统中所有拥有SUID和SGID的文件，并保存到临时目录中。</span><br><span class="line">for i in $(cat &#x2F;tmp&#x2F;setuid.check)</span><br><span class="line">#做循环，每次循环取出临时文件中的文件名</span><br><span class="line">do</span><br><span class="line">grep $i &#x2F;root&#x2F;suid.list &gt; &#x2F;dev&#x2F;null</span><br><span class="line">#比对这个文件名是否在模板文件中</span><br><span class="line">if [ &quot;$?&quot; !&#x3D; &quot;0&quot; ]</span><br><span class="line">#如果在，不报错</span><br><span class="line">then</span><br><span class="line">echo &quot;$i isn&#39;t in listfile! &quot; &gt;&gt; &#x2F;root&#x2F;suid_log_$(date +%F)</span><br><span class="line">#如果文件名不再模板文件中，则报错。并把报错报错到日志中</span><br><span class="line">fi</span><br><span class="line">done </span><br><span class="line">rm -rf &#x2F;tmp&#x2F;setuid.check</span><br><span class="line">#删除临时文件</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# chmod u+s &#x2F;bin&#x2F;vi</span><br><span class="line">#手工给vi加入SUID权限</span><br><span class="line">[root@localhost ~]# .&#x2F;suidcheck.sh</span><br><span class="line">#执行检测脚本</span><br><span class="line">[root@localhost ~]# cat suid_log_2013-01-   20  </span><br><span class="line">&#x2F;bin&#x2F;vi isn&#39;t in listfile!</span><br><span class="line">#报错了，vi不再模板文件中。代表vi被修改了SUID权限</span><br></pre></td></tr></table></figure><h3 id="setgid"><a class="markdownIt-Anchor" href="#setgid"></a> SetGID</h3><ol><li>针对文件的作用<br />SGID既可以针对文件生效，又可以针对目录生效，这和SUID明显不同。如果针对文件，SGID的含义如下：</li></ol><ul><li>只有可执行的二进制程序才能设置SGID权限</li><li>命令执行者要对该程序拥有&quot; x &quot;(执行) 权限</li><li>命令执行在执行程序的时候，组身份升级为该程序文件的属组</li><li>SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db</span><br><span class="line">-rw-r----- 1 root slocate 1838850 1月  20 04:29 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db</span><br></pre></td></tr></table></figure><p>这里发现属主权限是r、w，属组权限是r，但是其他人权限是0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll&#x2F;usr&#x2F;bin&#x2F;locate</span><br><span class="line">-rwx--s--x 1 root slocate 35612 8月    24 201 &#x2F;usr&#x2F;bin&#x2F;locate</span><br></pre></td></tr></table></figure><p>当普通用户user1执行locate命令时，会发生如下事情：</p><ul><li>/usr/bin/locate 是可执行二进制程序。可以赋予SGID</li><li>执行用户 user1队/usr/bin/locate 命令拥有执行权限</li><li>执行 /usr/bin/locate 命令时，组身份会升级为 slocate组，而slocate组对 /var/lib/mlocate/mlocate.db 数据库拥有&quot; r &quot;权限，所以普通用户可以使用locate命令查询mlocate.db数据库</li><li>命令结束，user1用户的组身份返回为user1组</li></ul><ol start="2"><li>针对目录的作用<br />如果SGID针对目录设置，含义如下：</li></ol><ul><li>普通用户必须对此目录拥有&quot; r “和” x &quot;权限,才能进入此目录</li><li>普通用户在此目录中的有效组会变成此目录的属组</li><li>若普通用户对此目录拥有&quot; w &quot; 权限时，新建的文件的默认属组是这个目录的属组<br />举个例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;tmp&#x2F;</span><br><span class="line">进入临时目录&#x2F;tmp&#x2F;目录做此实验，因为临时目录才允许普通用户修改</span><br><span class="line">[root@localhost tmp]# mkdir dtest</span><br><span class="line">#建立测试目录</span><br><span class="line">[root@localhost tmp]# chmod g+s dtest</span><br><span class="line">#给测试目录赋予SGID</span><br><span class="line">[root@localhost tmp]# ll -d dtest&#x2F;</span><br><span class="line">drwxr-sr-x 2 root root 4096 1月    20 06:04 dtes</span><br><span class="line">#SGID已经生效</span><br><span class="line">root@localhost tmp]# chmod 777 dtest&#x2F;</span><br><span class="line">#给测试目录权限，让普通用户可以写</span><br><span class="line">root@localhost tmp]# su - user1</span><br><span class="line">#切换成普通用户user1</span><br><span class="line">root@localhost ~]$ cd &#x2F;tmp&#x2F;dtest</span><br><span class="line">#普通用户进入测试目录</span><br><span class="line">[user1@localhost dtest]$ touch abc</span><br><span class="line">#普通用户建立abc文件</span><br><span class="line">[user1@localhost dtest]$ ll</span><br><span class="line">总用量 0  </span><br><span class="line">-rw-rw-r--   1 user1 root 0 1月  20 06:07 abc</span><br><span class="line">#abc文件的默认属组不再是user1用户组，而变成了dtest组的属组root</span><br></pre></td></tr></table></figure><h3 id="文件特殊权限sticky-bit"><a class="markdownIt-Anchor" href="#文件特殊权限sticky-bit"></a> 文件特殊权限–Sticky BIT</h3><p>Stick BIT粘着位，也简称为SBIT目前仅针对目录有效，他的作用如下：</p><ul><li>粘着位目前只对目录有效</li><li>普通用户对该目录拥有&quot; w “和” x &quot;权限，即普通用户也可以在此目录拥有写权限</li><li>如果没有站着位，因为普通用户拥有&quot; w “权限，所以可以删除此目录下所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有” w &quot;权限，页只能删除自己建立的文件，但是不能删除其他用户建立的文件。</li></ul><h3 id="设定文件特殊权限"><a class="markdownIt-Anchor" href="#设定文件特殊权限"></a> 设定文件特殊权限</h3><p>特殊权限这样来表示：</p><ul><li>4代表SUID</li><li>2代表SGID</li><li>1代表SBIT</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod 4755 ftest</span><br><span class="line">#赋予SUID权限</span><br><span class="line">[root@localhost ~]# chmod 2755 ftest</span><br><span class="line">#赋予SGIS权限</span><br><span class="line">[root@localhost ~]# mkdir dtest</span><br><span class="line">[root@localhost ~]# chmod 1755 dtest&#x2F;</span><br><span class="line">#SBIT只对目录有效，所以建例测试目录，并赋予SBIT</span><br></pre></td></tr></table></figure><h2 id="文件系统属性chattr-权限"><a class="markdownIt-Anchor" href="#文件系统属性chattr-权限"></a> 文件系统属性chattr 权限</h2><ol><li>命令格式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chattr [+-&#x3D;] [选项] 文件或目录名</span><br><span class="line">选项：</span><br><span class="line">+：增加权限</span><br><span class="line">-：删除权限</span><br><span class="line">&#x3D;：等于权限</span><br><span class="line">i：如果对文件设置 i 属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置 i 属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。</span><br><span class="line">a：如果对文件设置 a 属性，那么只能在文件中增加数据，但是不能删除数据；如果对目录设置 a 属性，那么只允许在目录中建立和修改文件，但是不允许删除。</span><br><span class="line">e：Linux中绝大多数的文件都默认拥有 e 属性，表示该文件是使用ext文件系统进行存储的，而不能使用&quot;chattr -e&quot; 命令取消 e 属性。</span><br></pre></td></tr></table></figure><ol start="2"><li>查看文件系统属性lsattr</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsattr 选项 文件名</span><br><span class="line">选项：</span><br><span class="line">-a    显示所有文件和目录</span><br><span class="line">-d    若目标是目录，仅列出目录本身的属性，而不是子文件的</span><br></pre></td></tr></table></figure><p>3.举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">例1：</span><br><span class="line">#给文件赋予i属性</span><br><span class="line">[root@localhost ~]# touch ftest</span><br><span class="line">#建立测试文件</span><br><span class="line">[root@localhost ~]# chattr +i ftest </span><br><span class="line">[root@localhost ~]# rm -rf ftest </span><br><span class="line">rm: 无法删除&quot;ftest&quot;: 不允许的操作</span><br><span class="line">#赋予i属性后，root也不能删除</span><br><span class="line">[root@localhost ~]# echo 111 &gt;&gt; ftest </span><br><span class="line">-bash: ftest: 权限不够</span><br><span class="line">#也不能修改文件的数据</span><br><span class="line"></span><br><span class="line">#给目录赋予i属性</span><br><span class="line">[root@localhost ~]# mkdir dtest</span><br><span class="line">#建立测试目录</span><br><span class="line">[root@localhost dtest]# touch dtest&#x2F;abc</span><br><span class="line">#再建立一个测试文件abc </span><br><span class="line">[root@localhost ~]# chattr +i dtest&#x2F;</span><br><span class="line">#给目录赋予i属性</span><br><span class="line">[root@localhost ~]# cd dtest&#x2F;</span><br><span class="line">[root@localhost dtest]# touch bcd</span><br><span class="line"></span><br><span class="line">touch: 无法创建&quot;bcd&quot;: 权限不够</span><br><span class="line">#dtest目录不能新建文件</span><br><span class="line">[root@localhost dtest]# echo 11 &gt;&gt; abc</span><br><span class="line">[root@localhost dtest]# cat abc</span><br><span class="line">11 </span><br><span class="line">#但是可以修改文件内容</span><br><span class="line">[root@localhost dtest]# rm -rf abc </span><br><span class="line">rm: 无法删除&quot;abc&quot;: 权限不够</span><br><span class="line">#不能删除</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例2：</span><br><span class="line">[root@localhost ~]# mkdir -p &#x2F;back&#x2F;log</span><br><span class="line">#建立备份目录</span><br><span class="line">[root@localhost ~]# chattr +a &#x2F;back&#x2F;log&#x2F;</span><br><span class="line">#赋予a属性</span><br><span class="line">[root@localhost ~]# cp &#x2F;var&#x2F;log&#x2F;messages &#x2F;back&#x2F;log&#x2F;</span><br><span class="line">#可以复制文件和新建文件到指定目录</span><br><span class="line">[root@localhost ~]# rm -rf &#x2F;back&#x2F;log&#x2F;messages </span><br><span class="line">rm: 无法删除&quot;&#x2F;back&#x2F;log&#x2F;messages&quot;: 不允许的操作</span><br><span class="line">#但是不允许删除</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--用户管理</title>
      <link href="2020/10/17/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"/>
      <url>2020/10/17/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="用户相关文件"><a class="markdownIt-Anchor" href="#用户相关文件"></a> 用户相关文件</h2><h3 id="etcpsaawd-用户信息文件"><a class="markdownIt-Anchor" href="#etcpsaawd-用户信息文件"></a> /etc/psaawd  用户信息文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bas</span><br></pre></td></tr></table></figure><p>第一列：  用户名<br />第二列：  密码位<br />第三列：  用户ID</p><ul><li>0        超级用户UID。如果用户UID为0，代表这个账号是管理员账号。那linux中如何把 普通用户升级为管理员呢？就是把其他用户的UID修改为0既可以了，这点和Windows系统是不同的。不建议建立多个管理员账号。</li><li>1-499  系统用户 （伪用户）UID。这些UID账号是系统保留给系统用户的UID，也就是说UID是1-499范围内的用户是不能登陆系统的，而是用来运行系统或服务的。其中1-99是系统保留账号，系统自动创建。100-499是预留给用户创建系统账号的。</li><li>500-60000    普通用户UID。建立的普通用户UID从500开始，最大到60000.这些用户足够使用了，但是如果不够也不要担心，2.6.x内核以后的Linux系统用户UID已经可以支持2<sup>32</sup>这么多了</li></ul><p>第四列：组ID     GID添加用户时，如果不指定用户所属的初始组，那么会建立和用户名相同的组<br />第五列：     用户说明<br />第六列：     用户家目录<br />第七列：     登陆 shell         /bin/bash<br />如何把普通用户变为超级用户：吧用户UID改为０</p><h3 id="etcshadow-影子文件"><a class="markdownIt-Anchor" href="#etcshadow-影子文件"></a> /etc/shadow   影子文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$9w5Td6lg$bgpsy3olsq9WwWvS5Sst2W3ZiJpuCGDY.4w4MRk3ob&#x2F;i85fI38RH15wzVoomff9isV1PzdcXmixzhnMVhMxbv0:15775:0:99999:7:::</span><br></pre></td></tr></table></figure><p>第一列：用户名<br />第二列：加密密码</p><blockquote><p>我们也可以在密码前人为的加入&quot; ! &quot; 改变加密值让密码暂时失效，时这个用户无法登录，达到暂时禁止用户登陆的效果。<br />注意所有伪用户的密码都是“！！”,代表没有密码是不能登录的。当然我新创建的用户如果不设定密码，它的密码项也是“！！”，代表这个用户没有密码不能登录。<br />第三列：密码最近更改时间，1970年1月1日作为标准时间</p></blockquote><p>时间戳转日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# date -d &quot;1970-01-   01 15775 days&quot;</span><br><span class="line">2013年 03月 11日星期一 00:00:00 CST</span><br></pre></td></tr></table></figure><p>日期转时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo $(($(date --date&#x3D;&quot;2013&#x2F;03&#x2F;11&quot; +%s)&#x2F;86400+1))</span><br><span class="line">15775</span><br></pre></td></tr></table></figure><p>第四列：    两次密码的修改时间间隔（和第3字段相比）<br />第五列：    密码有效期（和第3字段相比）<br />第六列：    密码修改到期前警告天数（和第5字段相比）<br />第七列：    密码过期后的宽限天数（和第5字段相比）<br />第八列：    密码失效时间                    这里同样要写时间戳，也就是用1970年1月1日进行时间换算。如果超过了失效时间，就算密码没有过期，用户也就失效无法使用了<br />第九列：   保留</p><h3 id="etcgroup-组信息文件"><a class="markdownIt-Anchor" href="#etcgroup-组信息文件"></a> /etc/group     组信息文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:root</span><br></pre></td></tr></table></figure><p>第一列：组名<br />第二列：组密码位<br />第三列：GID<br />第四列：   此组支持的其他用户.附加组是此组的用户</p><ul><li>初始组：每个用户初始组只能有一个，一般都是和用户名相同的组作为初始组</li><li>附加组：每个用户可以属于多个附加组。要把用户加入组，都是附加组</li></ul><h3 id="组密码文件-etcgshadow"><a class="markdownIt-Anchor" href="#组密码文件-etcgshadow"></a> 组密码文件  /etc/gshadow</h3><blockquote><p>如果我给用户组设定了管理员，并给该用户组设定了组密码，组密码就保存在这个文件当中。组管理员就可以利用这个密码管理这个用户组了。</p></blockquote><h3 id="用户的家目录"><a class="markdownIt-Anchor" href="#用户的家目录"></a> 用户的家目录</h3><h3 id="用户邮箱目录"><a class="markdownIt-Anchor" href="#用户邮箱目录"></a> 用户邮箱目录</h3><blockquote><p>这个邮箱再/var/spool/mail 目录中，例如user1 用户的邮箱就是/var/spool/mail/user1 文件</p></blockquote><h3 id="用户模板目录"><a class="markdownIt-Anchor" href="#用户模板目录"></a> 用户模板目录</h3><blockquote><p>/etc/skel/</p></blockquote><h2 id="用户管理命令"><a class="markdownIt-Anchor" href="#用户管理命令"></a> 用户管理命令</h2><h3 id="添加用户"><a class="markdownIt-Anchor" href="#添加用户"></a> 添加用户</h3><ol><li>手工删除用户<br />手工删除用户试验：手工删除，如果可以正常建立用户，证明用户删除干净。<blockquote><p>/etc/passwd<br />/etc/shadow<br />/etc/group<br />/etc/gshadow<br />/home/user1<br />/var/spool/mail/user1</p></blockquote></li><li>useradd 命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd  选项  用户名</span><br><span class="line">选项：</span><br><span class="line">-u： 550 指定UID</span><br><span class="line">-g： 组名      指定初始组，不要手工指定</span><br><span class="line">-G： 组名      指定附加组，把用户加入组，使用附加组</span><br><span class="line">-c：  说明      添加说明</span><br><span class="line">-d： 目录       手工指定家目录，目录不需要事先建立</span><br><span class="line">-s：  shell       &#x2F;bin&#x2F;bash.</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd lamp1</span><br><span class="line">#先手工添加lamp1用户组，因为我一会要把lamp1用户的初始组指定过来，如果不事先建立，会报错用户组不存在</span><br><span class="line">[root@localhost ~]# useradd -u 550 -g lamp1 -G root -d &#x2F;home&#x2F;lamp1  \ -c &quot;test user&quot; -s &#x2F;bin&#x2F;bash lamp1 </span><br><span class="line">#建立用户lamp1的同时指定了UID（550），初始组（lamp1），附加组（root），家目录（&#x2F;home&#x2F;lamp1），用户说明(test user)和用户登录shell（&#x2F;bin&#x2F;bash）</span><br><span class="line">[root@localhost ~]# grep &quot;lamp1&quot; &#x2F;etc&#x2F;passwd &#x2F;etc&#x2F;shadow &#x2F;etc&#x2F;group</span><br><span class="line">#同时查看三个文件</span><br><span class="line">&#x2F;etc&#x2F;passwd:lamp1:x:550:502:test user:&#x2F;home&#x2F;lamp1:&#x2F;bin&#x2F;bash</span><br><span class="line">#用户的UID、初始组、用户说明、家目录和登录shell都和命令手工指定的一致</span><br><span class="line">&#x2F;etc&#x2F;shadow:lamp1:!!:15710:0:99999:7:::</span><br><span class="line">#lamp1用户还没有设定密码</span><br><span class="line">&#x2F;etc&#x2F;group:root:x:0:lamp1 </span><br><span class="line">#lamp1用户加入了root组，root组是lamp1用户的附加组</span><br><span class="line">&#x2F;etc&#x2F;group:lamp1:x:502:</span><br><span class="line">#GID502的组是lamp1组</span><br><span class="line">[root@localhost ~]# ll -d &#x2F;home&#x2F;lamp1&#x2F;</span><br><span class="line">drwx------ 3 lamp1 lamp1 4096 1月    6 01:13 &#x2F;home&#x2F;lamp1&#x2F; #家目录也建立了啊。不需要手工建立家目录</span><br></pre></td></tr></table></figure><ol start="3"><li>useradd 默认值<br />useradd 添加用户时参考的默认值文件主要有两个，分别是**/etc/default/useradd** 和 <strong>/etc/login.defs</strong></li></ol><ol><li>/etc/default/useradd</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;default&#x2F;useradd</span><br><span class="line"># useradd defaults file</span><br><span class="line">GROUP&#x3D;100</span><br><span class="line">HOME&#x3D;&#x2F;home</span><br><span class="line">INACTIVE&#x3D;-1</span><br><span class="line">EXPIRE&#x3D;</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">SKEL&#x3D;&#x2F;etc&#x2F;skel</span><br><span class="line">CREATE_MAIL_SPOOL&#x3D;yes</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>GROUP=100<br />这个选项是建立用户的默认组，也就是说添加每个用户时，用户的初始组就是GID为100的这个用户组。目前我们采用的机制私有用户组机制。</li><li>HOME=/home<br />这个选项是用户的家目录的默认位置，所以所有的新建用户的家目录默认都在/home/下。</li><li>INACTIVE=-1<br />这个选项就是密码过期后的宽限天数，也就是/etc/shadow 文件的第七个字段。如果是天数，比如10 代表密码过期后10天后失效；如果是0，代表密码过期后立即失效；如果是-1，则代表密码永远不会失效。这里默认值是-1，所以所有新建立的用户密码都不会失效。</li><li>EXPIRE=<br />这个选项是密码失效时间，也就是/etc/shadow 文件的第八个字段。也就是说用户达到这个日期后就会直接失效。当然这里也是使用时间戳来表示日期。默认值是空，所以所有新建用户没有失效时间，永久有效。</li><li>SHELL=/bin/bash、<br />这个选项是用户的默认值 shell 的。/bin/bash 是Linux的标志shell，所以所有新建立的用户默认都具备shell复制的权限。</li><li>SKEL=/etc/skel<br />这个选项就是定义用户的模板目录的位置，/etc/skel/目录中的文件都会复制到新建用户的家目录当中。</li><li>CREATE_MAIL_SPOOL=yes<br />这个选项定义是否给新建用户建立邮箱，默认是创建，也就是说所有的新建用户系统都会新建一个邮箱，放在/var/spool/mail/下和用户名相同。</li></ul><p>2）/etc/login.defs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vi &#x2F;etc&#x2F;login.defs</span><br><span class="line">#这个文件有些注释，把注释删掉，文件内容就变成下面这样了</span><br><span class="line">MAIL_DIR                &#x2F;var&#x2F;spool&#x2F;mail</span><br><span class="line"></span><br><span class="line">PASS_MAX_DAYS            99999</span><br><span class="line">PASS_MIN_DAYS             0</span><br><span class="line">PASS_MIN_LEN                5</span><br><span class="line">PASS_WARN_AGE            7</span><br><span class="line"></span><br><span class="line">UID_MIN                          500</span><br><span class="line">UID_MAX                         60000</span><br><span class="line"></span><br><span class="line">GID_MIN                          500</span><br><span class="line">GID_MAX                         60000</span><br><span class="line"></span><br><span class="line">CREATE_HOME         yes</span><br><span class="line"></span><br><span class="line">UMASK            077</span><br><span class="line"></span><br><span class="line">USERGROUPS_ENAB      yes</span><br><span class="line"></span><br><span class="line">ENCRYPT_METHOD  SHA512</span><br></pre></td></tr></table></figure><p>文件内容解释如下：</p><ul><li>MAIL_DIR            /var/spool/mail<br />这行指定了新建用户的默认邮箱位置。比如 user1 用户的邮箱是就是/var/spool/mail/user1 。</li><li>PASS_MAX_DAYS     99999<br />这行指定的是密码的有效期，也就是/etc/shadow 文件的第五字段。代表多少天之后必须修改密码，默认值是 99999。</li><li>PASS_MIN_DAYS    0<br />这行指定的是两次密码的修改间隔时间，也就是/etc/shadow 文件的第四字段。代表第一次修改密码之后，几天才能再次修改密码。默认值是0。</li><li>PASS_MIN_LEN    5<br />这行代表密码的最小长度，默认不小于5位。但是我们现在用户登录时验证已经被PAM模块取代，所以这个选项并不生效。</li><li>PASS_WARN_AGE    7<br />这行代表密码修改到期前的警告天数，也就是/etc/shadow 文件的第六字段。代表密码到底有效前期多少天开始进行警告提醒，默认值是7天。</li><li>UID_MIN             500</li><li>UID_MAX            60000<br />这两行代表创建用户时，最小UID 和最大的UID 的范围。我们2.6.x 内核开始，Linux用户的UID最大可以支持2<sup>32</sup>这么多，但是真正使用时最大范围是60000。还要主要如果我手工制定了一个用户的UID 是550，那么下一个创建的用户的UID就会从551开始，哪怕 500-549 之间的UID没有使用（小于500的UID是给伪用户预留的）。</li><li>GID_MIN      500</li><li>GID_MAX      60000<br />这两行指定了GID的最小值和最大值之间的范围</li><li>CREATE_HOME         yes<br />这行指定建立用户时是否自动建立用户的家目录，默认是建立</li><li>UMASK         077<br />这行指定的是建立的用户家目录的默认权限，因为umask值是077，所以新建的用户家目录的权限是700，umask的具体作用和修改方法我们可以参考下一章权限设定章节。</li><li>USERGROUPS_ENAB        yes<br />这行指定的是使用命令userdel 删除用户时，是否删除用户的初始组，默认是删除。</li><li>ENCRYPT_METHOD               SHA512<br />这行指定Linux 用户的密码使用 SHA512 散列模式加密，这时新的密码加密模式，原先的Linux只能用DES或MD5 方式加密</li></ul><h3 id="设定密码"><a class="markdownIt-Anchor" href="#设定密码"></a> 设定密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd  [选项]  用户名</span><br><span class="line">选项：</span><br><span class="line">-l：        暂时许哦顶用户。仅root用户可用</span><br><span class="line">-u：       解锁用户。仅root用户可用</span><br><span class="line">--stdin：      可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# passwd</span><br><span class="line">#passwd 直接回车代表修改当前用户的密码</span><br></pre></td></tr></table></figure><p>也可以使用字符串作为密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;123&quot;  | passwd  -stdin  user1</span><br><span class="line">#更改用户user1 的密码</span><br></pre></td></tr></table></figure><p>可以通过命令，把密码修改日期归零 （shadow第三字段）。这样用户一登陆就要修改密码，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  chage -d 0  user1</span><br></pre></td></tr></table></figure><h3 id="用户信息修改"><a class="markdownIt-Anchor" href="#用户信息修改"></a> 用户信息修改</h3><p>usermod 命令是修改已经添加的用户的信息的，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# usermod  [选项]  用户名</span><br><span class="line">选项：</span><br><span class="line">-u  UID:       修改用户的UID</span><br><span class="line">-d  家目录:     修改用户的家目录。家目录必须写绝对路径</span><br><span class="line">-c  用户说明:     修改用户的说明信息，就是&#x2F;而通常&#x2F;passwd 文件的第五个字段</span><br><span class="line">-g  组名:       修改用户的初始组，就是&#x2F;etc&#x2F;passwd 文件的第四个字段</span><br><span class="line">-G  组名:       修改用户的附加组，其实就是把用户加入其他用户组</span><br><span class="line">-s  shell:     修改用户的登录Shell。默认是&#x2F;bin&#x2F;bash</span><br><span class="line">-e  日期:       修改用户的失效日期，格式为&quot;YYYY-MM-DD&quot;。也就是&#x2F;etc&#x2F;shadow文件的第八个字段</span><br><span class="line">-L：            临时锁定用户（Lock）</span><br><span class="line">-U：            解锁用户（Unlock）</span><br></pre></td></tr></table></figure><p>用户修改用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# usermod  -l  新名  旧名</span><br><span class="line">#改名</span><br></pre></td></tr></table></figure><p>不建议修改用户名，建议直接删除旧用户，再建立新用户。</p><h3 id="删除用户"><a class="markdownIt-Anchor" href="#删除用户"></a> 删除用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  userdel  [-r]  用户名</span><br><span class="line">选项：</span><br><span class="line">-r：               在删除用户的同时删除用户的家目录</span><br></pre></td></tr></table></figure><h3 id="切换用户身份"><a class="markdownIt-Anchor" href="#切换用户身份"></a> 切换用户身份</h3><p>su命令可用切换成不同的用户身份，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su  [选项]  用户名</span><br><span class="line">选项：</span><br><span class="line">-：                选项只使用&quot; - &quot; 代表连带用户的环境变量一起切换</span><br><span class="line">-c 命令：           仅执行一次命令，而不切换用户身份</span><br></pre></td></tr></table></figure><p>&quot; - &quot; 不能省略，它代表切换用户身份时，用户的环境变量也要切换成新用户的环境变量。</p><h2 id="组管理命令"><a class="markdownIt-Anchor" href="#组管理命令"></a> 组管理命令</h2><h3 id="添加用户组groupadd"><a class="markdownIt-Anchor" href="#添加用户组groupadd"></a> 添加用户组：groupadd</h3><p>添加用户组的命令是groupadd，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  groupadd  group1</span><br><span class="line">#添加group1 组</span><br><span class="line">[root@localhost ~]# grep  &quot;group1&quot;  &#x2F;etc&#x2F;group</span><br><span class="line">group1:x:502</span><br></pre></td></tr></table></figure><h3 id="删除用户组groupdel"><a class="markdownIt-Anchor" href="#删除用户组groupdel"></a> 删除用户组：groupdel</h3><p>groupdel命令用于删除用户组，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupdel  组名</span><br><span class="line">例：</span><br><span class="line">[root@localhost ~]# groupdel  testgrp</span><br><span class="line">#删除 testgrp 组</span><br></pre></td></tr></table></figure><p>不过要注意，要删除的组不能是其他用户的初始组，也就是说这个组中没有初始用户才可以删除。如果组中有附加用户，则删除组时不受影响。</p><h3 id="把用户添加进组或从组中删除gpasswd"><a class="markdownIt-Anchor" href="#把用户添加进组或从组中删除gpasswd"></a> 把用户添加进组或从组中删除：gpasswd</h3><p>其实gpasswd命令是用来设定组密码并指定组管理员的，不过我们在前面已经说了，组密码和组管理员功能很少使用，而且完全可以被sudo命令取代，所以gpasswd命令现在主要用于把用户添加进组或从组中删除。命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gpasswd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">-a 用户名：把用户加入组</span><br><span class="line">-d 用户名：把用户从组中删除</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd grouptest </span><br><span class="line">#添加组grouptest  </span><br><span class="line">[root@localhost ~]# gpasswd -a user1 grouptest </span><br><span class="line">Adding user user1 to group grouptest</span><br><span class="line">#把用户user1加入grouptest组</span><br><span class="line">[root@localhost ~]# grep &quot;user1&quot; &#x2F;etc&#x2F;group </span><br><span class="line">user1:x:501: </span><br><span class="line">grouptest:x:505:user1 </span><br><span class="line">#查看一下，user1用户已经作为附加用户加入grouptest组</span><br><span class="line">[root@localhost ~]# gpasswd -d user1 grouptest </span><br><span class="line">Removing user user1 from group grouptest</span><br><span class="line">#把用户user1从组中删除</span><br><span class="line">[root@localhost ~]# grep &quot;grouptest&quot; &#x2F;etc&#x2F;group </span><br><span class="line">grouptest:x:505:</span><br><span class="line">#组中没有user1用户了</span><br></pre></td></tr></table></figure><p>大家注意，也可以使用usermod命令把用户加入某个组，不过usermod命令的操作对象是用户，命令是“usermod -G grouptest user1”，把用户名作为参数放在最后；而gpasswd命令的操作对象是组，命令是“gpasswd -a user1 grouptest”，把组名作为参数放在最后。</p><h3 id="改变有效组newgrp"><a class="markdownIt-Anchor" href="#改变有效组newgrp"></a> 改变有效组：newgrp</h3><p>我们说过，每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？当然是初始用户组的组身份生效了，因为初始组是用户一旦登录就直接获得的组身份。也就是说，用户在创建文件后，文件的属组是用户的初始组，因为用户的有效组默认是初始组。<br />既然用户属于多个用户组，那么能不能改变用户的有效组呢？使用命令newgrp就可以切换用户的有效组。命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# newgrp 组名</span><br></pre></td></tr></table></figure><p>举个例子，我们已经有了普通用户user1，默认会建立user1用户组，user1组是user1用户的初始组。我们再把user1用户加入group1组，那么group1组就是user1用户的附加组。当user1用户创建文件test1时，test1文件的属组是user1组，因为user1组是user1用户的有效组。通过newgrp命令就可以把user1用户的有效组变成group1组，当user1用户创建文件test2时，就会发现test2文件的属组就是group1组。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd group1 </span><br><span class="line">#添加组group1 </span><br><span class="line">[root@localhost ~]# gpasswd -a user1 group1 </span><br><span class="line">Adding user user1 to group group1</span><br><span class="line">#把user1用户加入group1组</span><br><span class="line">[root@localhost ~]# grep &quot;user1&quot; &#x2F;etc&#x2F;group </span><br><span class="line">user1:x:501: </span><br><span class="line">group1:x:503:user1 </span><br><span class="line">#user1用户既属于user1组，也属于group1组</span><br><span class="line">[root@localhost ~]# su – user1 #切换成user1身份，超级用户切换成普通用户不用密码</span><br><span class="line">[user1@localhost ~]$ touch test1</span><br><span class="line"></span><br><span class="line">#创建文件test1 </span><br><span class="line">[user1@localhost ~]$ ll test1</span><br><span class="line">-rw-rw-r-- 1 user1 user1 0 1月    14 05:43 test1</span><br><span class="line">#test1文件的默认属组是user1组</span><br><span class="line">[user1@localhost ~]$ newgrp group1</span><br><span class="line">#切换user1用户的有效组为group1组</span><br><span class="line">[user1@localhost ~]$ touch test2</span><br><span class="line">#创建文件test2 </span><br><span class="line">[user1@localhost ~]$ ll test2</span><br><span class="line">-rw-r--r-- 1 user1 group1 0 1月  14 05:44 test2 </span><br><span class="line">#test2文件的默认属组是group1组</span><br></pre></td></tr></table></figure><p>通过这个例子明白有效组的作用了吗？其实就是当用户属于多个组时，在创建文件时哪个组身份生效。使用newgrp命令可以在多个组身份之间切换。</p>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--软件包管理(3)</title>
      <link href="2020/10/15/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86(3)/"/>
      <url>2020/10/15/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86(3)/</url>
      
        <content type="html"><![CDATA[<h2 id="源码包安装"><a class="markdownIt-Anchor" href="#源码包安装"></a> 源码包安装</h2><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><ol><li><p>应该选择哪种软件包？</p><ul><li>如果软件包是给大量客户提供访问，建议使用源码包安装，如LAMP环境搭建，因为源码包效率更高。</li><li>如果软件包是给Linux底层使用，或只给少量客户访问，建议使用rpm包安装，因为rpm包简单。</li></ul></li><li><p>源码包是从哪里来？<br />rpm包是光盘中直接包含的，所以不需要用户单独下载。而源码包是通过官方网站下载的，如果需要使用，是需要单独下载的。</p></li><li><p>是否可以在系统中既安装rpm包的Apache，又安装源码包的Apache？<br />答案是可以，因为两种安装方法安装的Apache，安装位置是不一样的，例如：（背）</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RPM 包：不建议指定安装位置，建议安装在more位置（RPM包安装的服务又标准卸载命令，不怕文件到处都是）。</span><br><span class="line">配置文件：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">网页位置：&#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">日志位置：&#x2F;varlog&#x2F;httpd&#x2F;</span><br><span class="line">启动方法：1）service  httpd  restart</span><br><span class="line">                 2）&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd  restart</span><br><span class="line"></span><br><span class="line">源码包：必须指定安装位置（源码包没有安装数据库，没有删除命令）</span><br><span class="line">配置文件：&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf&#x2F;httpd.conf</span><br><span class="line">网页文件：&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;htdocs&#x2F;</span><br><span class="line">日志位置：&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;logs&#x2F;</span><br><span class="line">启动方法：&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;bin&#x2F;apachectl  start</span><br></pre></td></tr></table></figure><ol start="4"><li>生产服务器上，是否会同时安装两种Apache？<br />不会，因为系统中只有一个80端口，所以只能启动一个Apache，装多个只能浪费资源。我们建议安装源码包的Apache。</li></ol><h3 id="安装过程"><a class="markdownIt-Anchor" href="#安装过程"></a> 安装过程</h3><p>源码包安装的具体步骤：<br />(1) 下载软件包<br />(2) 解压缩<br />(3) 进入解压目录<br />(4)  ./configure            编译前准备<br />这一步主要有三个作用：</p><pre><code>① 在安装之前需要检测环境是否符合安装要求。② 定义需要的功能选项。 &quot;./configure&quot; 支持的功能选项较多，可以执行&quot;./configure --help&quot; 命令查询其支持的功能。一般不会通过“./configure --prefix=安装路径”来指定安装路径。③ 把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。#注意configure不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用&quot;./configure&quot; 方式执行（&quot;./&quot;代表在当前目录下）。</code></pre><p>(5) make         编译<br />make 会调用gcc编译器，并读取Makefile文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被Linux识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时间，需要有足够的耐心。<br />(6) make clean : 清空编译内容（非必须步骤）<br />如果在&quot;./configure&quot; 或&quot;make&quot; 编译中报错，那么我们在重新执行命令前一定要记得执行makeclean命令，它会清空Makefile文件或编译产生的&quot;.o&quot;头文件。<br />(7) make install:  编译安装<br />这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个命令的执行过程保存下来，已被将来删除使用。</p><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>源码包没有删除命令，如果需要删除，直接删除安装目录即可。</p><h3 id="打入补丁"><a class="markdownIt-Anchor" href="#打入补丁"></a> 打入补丁</h3><ol><li>补丁的生成</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# diff  选项  old  new</span><br><span class="line">#比较old和new文件的不同</span><br><span class="line">选项：</span><br><span class="line">-a： 将任何文档当做文本文档处理</span><br><span class="line">-b： 忽略空格造成的不同</span><br><span class="line">-B： 忽略空白行造成的不同</span><br><span class="line">-I： 忽略大小写造成的不同</span><br><span class="line">-N： 当比较两个目录时，如果某个文件只在一个目录中，则在另一个目录中视做空文件</span><br><span class="line">-r： 当比较目录时，递归比较子目录</span><br><span class="line">-u： 使用同一的输出格式</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir  test</span><br><span class="line">#建立测试目录</span><br><span class="line">[root@localhost ~]# cd  test</span><br><span class="line">#进入测试目录</span><br><span class="line">[root@localhost test]# vi old.txt</span><br><span class="line">our</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">atguigu</span><br><span class="line">#文件old.txt，为了一会输出便于比较，每行分开</span><br><span class="line">[root@localhost test]# vi  new.txt</span><br><span class="line">our</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">atguigu</span><br><span class="line">in</span><br><span class="line">Beijing</span><br><span class="line">#文件new.txt</span><br></pre></td></tr></table></figure><p>比较下两个文件的不同，并生成补丁文件&quot;txt.patch&quot;,命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# diff  -Naur  &#x2F;root&#x2F;test&#x2F;old.txt  &#x2F;root&#x2F;test&#x2F;new.txt  &gt;  txt.patch</span><br><span class="line">#比较两个文件的不同，同时生成txt.patch补丁文件</span><br><span class="line"></span><br><span class="line">[root@localhost test]# vi  txt.patch</span><br><span class="line">#查看下这个文件</span><br><span class="line">---  &#x2F;root&#x2F;test&#x2F;old.txt      2012-11-23  05:51:14.347954373  +0800</span><br><span class="line">#前一个文件</span><br><span class="line">+++  &#x2F;root&#x2F;test&#x2F;new.txt      2012-11-23  05:50:05.772988210  +0800</span><br><span class="line">#后一个文件</span><br><span class="line">@@  -2,3  +2,5  @@</span><br><span class="line"> scholl</span><br><span class="line"> is</span><br><span class="line"> atguigu</span><br><span class="line">+in</span><br><span class="line">+beijing</span><br></pre></td></tr></table></figure><p>#后一个文件比前一个文件多两行（+表示）</p><ol start="2"><li>打入补丁</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# patch  -pn &lt; 补丁文件</span><br><span class="line">#按照补丁文件进行更新</span><br><span class="line">选项：</span><br><span class="line">-pn      n为数字。代表按照补丁文件中的路径，指定更新文件的位置。</span><br></pre></td></tr></table></figure><p>“-pn” 不好理解，我们说明一下。补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中的记录的目的是不一定匹配的，所以就需要&quot;-pn&quot; 来同步两个目录。<br />比如我当前是在&quot;/root/test&quot; 目录中（我要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为&quot;/root/test/old.txt&quot;,这时如果写入&quot;-pl&quot; (在补丁文件目录中取消一级目录)那么补丁文件就会打入&quot;/root/test/root/test/old.txt&quot; 文件中，这显然是不对的。那如果写入的是&quot;-p2&quot; (在补丁文件目录中取消二级目录) 那么补丁文件打入的就是&quot;/root/test/test/old.txt&quot; ,这显然也不对。如果写入的是&quot;-p3&quot;（在补丁文件目录中取消三级目录）那么补丁文件就是打入的&quot;/root/test/old.txt&quot; , 我们的 old.txt 文件就在这个目录下，所以就应该是&quot;-p3&quot;.<br />那么我们更新下&quot;old.txt&quot; 文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# patch  -p3  &lt; txt.patch</span><br><span class="line">patching  file  old.txt</span><br><span class="line">#给old.txt 文件打补丁</span><br><span class="line"></span><br><span class="line">[root@localhost test]# cat  old.txt</span><br><span class="line">#查看一下old.txt的内容</span><br><span class="line">our</span><br><span class="line">school</span><br><span class="line">is</span><br><span class="line">atguigu</span><br><span class="line">in</span><br><span class="line">Beijing</span><br><span class="line">#多出来了in Beijing 两行</span><br></pre></td></tr></table></figure><h2 id="脚本安装程序"><a class="markdownIt-Anchor" href="#脚本安装程序"></a> 脚本安装程序</h2><h3 id="脚本程序简介"><a class="markdownIt-Anchor" href="#脚本程序简介"></a> 脚本程序简介</h3><p>脚本程序包并不多见，所以在软件包分类中并没有把它列为一类。它更加类似于与Windows下的程序安装，有一个可执行的安装程序，只要运行安装程序，然后进行简单的功能定制选择（比如指定安装目录等），就可以安装成功，只不过实在字符界面下完成的。<br />目前常见的脚本程序以各类硬件的驱动居多，我们需要学习一下这类软件的安装方式，以备将来不时之需。</p><h3 id="webmin-安装-脚本程序包安装实例"><a class="markdownIt-Anchor" href="#webmin-安装-脚本程序包安装实例"></a> Webmin 安装 （脚本程序包安装实例）</h3><ol><li>简介<br />我们来看看脚本程序如何安装和使用。安装一个叫做Webmin 的工具软件，Webmin是一个基于Web的系统管理界面。借助任何支持表格和表单的浏览器（和File Manager 模块所需要的Java ），你就可以设置用户账号、apache、DNS、文件共享等。Webmin 包括一个简单的Web服务器和许多CGI程序，这些程序可以直接修改系统文件，比如/etc/inetd.conf 和/etc/passwd。Web服务器和所有的CGI程序都是用Perl 5编写的，没有使用任何非标准Perl模块。也就是说，Webmin是一个用Perl语言写的、可以通过浏览器管理linux的软件。</li><li>安装步骤<br />首先下载Webmin软件，地址为http:sourceforge.net/projects/webadmin/file/webmin/,这里下载的是webmin-1.610.tar.gz 。<br />接下来解压软件，目录如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tar  -zxvf  webmin-1.61..tar.gz</span><br></pre></td></tr></table></figure><p>进入解压目录，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd  webmin-1.610</span><br></pre></td></tr></table></figure><p><a href="http://xn--setup-ff8is4p4yijr1ds13acdb.sh">执行安装程序setup.sh</a> ,并指定功能选项，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost webmin-1.610]# .&#x2F;setup.sh</span><br><span class="line">****************************************************************************************</span><br><span class="line">*                  welcome to the Webmin setup script, version 1.610                     *</span><br><span class="line">****************************************************************************************</span><br><span class="line">Webmin is a web-based interface that allows Unix-like operating</span><br><span class="line">systems and common Unix services to be easily administered.</span><br><span class="line"></span><br><span class="line">Installing Webmin in &#x2F;root&#x2F;wenmin-1.610 ...</span><br><span class="line"></span><br><span class="line">****************************************************************************************</span><br><span class="line">Webmin uses separate directories for configuration files and log files.</span><br><span class="line">Unless you want to run multiple versions of Webmin at the same time you can just accept the defaults.</span><br><span class="line"></span><br><span class="line">Config file directory [&#x2F;etc&#x2F;webmin] :</span><br><span class="line">#选择安装位置，默认安装在&#x2F;etc&#x2F;webmin 目录下。如果安装到默认位置，则直接回车</span><br><span class="line">Log file directory [&#x2F;var&#x2F;webmin] :</span><br><span class="line">#日志文件保存位置，直接回车，选择默认位置</span><br><span class="line">*****************************************************************************************</span><br><span class="line">Webmin is written entirely in Perl. Please enter the full path to the Perl 5 interpreter on your system.</span><br><span class="line"></span><br><span class="line">Full path to perl (default &#x2F;usr&#x2F;bin&#x2F;perl) :</span><br><span class="line">#指定Perl 语言的安装位置，直接回车，选择默认位置，Perl默认就安装在这里</span><br><span class="line">Testing Perl ...</span><br><span class="line">Perl seem to be installed ok</span><br><span class="line"></span><br><span class="line">*****************************************************************************************</span><br><span class="line">Operating system name :         CentOS Linux </span><br><span class="line">Operating system version: 6.3</span><br><span class="line"></span><br><span class="line">*****************************************************************************************</span><br><span class="line">Webmin uses its own password portected web server to provide access</span><br><span class="line">to the administration programs. The setup script needs to know :</span><br><span class="line">- what port to run the web server on .There must not be another web server already using this port.</span><br><span class="line">- The login name required to access the web server.</span><br><span class="line">- The password required to access the web server.</span><br><span class="line">- If the webserver should use SSL (if your system supports it) .</span><br><span class="line">- whether to start webmin at boot time.</span><br><span class="line"></span><br><span class="line">web server port (default 10000) :</span><br><span class="line">#指定Webmin 监听的端口，直接回车，默认选定10000</span><br><span class="line">Login name (default admin) : admin</span><br><span class="line">#输入登录Webmin的用户名</span><br><span class="line">Login password:</span><br><span class="line">Password again:</span><br><span class="line">#输入登录密码</span><br><span class="line">The Perl SSLeay library is not installed. SSL not available</span><br><span class="line">#apache 默认没有启动SSL功能，所以SSL没有被激活</span><br><span class="line">Start Webmin at boot time (y&#x2F;n) : y</span><br><span class="line">#是否在开机的同时启动Webmin</span><br><span class="line">...安装过程省略...</span><br><span class="line">Webmin has been installed and started successfully.Use your web browser to go to</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;localhost:10000&#x2F;</span><br><span class="line"></span><br><span class="line">and login with the name and password you entered perviously.</span><br><span class="line">#安装完成</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--软件包管理(2)</title>
      <link href="2020/10/08/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86(2)/"/>
      <url>2020/10/08/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86(2)/</url>
      
        <content type="html"><![CDATA[<h3 id="rpm包在线安装yum安装"><a class="markdownIt-Anchor" href="#rpm包在线安装yum安装"></a> rpm包在线安装（yum安装）</h3><h4 id="yum源文件解析"><a class="markdownIt-Anchor" href="#yum源文件解析"></a> yum源文件解析</h4><pre><code>yum源配置文件保存在**/etc/yum.repos.d** 目录中，文件的扩展名一定是 ”*.repo“。也就是说，yum源配置文件只要扩展名是“*.repo&quot;就会生效。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls  &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">CentOS-Base.repo  CentOS-Debuginfo.repo  CentOS-Media.repo    CentOS-Vault.repo</span><br><span class="line"> CentOS-fasttrack.repo  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个目录有7个yum源配置文件，弄人情况下CentOS-Base.repo  文件生效。我们打开这个文件看看，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# vim &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo </span><br><span class="line"></span><br><span class="line">[base]</span><br><span class="line">name&#x3D;CentOS-$releasever - Base</span><br><span class="line">mirrorlist&#x3D;http:&#x2F;&#x2F;mirrorlist.centos.org&#x2F;?release&#x3D;$releasever&amp;arch&#x3D;$basearch&amp;rep    o&#x3D;os&amp;infra&#x3D;$infra</span><br><span class="line">#baseurl&#x3D;http:&#x2F;&#x2F;mirror.centos.org&#x2F;centos&#x2F;$releasever&#x2F;os&#x2F;$basearch&#x2F;</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br><span class="line">....省略部分输出....</span><br></pre></td></tr></table></figure><p>在CentOS-Base.repo 文件中有5个yum源容器，这里只列出了base容器，其他容器和base容器类似。我们解释一下base这个容器。</p><ul><li>[base]：容器名称，一定要放在[ ] 中。</li><li>name：容器说明，可以自己随便写。</li><li>mirrorlist：镜像站点，这个可以注释掉。</li><li>baseurl：我们的yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的。如果你觉得蛮，则可以改成你喜欢的yum源地址。</li><li>enable：此容器是否生效，如果不写或携程enable=1，则表示此容器生效，携程enable=0则不生效。</li><li>gpgcheck：如果为 1 则表示RPM的数字证书生效；如果为 0 则表示RPM的数字证书。</li><li>gpgkey：数字证书的公钥文件保存位置。不用修改。</li></ul><h4 id="搭建本地光盘yum源"><a class="markdownIt-Anchor" href="#搭建本地光盘yum源"></a> 搭建本地光盘yum源</h4><p>第一步：放入CentOS安装光盘，并挂载到指定位置。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mkdir  &#x2F;mnt&#x2F;cdrom</span><br><span class="line">#创建cdrom 目录，作为光盘的挂载点</span><br><span class="line">[root@localhost ~]#  mount  &#x2F;dev&#x2F;cdrom  &#x2F;mnt&#x2F;cdrom&#x2F;</span><br><span class="line">mount：block device  &#x2F;dev&#x2F;sr0 is write-portected，mount read-only</span><br><span class="line">#挂载光盘到&#x2F;mnt&#x2F;cdrom 目录下</span><br></pre></td></tr></table></figure><p>第二步：修改其他几个yum源配置文件的扩展名，让他们失效，因为只有扩展名是&quot;*.repo&quot;的文件才能作为yum源配置文件。当然也可以删除其他几个域名源配置文件，但是如果删除了，当你再次想用网络作为域名源时，就没有了参考文件，所有做好还是修改扩展名。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cd &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">[root@localhost yum.repos.d]# mv  CentOS-Base.repo  CentOS-Base.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]# mv  CentOS-Debuginfo.repo  CentOS-Debuginfo.repo.bak</span><br><span class="line">[root@localhost yum.repos.d]# mv  CentOS-Vault.repo  CentOS-Vault.repo.bak</span><br></pre></td></tr></table></figure><p>第三步：修改光盘yum源配置文件CentOS-Media.repo,参照一下方法修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[c7-media]</span><br><span class="line">name&#x3D;CentOS-$releasever - Media</span><br><span class="line">baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;media&#x2F;cdrom</span><br><span class="line">#地址为你自己的光盘挂载地址</span><br><span class="line">#         file:&#x2F;&#x2F;&#x2F;media&#x2F;cdrom&#x2F;</span><br><span class="line">#         file:&#x2F;&#x2F;&#x2F;media&#x2F;cdrecorder&#x2F;</span><br><span class="line">#注释掉这两个不存在的地址</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">#把enable&#x3D;0 改为enable&#x3D;1，让这个yum源配置文件生效</span><br><span class="line">gpgkey&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-7</span><br></pre></td></tr></table></figure><p>配置完成，现在可以感受一下yum的便捷了。</p><h4 id="yum命令"><a class="markdownIt-Anchor" href="#yum命令"></a> yum命令</h4><ol><li>查询</li></ol><ul><li>查询yum 源服务器上所有可安装的软件包列表。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]#  yum  list</span><br><span class="line">#查询所有可用软件包列表</span><br><span class="line">Installed Packages</span><br><span class="line">#已经安装的软件包</span><br><span class="line">ConsoleKit.i686  0.4.1-3.el6  @anaconda-CentOS-201207051201.i386&#x2F;6.3</span><br><span class="line">ConsoleKit-Libs.i686  0.4.1-3.el6  @anaconda-CentOS-201207051201.i386&#x2F;6.3</span><br><span class="line">...省略部分输出...</span><br><span class="line">Available Packages</span><br><span class="line">#还可以安装的软件包</span><br><span class="line">389-ds-base.i686                           1.2.10.2-15.el6                c6-media</span><br><span class="line">389-ds-base-devel.i686                    1.2.10.2-15.el6                 c6-media</span><br><span class="line">#软件名                                               版本                                  所在位置（光盘）</span><br><span class="line">...省略部分输出...</span><br></pre></td></tr></table></figure><ul><li>查询yum源服务器中是否包含某个软件包。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum  list  包名</span><br><span class="line">#查询单个软件包</span><br><span class="line">例如：</span><br><span class="line">[root@localhost yum.repos.d]# yum  list  samba</span><br><span class="line">Available  Packages</span><br><span class="line">samba.i686                          3.5.10-125.el6                      c6-media</span><br></pre></td></tr></table></figure><ul><li>搜索yum源服务器上所有和关键字相关的软件包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum search  关键字</span><br><span class="line">#搜索服务器上所有和关键字相关的软件包</span><br><span class="line">例如：</span><br><span class="line">[root@192 ~]# yum search ifconfig</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Repodata is over 2 weeks old. Install yum-cron? Or run: yum makecache fast</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.aliyun.com</span><br><span class="line"> * extras: mirrors.aliyun.com</span><br><span class="line"> * updates: mirrors.aliyun.com</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 匹配：ifconfig &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">net-tools.x86_64 : Basic networking tools</span><br></pre></td></tr></table></figure><p>yum search 搜索可以用于确定某个软件在哪个相关包中。此例可以确定”ifconfig“命令需要安装”net-tools“包。</p><ul><li>查询指定软件包的信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum  info  samba</span><br><span class="line">#查询samba软件包信息</span><br><span class="line">Available  Packages                      ←还没有安装</span><br><span class="line">Name                   ：samba           ←包名</span><br><span class="line">Arch                      ：i686              ←适合的硬件平台</span><br><span class="line">Version                 ：3.5.10            ←版本</span><br><span class="line">Release                 ：125.el6          ←发布版本</span><br><span class="line">Size                       ：4.9M             ←大小</span><br><span class="line">Repo                     ：c6-media      ←在光盘上</span><br><span class="line">....省略部分输出....</span><br></pre></td></tr></table></figure><ol start="2"><li>安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum  -y  install  包名</span><br><span class="line">选项：</span><br><span class="line">install：   安装</span><br><span class="line">-y：        自动回答yes。如果不加-y，那么每个安装的软件都需要手工回答yes</span><br><span class="line">例如：</span><br><span class="line">[root@localhost yum.repos.d]# yum  -y  install  gcc</span><br><span class="line">#使用yum自动安装gcc</span><br></pre></td></tr></table></figure><ol start="3"><li>升级</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum  -y  update  包名</span><br><span class="line">#升级指定的软件包</span><br><span class="line">选项：</span><br><span class="line">update：           升级</span><br><span class="line">-y ：             自动回答yes</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 在进行升级操作时，yum源服务器中软件包的版本要比本机安装的软件包的版本高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]#  yum  -y  update</span><br><span class="line">#升级本机所有软件包</span><br></pre></td></tr></table></figure><p>这条命令会升级系统中所有的软件包。不过我们生产服务器是稳定优先的，所以这种全系统升级的情况并不多见。</p><ol start="4"><li>卸载<br />再次强调一下，除非确定卸载的软件的依赖包不会对系统产生影响，否则不要执行yum卸载，因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就有可能导致系统崩溃。卸载命令如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost yum.repos.d]# yum  remove  包名</span><br><span class="line">#卸载指定的软件包</span><br><span class="line">例如：</span><br><span class="line">[root@localhost yum.repos.d]# yum  remove  samba</span><br><span class="line">#卸载samba软件包</span><br></pre></td></tr></table></figure><h4 id="yum组管理命令"><a class="markdownIt-Anchor" href="#yum组管理命令"></a> yum组管理命令</h4><ul><li>查询可以安装的软件组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum  grouplist</span><br><span class="line">#列出所有可用的软件组列表</span><br></pre></td></tr></table></figure><ul><li>查询软件组包含的软件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum  groupinfo  软件组名</span><br><span class="line">#列出软件组中包含的软件</span><br><span class="line">列出：</span><br><span class="line">[root@localhost ~]# yum  groupinfo  &quot;Web Server&quot;</span><br><span class="line">#查询软件组&quot;Web Server&quot; 中包含的软件</span><br></pre></td></tr></table></figure><ul><li>安装软件组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum  groupinstall  软件组名</span><br><span class="line">#安装指定软件组，组名可以有grouplist 查询出来</span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~]# yum groupinstall  &quot;Web Server&quot;</span><br><span class="line">#安装网页服务软件组</span><br></pre></td></tr></table></figure><ul><li>卸载软件组</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum  groupremove  软件组名</span><br><span class="line">#卸载指定软件组</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--软件包管理(1)</title>
      <link href="2020/09/22/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86(1)/"/>
      <url>2020/09/22/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="软件包分类"><a class="markdownIt-Anchor" href="#软件包分类"></a> 软件包分类</h2><h3 id="软件包分类-2"><a class="markdownIt-Anchor" href="#软件包分类-2"></a> 软件包分类</h3><ul><li>源码包</li><li>二进制包</li></ul><h3 id="源码包"><a class="markdownIt-Anchor" href="#源码包"></a> 源码包</h3><ol><li>源码包什么样</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim  hello.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main (void)</span><br><span class="line">&#123;</span><br><span class="line">print(&quot;hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm  -ivh  &#x2F;mnt&#x2F;dcrom&#x2F;Packages&#x2F;gcc-4.4.6-4.el6.i686.rpm</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gcc  -c hello.c</span><br><span class="line">#-c 生成 &quot; .o &quot; 头文件。这里会生成hello.o头文件，但是不会i执行文件。</span><br><span class="line">[root@localhost ~]# gcc  -o  hello  hello.o</span><br><span class="line">#-o  生成执行文件，并制定执行文件名。这里生成的hello就是可执行文件。 </span><br><span class="line">[root@localhost ~]# 。&#x2F;hello</span><br><span class="line">hello world</span><br><span class="line">#执行hello文件</span><br></pre></td></tr></table></figure><ol start="2"><li>源码包特点<br />源码包的优点：</li></ol><ul><li>开源，如果有能力可以自己修改源代码。</li><li>可以自由选择所需的功能。</li><li>软件是编译安装，所以更加适合自己的系统，更加稳定也效率高。</li><li>卸载方便。</li></ul><p>源码包的缺点：</p><ul><li>安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误。</li><li>编译时间过长，安装比二进制安装时间长。</li><li>因为是编译安装，安装过程中一旦报错新手很难解决。</li></ul><h3 id="二进制包"><a class="markdownIt-Anchor" href="#二进制包"></a> 二进制包</h3><ol><li>二进制包分类</li></ol><ul><li>DKPG包：是有Debian Linux 所开发出来的包管理机制，通过DPKG包，Debian Linux就可以进行软件包管理。主要应用再Debian和unbuntu中。</li><li>RPM包：是由Red Hat 公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多Linux都在使用这种包管理方式，包括Fedora、CentOS、SuSE等。我们这里主要学习的是RPM包gu案例系统。</li></ul><ol start="2"><li>特点<br />RPM包的优点：</li></ol><ul><li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载。</li><li>安装速度比源码包安装块的很多。<br />RPM的缺点：</li><li>经过编译，不可以看到源代码。</li><li>功能选择不如源码包灵活。</li><li>依赖性。有时我们会发现需要安装软件包 a 时需要先安装b和c，而安装b时需要安装d和e。这时需要先安装d和e，再安装b和c，最后才能安装a包。</li></ul><ol start="3"><li>RPM包依赖<br />1)树形依赖：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200923165548254.png#pic_center" alt="" /><br />2）环形依赖：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020092317012399.png#pic_center" alt="" /><br />3）函数库依赖：<br />什么是函数库依赖？我们举一个例子，尝试安装以下文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Packages]# rpm  -ivh  mysql-connector-odbc-5.2.5-7.el7.x86_64.rpm</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">libodbc.so.2()(64bit)  被connector-odbc-5.2.5-7.el7.x86_64 需要</span><br><span class="line">libodbcinst.so.2()(64bit)  被connector-odbc-5.2.5-7.el7.x86_64 需要</span><br></pre></td></tr></table></figure><p>发现报错，需要安装“<a href="http://libodbc.so">libodbc.so</a>。2”函数库文件，这是会发现光盘中根本找不到这个文件。是因为函数库没有单独成包，是包含在某一个软件包中的。而如果要知道在哪个软件包中，需要查询网站 <a href="http://www.rpmfind.net">www.rpmfind.net</a> .</p><h2 id="rpm安装"><a class="markdownIt-Anchor" href="#rpm安装"></a> rpm安装</h2><h3 id="rpm包命名"><a class="markdownIt-Anchor" href="#rpm包命名"></a> rpm包命名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br></pre></td></tr></table></figure><pre><code>httpd        软件包名2.2.15       软件版本15           软件发布的次数el6          软件发行商。el6是RedHat公司发布，适合RHEL6.x(Red Hat Enterprise linux)和 CentOS6.x下使用。i686         适合的硬件平台。RPM包可以在不同的硬件平台安装，选择适合不同CPU的软件版本，可以最大化的发挥CPU性能，所以出现了所谓的i386（386以上的计算机都可以安装），i586（586以上的计算机都可以安装），i686（奔腾II以上计算机都可以安装，目前所有的CPU都是奔腾II以上，所有这个软件版本居多，x86_64(64位CPU可以安装）和noarch（没有硬件限制）等文件名。rpm          rpm包的扩展名。我们说过Linux下文件是不靠扩展名区分文件类型，也就是Linux中扩展名没有任何意含义。可是这里怎么又出现了扩展名呢？原因很简单，如果我们不把RPM的扩展名叫做&quot;.rpm&quot; ,管理员很难知道这是一个RPM包，当然也就无法正确安装了。也就是说如果RPM包不用&quot;.rpm&quot; 作为扩展名，系统可以正确识别没有问题，可是管理员很难识别这是什么软件。包全名：如果操作的是未安装软件包，则使用包全名，而且需要注意绝对路径。包名： 如果操作的是已经安装的软件包，则使用包名即可，系统会产生RPM包的数据库**（/var/lib/rpm/）**，而且可以在任意路径下操作。</code></pre><h3 id="依赖性"><a class="markdownIt-Anchor" href="#依赖性"></a> 依赖性</h3><p>参考上边③RPM包依赖，这里不再重复。</p><h3 id="rpm包手工命令安装"><a class="markdownIt-Anchor" href="#rpm包手工命令安装"></a> rpm包手工命令安装</h3><h4 id="默认安装位置"><a class="markdownIt-Anchor" href="#默认安装位置"></a> 默认安装位置</h4><p>RPM包默认安装路径：</p><table><thead><tr><th>位置</th><th>说明</th></tr></thead><tbody><tr><td>/etc/</td><td>配置文件安装目录</td></tr><tr><td>/usr/bin/</td><td>可执行的命令安装目录</td></tr><tr><td>/usr/lib/</td><td>程序所使用的函数库保存位置</td></tr><tr><td>/usr/share/doc/</td><td>基本的软件使用手册保存位置</td></tr><tr><td>/usr/share/man/</td><td>帮助文件保存位置</td></tr></tbody></table><h4 id="rpm包安装"><a class="markdownIt-Anchor" href="#rpm包安装"></a> RPM包安装</h4><ol><li>安装命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm  -ivh  包全名</span><br><span class="line">#注意一定是包全名，如果跟包全名的命令要注意路径，因为软件包在光盘中</span><br><span class="line">选项：</span><br><span class="line">-i     install安装（intall）</span><br><span class="line">-v     显示更详细的信息（verbose）</span><br><span class="line">-h     打印#显示安装进度（hash）</span><br></pre></td></tr></table></figure><ul><li>–nodeps  不检测依赖性安装。软件在安装时会检测依赖性，确定所需的底层软件是否安装，如果没有安装则会报错。如果不管依赖性，想强行安装，可以使用这个选项。注意：这样不检测依赖性安装的软件基本是不能使用的，所以不建议这样做。</li><li>–replacefiles  替换文件安装。如果安装软件包，可是包中部分文件已经存在，那么正常安装时候，会报错“某个文件已经存在”从而导致软件无法安装，使用这个选项可以户是这个报错，而覆盖安装。</li><li>–replacepkgs   替换软件包安装。如果软件包已经安装，此选项可以把软件包重复安装一遍。</li><li>–force  强制安装，不管是否已经安装，都重新安装一遍。就是–replace files 和–replacepkgs 的结合。</li><li>–test  测试安装，不会实际安装，知识检测一下依赖性。</li><li>–prefix  指定安装路径。为安装软件指定安装路径，而不是使用默认安装路径。注意：如果指定了安装路径，软件没有安装到系统默认路径中的画，系统会找不到这些安装的软件，需要进行手工配置才能被系统识别。<strong>所以rpm包我们要采用默认路径安装。</strong></li></ul><ol start="2"><li>服务启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service 服务名 start|stop|restart|status</span><br><span class="line">参数：</span><br><span class="line">start：    启动服务</span><br><span class="line">stop：    停止服务</span><br><span class="line">restart：   重启服务</span><br><span class="line">status：   查看服务状态</span><br><span class="line">[root@localhost ~]# &#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd  start|stop|restart|status</span><br><span class="line">#推荐这个👆</span><br><span class="line">[root@localhost ~]#  systemctl  restart  httpd</span><br><span class="line">#这个命令也行</span><br><span class="line"></span><br><span class="line">#网页位置：&#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">#配置文件位置：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</span><br></pre></td></tr></table></figure><h4 id="rpm包升级"><a class="markdownIt-Anchor" href="#rpm包升级"></a> RPM包升级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -Uvh  包全名</span><br><span class="line">选项：</span><br><span class="line">-U（大写）  升级安装，如果没有安装过，系统直接安装。如果安装过的版本过旧，则升级到最新版本（upgrade）</span><br><span class="line">[root@localhost ~]#   rpm   -Fvh  包全名</span><br><span class="line">选项：</span><br><span class="line">-F（大写）    升级安装，如果没有安装过，则不会安装。必须安装有较旧版本，才能升级（freshen）</span><br></pre></td></tr></table></figure><h4 id="卸载"><a class="markdownIt-Anchor" href="#卸载"></a> 卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm  -e  包名</span><br><span class="line">选项：</span><br><span class="line">--nodeps   不检查依赖性</span><br><span class="line">-e   卸载</span><br></pre></td></tr></table></figure><h4 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h4><ol><li>查询软件包是否安装<br />可以查询软件包是否安装，命令格式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -q  包名</span><br><span class="line">选项：</span><br><span class="line">-q：  查询（query）</span><br></pre></td></tr></table></figure><ol start="2"><li>查询系统中的所有安装软件包<br />可以查询Linux系统中所有已经安装的软件包，命令格式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qa</span><br><span class="line">选项：</span><br><span class="line">-a：所有（all）</span><br></pre></td></tr></table></figure><p>当然，可以用管道符来查看所需的内容，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qa  |  grep  httpd</span><br></pre></td></tr></table></figure><p>可以看出使用&quot;rpm  -q  包名&quot; 只能查看这个包是否安装，但是使用&quot;rpm  -qa  |  grep  包名&quot; 会把包含包名称的所有包都列出来。<br />3. 查询软件包的详细信息<br />可以查询已经安装的某个软件包的详细信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qi  包名</span><br><span class="line">选项：</span><br><span class="line">-i： 查询软件信息（information）</span><br></pre></td></tr></table></figure><p>也可以查询还没有安装的软件包的详细信息，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qip  包全名</span><br><span class="line">选项：</span><br><span class="line">-p: 查询没有安装的软件包（package）</span><br></pre></td></tr></table></figure><ol start="4"><li>查询软件包中的文件列表<br />可以查询已经安装的软件包中的文件列表和安装的完整目录，命令如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -ql  包名</span><br><span class="line">选项：</span><br><span class="line">-l： 列出软件包中所有的文件列表和软件所安装的目录（list）</span><br></pre></td></tr></table></figure><p>还可以查询没有安装的软件包中的文件列表和打算安装的位置，命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qlp  包全名</span><br><span class="line">选项：</span><br><span class="line">-p：查询没有安装的软件包信息（package）</span><br></pre></td></tr></table></figure><ol start="5"><li>查询系统文件属于哪个RPM包<br />既然可以知道每个RPM包中的文件的安装位置，那么可以查询系统文件属于哪个RPM包吗？当然可以，不过需要注意的是，手工建立的文件是不能查询的，因为这些文件不是通过RPM包安装的，当然不能反向查询它属于哪个RPM包，命令格式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qf  系统文件名</span><br><span class="line">选项：</span><br><span class="line">-f: 查询系统文件属于哪个软件包（file）</span><br></pre></td></tr></table></figure><ol start="6"><li>查询软件包所依赖的软件包<br />查询系统中和已经安装的软件包有依赖关系的软件包，命令格式如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qR  包名</span><br><span class="line">选项：</span><br><span class="line">-R: 查询软件包的依赖性（requires）</span><br></pre></td></tr></table></figure><p>可以查询没有安装的软件包的依赖性吗？加&quot;-p&quot; 选项即可。例如，查看一下还没有安装的bind软件包的依赖包，可以执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qRp  &#x2F;mnt&#x2F;cdrom&#x2F;Packages&#x2F;bind-9.8.2-0.10.rc1.el6.i686.rpm</span><br></pre></td></tr></table></figure><h4 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h4><ol><li>基本命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -Va</span><br><span class="line">选项：</span><br><span class="line">-Va校验本及已经安装的所有软件包</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#  rpm  -V  已安装的包名</span><br><span class="line">选项：-V   校验指定RPM包中的文件（verify）</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#  rpm  -Vf  系统文件名</span><br><span class="line">选项：-Vf  校验某个系统文件是否被修改</span><br></pre></td></tr></table></figure><ol start="2"><li>验证举例<br />在源文件内做出改动后验证</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -V  httpd</span><br><span class="line">S.5....T.              c             &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd&#x2F;conf</span><br><span class="line">验证内容        文件类型           文件名</span><br></pre></td></tr></table></figure><p>出现了提示信息，我们来解释一下最前面共有8个信息内容，是表示验证内容的。文件名前面的c是表示这是个配置文件（configuration）。最后是文件名，娜美验证内容中的8个信息的具体内容如下：</p><pre><code>- S     文件大小是否改变- M     文件的类型或文件的权限（rwx）是否被改变- 5      文件MD5校验和是否改变（可以看成文件内容是否改变）- D      设备的主从代码是否改变- L      文件路径是否改变- U      文件的属主（所有者）是否改变- G      文件的属组是否改变- T      文件的修改时间是否改变</code></pre><p>apache配置文件的文件类型是c，那么还有哪些文件类型呢？</p><pre><code>- c     配置文件（config file）- d    普通文件（documentation）- g    &quot;鬼&quot; 文件（ghost file），很少见，就是该文件不应该被这个RPM包包含- l     授权文件（license file）- r    描述文件（read file）</code></pre><h4 id="数字证书"><a class="markdownIt-Anchor" href="#数字证书"></a> 数字证书</h4><p>刚刚的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果RPM包本身就被动过手脚，那么校验就不能解决问题了。我们就必须使用数字验证了。<br />数字验证的特点：</p><pre><code>- 首先必须找到原厂的公钥文件，然后进行安装- 再安装RPM包，是会提取RPM保重的证书信息，然后和本机安装的原厂证书进行验证- 如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告</code></pre><ol><li>数字证书位置<br />那么数字证书在哪呢？其实在CentOS 6.3的第一章光盘中，当然也默认会放在系统中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll  &#x2F;mnt&#x2F;cdrom&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line">-r--r--r--  2  root  root  1706  7月     2  04:21  &#x2F;mnt&#x2F;cdrom&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line">#光盘中的数字证书位置</span><br><span class="line">[root@localhost ~]# ll  &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line">-rw-r--r--.  1  root  root  1706  6月    26  17:29  &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line">#系统中的数字证书位置</span><br></pre></td></tr></table></figure><ol start="2"><li>数字证书导入</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm  --import  &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-CentOS-6</span><br><span class="line">选项： --import        导入数字证书</span><br></pre></td></tr></table></figure><p>查询系统中安装好的数字证书，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm  -qa  |  grep  gpg-pubkey</span><br><span class="line">gpg-pubkey-c105b9de-4e0fd3a3</span><br></pre></td></tr></table></figure><h4 id="rpm包中文件的提取"><a class="markdownIt-Anchor" href="#rpm包中文件的提取"></a> RPM包中文件的提取</h4><ol><li>cpio命令 (不建议使用cpio命令来做备份还原）<br />cpio命令主要有三种模式：&quot;-o&quot; 模式指的是 copy-out模式，就是把数据被分到文件库中；&quot;-i&quot;模式指的是copy-in 模式，就是把数据从文件库中恢复；&quot;-p&quot; 模式指的是复制模式，就是不把数据备份到cpio库中，而是直接复制为其他文件。如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  cpiu  -o[vcB]   &gt;  [文件|设备]</span><br><span class="line">#备份</span><br><span class="line">选项：</span><br><span class="line">-o：copy-out模式，备份</span><br><span class="line">-v：显示备份过程</span><br><span class="line">-c：使用较新的portable format 存储方式</span><br><span class="line">-B：设定输入输出块为5210bytes，而不是模式的521butes</span><br><span class="line">[root@localhost ~]#  cpio  -i[vcdu]  &gt;  [文件|设备]</span><br><span class="line">#还原</span><br><span class="line">选项：</span><br><span class="line">-i：copy-in模式，还原</span><br><span class="line">-v：显示还原过程</span><br><span class="line">-c：使用较新的portable format 存储方式</span><br><span class="line">-d：还原时自动新建目录</span><br><span class="line">-u：自动使用较新的文件覆盖较旧的文件</span><br><span class="line">[root@localhost ~]#  cpio  -p    目标目录</span><br></pre></td></tr></table></figure><p>先来看使用cpio备份数据的方法，命令如下(不建议使用cpio来做备份还原）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例子：利用find命令找到文件，备份</span><br><span class="line">[root@localhost ~]#  find  &#x2F;etc  -print  |  cpio  -ocvB  &gt;  &#x2F;root&#x2F;etc.cpio</span><br><span class="line">#利用find指定要备份&#x2F;etc&#x2F;目录，使用 &gt; 导出etc.cpio文件</span><br><span class="line">[root@localhost ~]#  ll  -h  etc.cpio</span><br><span class="line">-rw-r--r--.  1  root  root  21M 6月    5  11:40  etc.cpio</span><br><span class="line">#etc.cpio 文件生成</span><br></pre></td></tr></table></figure><p>再来看看如何恢复cpio的备份数据，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  cpio  -idvcu  &lt;  &#x2F;root&#x2F;etc.cpio</span><br><span class="line">#还原而通常备份</span><br><span class="line">#但是如果查看当前目录&#x2F;root,会发现没有生成etc目录。这是因为备份是&#x2F;etc目录使用的是绝对路径，所以恢复的数据直接恢复到了&#x2F;etc 系统目录中，而没有生成在&#x2F;root&#x2F;etc中。</span><br></pre></td></tr></table></figure><p>在CentOS5.x的版本中，是可以利用上边的命令备份与恢复指定的文件。但是到CentOS6.x当中，需要更加严谨。如果备份时使用绝对路径，则恢复的数据会直接到绝对路径指定的路径中，如果需要把数据恢复到当前目录中，则需要使用相对路径，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">备份：</span><br><span class="line">[root@localhost ~]#  cd  &#x2F;etc</span><br><span class="line">#进入&#x2F;etc目录</span><br><span class="line">[root@localhost ~]# find  .  -print  |  cpio  -ocvB  &gt;  &#x2F;root&#x2F;etc.cpio</span><br><span class="line">#利用find指定要备份的&#x2F;而通常&#x2F;目录，使用&gt;导出到etc.cpio 文件</span><br><span class="line"></span><br><span class="line">恢复：</span><br><span class="line">[root@localhost ~]#  cd  &#x2F;root</span><br><span class="line">#回到&#x2F;root目录</span><br><span class="line">[root@localhost ~]#  mkdir  etc_test</span><br><span class="line">#建立恢复测试目录</span><br><span class="line">[root@localhost ~]#  cd  etc_test</span><br><span class="line">#进入测试目录，数据恢复到该目录</span><br><span class="line">[root@localhost etc_test]#  cpio  -idvcu  &lt;  &#x2F;root&#x2F;etc.cpio</span><br><span class="line">#还原&#x2F;etc 目录的数据，因为备份时使用的是相对路径，则会还原到&#x2F;root&#x2F;etc_test&#x2F;目录下</span><br></pre></td></tr></table></figure><p>最后演示一下cpio命令的 &quot; -p &quot; 复制模式，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  cd  &#x2F;tmp&#x2F;</span><br><span class="line">#进入&#x2F;tmp 目录</span><br><span class="line">[root@localhost tmp]# rm -rf  *</span><br><span class="line">#删除&#x2F;tmp 目录中所有数据</span><br><span class="line">[root@localhost tmp]#  mkdir  test</span><br><span class="line">#建立备份目录</span><br><span class="line">[root@localhost tmp]# find  &#x2F;boot&#x2F;  -print  |  cpio  -p  &#x2F;tmp&#x2F;test</span><br><span class="line">#备份&#x2F;boot&#x2F;目录到&#x2F;tmp&#x2F;test目录中</span><br><span class="line">[root@localhost tmp]# ls  test&#x2F;</span><br><span class="line">boot</span><br><span class="line">#在&#x2F;tmp&#x2F;test&#x2F;目录中备份出了boot目录</span><br></pre></td></tr></table></figure><ol start="2"><li>提取RPM包中的文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm2cpio  包全名  |  cpio  -idv  .  文件名</span><br><span class="line"></span><br><span class="line">rpm2cpio         将rpm包转换为cpio格式的命令</span><br><span class="line">cpio              是一个标准工具，它用于创建软件档案文件和档案文件中提取文件</span><br></pre></td></tr></table></figure><p>现在假设把系统中的/bin/ls 命令不小心删除了，这时有两种方法能将其修复，要不就是使用–force选项覆盖安装一遍 coreutils-8.4-19.el6.i686 包，或者使用cpio命令提取出/bin/ls 命令文件，再把它拷贝到对应位置就可以了。这时可以用 “-qf” 选项查询/bin/ls命令是否属于coreutils-8.4-19.el6.i686 这个软件包，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  rpm  -qf  &#x2F;bin&#x2F;ls</span><br><span class="line">coreutils-8.4-19.el6.i686</span><br><span class="line">#查看ls文件属于哪个软件包</span><br></pre></td></tr></table></figure><p>因为在讲RPM包中文件提取，所有我们使用第二章方法，使用cpio命令提取出ls命令文件，然后拷贝到对应位置，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mv  &#x2F;bin&#x2F;ls  &#x2F;root&#x2F;</span><br><span class="line">#把&#x2F;bin&#x2F;ls命令移动到&#x2F;root目录下，造成误删除的假象</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#  ls</span><br><span class="line">-bash: ls:command not found</span><br><span class="line">#这时执行 ls 命令，系统会报错“命令没有找到”</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#  rpm2cpio  &#x2F;mnt&#x2F;cdrom&#x2F;Packages&#x2F;coreutils-8.4-19.el6.i686.rpm  |  cpio  -idv  .&#x2F;bin&#x2F;ls</span><br><span class="line">.&#x2F;bin&#x2F;ls</span><br><span class="line">24772块</span><br><span class="line">#提取ls命令文件到当前目录下</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#  cp  &#x2F;root&#x2F;bin&#x2F;ls  &#x2F;bin&#x2F;</span><br><span class="line">#把提取出来的 ls 命令文件复制到&#x2F;bin目录下</span><br><span class="line"></span><br><span class="line">[root@localhost ~]#  ls</span><br><span class="line">anaconda-ks.cfg   bin   inittab   install.log   install.log.syslog   ls</span><br><span class="line">#ls命令又可以正常使用了</span><br></pre></td></tr></table></figure><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RPM包手工命令安装：</span><br><span class="line">- 安装：rpm  -ivh  包全名</span><br><span class="line">- 升级：rpm  -Uvh  包全名</span><br><span class="line">- 卸载：rpm  -e  包名</span><br><span class="line">- 查询：  1）查询是否安装                     rpm  -q  包名</span><br><span class="line"> rpm  -qa  |  grep  包名</span><br><span class="line">   2）查询包信息 rpm  -qi  包名</span><br><span class="line">    rpm  -qip   包全名</span><br><span class="line">   3）查询安装位置     rpm  -ql  包名</span><br><span class="line">        rpm  -qlp  包全名</span><br><span class="line">   4）查询系统文件属于哪个包       rpm  -qf  包全名</span><br><span class="line">   5）查询依赖性                         rpm  -qR  包名</span><br><span class="line">   </span><br><span class="line">验证       rpm  -V  包名</span><br><span class="line">数字证书      rpm--import  数字证书名</span><br><span class="line">提取RPM包中文件           rpm2cpio  包全名  |  cpio  -idv  .文件绝对路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--vim编辑器</title>
      <link href="2020/09/20/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>2020/09/20/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="vim-编辑器"><a class="markdownIt-Anchor" href="#vim-编辑器"></a> vim 编辑器</h2><h3 id="vi-编辑器简介"><a class="markdownIt-Anchor" href="#vi-编辑器简介"></a> vi 编辑器简介</h3><p>vim是一个全屏幕纯文本编辑器，是vi编辑器的增强版，我们主要讲解的是vim编辑器。可以利用别命让输入vi目录的时候，实际上执行vim编辑器，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  alias  vi&#x3D;&quot;vim&quot;</span><br><span class="line">#定义别名</span><br></pre></td></tr></table></figure><p>这样定义别命是临时生效的，如果需要永久生效，请放入环境变量配置文件(~/.bashrc)。</p><h3 id="vim-基本使用"><a class="markdownIt-Anchor" href="#vim-基本使用"></a> vim 基本使用</h3><p><strong>1.vim的工作模式</strong><br />vim工作在三种模式之下：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200920150835632.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br /><strong>命令模式：</strong> 是主要使用快捷键的模式，是学习的重点。命令模式想要进入输入模式可以用以下方法：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>a</td><td>在光标所在字符后插入</td></tr><tr><td>A</td><td>在光标所在行尾插入</td></tr><tr><td>i</td><td>在光标所在字符前插入</td></tr><tr><td>I</td><td>在光标所在行行首插入</td></tr><tr><td>o（小写）</td><td>在光标下插入新行</td></tr><tr><td>O（大写）</td><td>在光标上插入新行</td></tr></tbody></table><p>**输入模式：**主要用于文本编辑，输入数据。<br /><strong>编辑模式（末行模式）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:w   保存不退出</span><br><span class="line">:w 新文件名     把文件另存为新文件</span><br><span class="line">:q    不保存退出</span><br><span class="line">:wq   保存退出</span><br><span class="line">:!  强制</span><br><span class="line">:q!    强制不保存退出，用于修改文件后，不保存数据退出。</span><br><span class="line">:wq!   强制保存退出，当文件的所有者或者root用户，对文件没有写权限时，强制写入数据使用。</span><br></pre></td></tr></table></figure><p><strong>2.命令模式操作</strong></p><p><strong>①移动光标</strong></p><ul><li>上下左右移动光标：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上、下、左、右方向键               移动光标</span><br><span class="line">H、 J、 K、 L                    移动光标</span><br></pre></td></tr></table></figure><ul><li>把光标移动到文件头或尾：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gg      移动到文件头</span><br><span class="line">G       移动到文件尾</span><br></pre></td></tr></table></figure><ul><li>移动到行首或行尾</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^      移动到行尾</span><br><span class="line">$      移动到行尾</span><br></pre></td></tr></table></figure><ul><li>移动到指定行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:n     移动到第几行</span><br></pre></td></tr></table></figure><p><strong>②删除或剪切</strong></p><ul><li>删除字母</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x         删除单个字母</span><br><span class="line">nx        删除n个字母</span><br></pre></td></tr></table></figure><p>#n是数字，如果想从光标位置删除连续的10个字母，可以使用“10x”即可。删除字母并不符合使用习惯，我们更习惯在编辑模式中，用“Backspace”键删除字母。</p><ul><li>删除整行或剪切</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dd          删除单行</span><br><span class="line">ndd         删除多行</span><br><span class="line">:n1,n2d     删除指定范围的行</span><br></pre></td></tr></table></figure><p>删除整行或多行，这是比较常用的删除方法。这里的 dd 快捷键既是删除，也是剪切。删除内容放入了剪切板，如果不粘贴就是删除，反之就是剪切。粘贴方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p(小)    粘贴到光标后</span><br><span class="line">P(大)    粘贴到光标前</span><br></pre></td></tr></table></figure><ul><li>从光标所在行删除到文件尾<br />&quot; d “是删除行，” G &quot; 是文件尾，vim没有删除整篇文档的快捷键。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dG    从光标所在行删除到文件尾</span><br></pre></td></tr></table></figure><p><strong>③复制</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yy         复制单行</span><br><span class="line">nyy        复制多行</span><br></pre></td></tr></table></figure><p>复制之后的粘贴，依然是用p键或P(大)键</p><p><strong>④撤销</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u             撤销</span><br><span class="line">ctrl+r        反撤销</span><br></pre></td></tr></table></figure><p>&quot; u &quot; 键能一直撤销到文件打开时的状态，类似与 Windows系统 下的“ctrl+z”。<br />&quot; ctrl+r &quot; 能一直反撤销到最后一次操作状态，类似Windows下的“ctrl+y”。</p><p><strong>⑤替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r    替换光标所在处的字符</span><br><span class="line">R    从光标所在处开始替换字符，按esc结束</span><br></pre></td></tr></table></figure><p>&quot; r &quot; 键替换单一字符，不能进入输入模式，实际使用时，比进入输入模式删除后再修改，要方便。</p><p><strong>⑥vim配置文件</strong><br />这次编辑模式（末行模式）参数设置，多数需要再vim种才能生效。</p><table><thead><tr><th>设置参数</th><th>含  义</th></tr></thead><tbody><tr><td>① :set nu      ②:set nomu</td><td>显示与取消行号</td></tr><tr><td>①:syntax on   ②:syntax off</td><td>是否一句语法显示相关的颜色帮助。再Vim中修改相关配置文件或Shell脚本时（如前面示例的脚本/而通常/init.d/sshd），默认会显示相应的颜色，用来帮助排错。如果觉得颜色产生了干扰，则可以取消此设置。</td></tr><tr><td>①:set hlsearch    ②:set nohlsearch</td><td>设置是否将查找的字符串高亮显示。默认是set hlsearch 高亮显示</td></tr><tr><td>①:set ruler   ②:set noruler</td><td>设置是否显示右下角的状态栏。默认是set ruler 显示</td></tr><tr><td>①:set showmode  ②:set noshowmode</td><td>设置是否再左下角显示如&quot; -INSERT-- &quot; 之类的状态栏。默认是 set showmode显示</td></tr><tr><td>①:set list   ②:set nolist</td><td>设置是否显示隐藏字符（Tab键用&quot;^I&quot; 表示，回车符用&quot; $ &quot; 表示）。默认是 nolist 显示。如果使用 setlist 显示隐藏字符，类似&quot;cat -A文件名&quot; 。</td></tr></tbody></table><p>vim 支持更多的设置参数，可以通过&quot;:set all&quot; 进行查看。<br />这些设置参数都只是临时生效，一旦关闭文件再打开，又要重新输入。如果想要永久生效，需要手工建立 vim 的配置文件 <strong>“~/.vimrc”</strong>,把你需要的参数写入配置文件就永久生效了。</p><p>补充：windows下回车符再Linux种是用&quot;^M<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">&quot;</mi><mi mathvariant="normal">符</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">显</mi><mi mathvariant="normal">示</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">而</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">&quot; 符号显示，而不是&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span><span class="mord cjk_fallback">符</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">而</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">是</span><span class="mord">&quot;</span></span></span></span>&quot; 符。这样会导致Windows下编辑的程序脚本，无法在Linux中执行。这时可以通过命令&quot;dos2unix&quot; ,把Windows 格式转为Linux格式，当然反过来 “unix2dos” 命令就是把Linux格式转换为Windows格式。这两个命令默认没有安装，需要手工安装才能使用。</p><p><strong>⑦ 查找</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;查找内容    从光标所在航向下查找</span><br><span class="line">?查找内容    从光标所在行向上查找</span><br><span class="line">n           下一个</span><br><span class="line">N           上一个</span><br></pre></td></tr></table></figure><p><strong>⑧ 替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:1,10s&#x2F;old&#x2F;new&#x2F;g     替换1到10行的所有old为new</span><br><span class="line">:%s&#x2F;old&#x2F;new&#x2F;g         替换整个文件的old为new</span><br></pre></td></tr></table></figure><p>替换字符串，举个例子：在shell中&quot;#&quot; 开头是注释，那是否可以注释文件的前10行呢？手工一个一个注释很麻烦，那么批量替换如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:1,10s&#x2F;^&#x2F;#&#x2F;g      注释1到10行</span><br><span class="line">:1,10&#x2F;^#&#x2F;&#x2F;g       取消注释</span><br></pre></td></tr></table></figure><p>而C语言，PHP语言等大多数语言中，是使用&quot;//&quot; 开头作为注释的，当然可以用vim来写这些程序语言脚本，批量加入“//”注释方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:1,10s&#x2F;^&#x2F;\&#x2F;\&#x2F;&#x2F;g     1到10行，行首加入&#x2F;&#x2F;</span><br><span class="line">:1,10s&#x2F;^\&#x2F;\&#x2F;&#x2F;&#x2F;g     取消1到10行行首的&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><h3 id="vim-使用技巧"><a class="markdownIt-Anchor" href="#vim-使用技巧"></a> vim 使用技巧</h3><p><strong>1.在vim中导入其他文件内容或命令结果</strong><br />①导入其他文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r文件名             把文件内容导入光标位置</span><br></pre></td></tr></table></figure><p>可以把其他文件的内容导入到光标所在位置<br />②在vim中执行系统命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!命令        在vim中执行系统命令</span><br></pre></td></tr></table></figure><p>这里只是在vim中执行系统命令，但并不把系统命令的结果写入到文件中。主要用于在文件编辑中，查看系统信息，如时间。<br />③导入命令结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r  !命令          在vim中执行系统目录，并把命令结果导入光标所在行</span><br></pre></td></tr></table></figure><p>在vim中执行系统命令，并把命令结果导入光标所在行。<br /><strong>2.设定快捷键</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:map  快捷键  快捷键执行的命令                     自定义快捷键</span><br></pre></td></tr></table></figure><p>vim允许自定义快捷键，常用的自定义快捷键如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:map ^P  I#&lt;ESC&gt;             按&quot;ctrl+p&quot; 时，在行首加入注释</span><br><span class="line">:map   ^B  ^x                 按&quot;ctrl+b&quot; 时，删除行首第一个字母（删除注释）</span><br></pre></td></tr></table></figure><p>注意：^p快捷键不能手工输入，需要执行ctrl+V+P来定义，或CTRL+V，然后ctrl+P,  ^B快捷键也是一样。<br /><strong>3.字符替换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:a 元字符  替换为字符           字符替换</span><br></pre></td></tr></table></figure><p>在vim编辑中，有时候需要频繁输入摸一个长字符串（比如洋浦想），这是使用字符串替换，能增加输入效率，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:ab  mymail  xxxxxxxxx@163.com         当碰到“mymail”时，转变为邮箱</span><br></pre></td></tr></table></figure><p>注意：”源字符“ 不应设置太短，否则又肯影响输入。<br /><strong>4.多文件打开</strong><br />在vim中可以同时打开两个文件，只要执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # vim  -o   abc   bcd</span><br><span class="line">[root@localhost ~] # vim  -O  abc  bcd</span><br><span class="line">#-o   小写o会上下分屏打开两个文件</span><br><span class="line">#-O  大写O会左右分屏打开两个文件</span><br></pre></td></tr></table></figure><p>这样可以同时打开两个文件，方便操作。如果是”-o“上下打开两个文件，可以通过先按”ctrl+w“，再按”上下箭头“的方式在两个文件之间切换。<br />如果是”-O（大写）“左右打开两个文件。可以通过先按”ctrl+w“，再按”左右箭头“ 的方式再两个文件之间切换。</p>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--常用命令（4）</title>
      <link href="2020/09/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%884%EF%BC%89/"/>
      <url>2020/09/16/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="系统痕迹命令"><a class="markdownIt-Anchor" href="#系统痕迹命令"></a> 系统痕迹命令</h2><h3 id="w-命令"><a class="markdownIt-Anchor" href="#w-命令"></a> w 命令</h3><p>w 命令是显示系统中正在登陆的用户信息的命令，这个命令查看的痕迹日志是/var/run/utmp。</p><ul><li>命令名称：w</li><li>英文原意：Show who is logged on and what they are doing</li><li>所在路径：/usr/bin/w</li><li>执行权限：所有用户</li><li>功能描述：显示登陆用户信息</li><li></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 15:59:40  up 19 min,  2 users,  load average: 0.00, 0.02, 0.09</span><br><span class="line"> #系统时间  持续开机时间   登陆用户       系统在1分钟，  5分钟， 15分钟的平均负载</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">thekun   :0       :0               15:40   ?xdm?  32.63s  0.43s &#x2F;usr&#x2F;libexec&#x2F;gnome-session-binary --se</span><br><span class="line">root     pts&#x2F;0    192.168.11.1     15:40    4.00s  0.09s  0.04s w</span><br></pre></td></tr></table></figure><p>第一行信息如下：</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>15:59:40</td><td>系统当前时间</td></tr><tr><td>up 19 min</td><td>系统运行时间，本及已经运行了19分钟</td></tr><tr><td>2 users</td><td>当前登录了两个用户</td></tr><tr><td>load average: 0.00, 0.02, 0.09</td><td>系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数值超过 1 就是高负载；如果CPU是四核，则这个数值超过4就是高负载。</td></tr></tbody></table><p>第二行信息如下：</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>USERS</td><td>当前登陆用户</td></tr><tr><td>TTY</td><td>登陆的终端：ttyl-6:本地字符终端（alt+F1-6切换）  tty7：本地图形终端（ctrl+alt+F7切换，必须要安装启动图形界面）pts/0-255：远程终端</td></tr><tr><td>FROM</td><td>登陆的IP地址，如果是本地终端，则是空</td></tr><tr><td>LOGIN@</td><td>登陆时间</td></tr><tr><td>IDLE</td><td>用户闲置时间</td></tr><tr><td>JCPU</td><td>所有的进程占用的CPU时间</td></tr><tr><td>PCPU</td><td>当前进程占用的CPU时间</td></tr><tr><td>WHAT</td><td>用户正在进行的操作</td></tr></tbody></table><h3 id="who命令"><a class="markdownIt-Anchor" href="#who命令"></a> who命令</h3><p>who命令和 w 命令类似，用于查看正在登陆的用户，但是显示的内容更加简单，也是查看/var/run/utmp 日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who</span><br><span class="line">thekun   :0           2020-09-17 15:40 (:0)</span><br><span class="line">root     pts&#x2F;0        2020-09-17 15:40 (192.168.11.1)</span><br><span class="line">#用户名  登陆终端       登陆时间（来源IP）</span><br></pre></td></tr></table></figure><h3 id="last-命令"><a class="markdownIt-Anchor" href="#last-命令"></a> last 命令</h3><p>last命令是查看系统所有登陆过的用户信息的，包括正在登陆的用户和之前登陆的用户。这个命令查看的是/var/log/wtmp 痕迹日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# last</span><br><span class="line">root     pts&#x2F;1        192.168.11.1     Wed Sep 16 21:57 - crash  (17:41)    </span><br><span class="line">root     pts&#x2F;0        192.168.11.1     Wed Sep 16 21:56 - 21:57  (00:01) </span><br><span class="line">root     pts&#x2F;2        192.168.11.1     Wed Sep 16 15:57 - 15:57  (00:00)    </span><br><span class="line">root     pts&#x2F;1        192.168.11.1     Wed Sep 16 15:56 - crash  (05:55) </span><br><span class="line">reboot   system boot  3.10.0-1062.el7. Thu Sep 17 15:38 - 16:34  (00:56)</span><br><span class="line">#系统重启信息记录</span><br><span class="line">root     pts&#x2F;2        192.168.11.1     Sat May 23 17:58 - 17:59  (00:01)    </span><br><span class="line">root     pts&#x2F;2        192.168.11.1     Sat May 23 17:47 - 17:56  (00:08)  </span><br><span class="line">#用户名   终端号            来源IP                登陆时间- 退出时间</span><br></pre></td></tr></table></figure><h3 id="lastlog-命令"><a class="markdownIt-Anchor" href="#lastlog-命令"></a> lastlog 命令</h3><p>lastlog 命令是查看系统中所有用户最后一次的登陆时间的命令，他查看的日志是/var/log/lastlog文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lastlog</span><br><span class="line">用户名           端口     来自IP             最后登陆时间</span><br><span class="line">root           pts&#x2F;1    192.168.11.1     四 9月 17 16:56:20 +0800 2020</span><br><span class="line">bin                                        **从未登录过**</span><br><span class="line">daemon                                     **从未登录过**44--*************+666666666666666666666669999999999999999999999999999999999999999999994</span><br><span class="line">adm                                        **从未登录过**</span><br><span class="line">lp                                         **从未登录过**</span><br><span class="line">sync                                       **从未登录过**</span><br><span class="line">shutdown                                   **从未登录过**</span><br><span class="line">halt                                       **从未登录过**</span><br><span class="line">...省略部分内容...</span><br></pre></td></tr></table></figure><h3 id="lastb-命令"><a class="markdownIt-Anchor" href="#lastb-命令"></a> lastb 命令</h3><p>lastb命令是查看错误登陆的信息的，查看的是/var/log/btmp 痕迹日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lastb</span><br><span class="line">thekun         :0           :0        Thu Sep 17 15:40 - 15:40  (00:00)    </span><br><span class="line">root           tty3                   Wed Sep 16 21:54 - 21:54  (00:00)    </span><br><span class="line">#错误登陆用户    终端                    尝试登陆的时间</span><br></pre></td></tr></table></figure><h2 id="挂载命令"><a class="markdownIt-Anchor" href="#挂载命令"></a> 挂载命令</h2><h3 id="mount-命令基本格式"><a class="markdownIt-Anchor" href="#mount-命令基本格式"></a> mount 命令基本格式</h3><p>Linux所有存储设备都必须挂载，包括硬盘<br />命令名称：mount<br />命令所在路径：<br />执行权限：所有用户<br />命令的具体格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount  [-l]</span><br><span class="line">#查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line">[root@localhost ~]#  mount  -a</span><br><span class="line">#一句配置文件&#x2F;etc&#x2F;fstab的内容，自动挂载。 -a代表auto （自动）</span><br><span class="line">[root@localhost ~]# mount  [-t 文件系统]  [-L卷标名] [-o  特殊选项]  \</span><br><span class="line">设备文件名  挂载点</span><br><span class="line">#\ 代表换行</span><br><span class="line">选项：</span><br><span class="line">-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统。</span><br><span class="line">-L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line">-o：特殊选项：可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认生效。</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>atime/noatime</td><td>更新访问时间/不更新访问时间。访问分区文件时，是否更新文件的访问时间，默认为更新。</td></tr><tr><td>async/sync</td><td>异步/同步，默认为异步</td></tr><tr><td>aout/noauto</td><td>自动/手动，mount -a 命令执行时，是否会自动安装/etc/fstab 文件内容挂载，默认为自动</td></tr><tr><td>defaults</td><td>定义默认值，相当于 rw，suid，dev, exec, auto, nouser, async 这七个选项</td></tr><tr><td>exec/noexec</td><td>执行/不执行，设定是否允许在文件系统中执行可执行文件，默认是 exec允许</td></tr><tr><td>remount</td><td>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</td></tr><tr><td>rw/ro</td><td>读写/只读，文件系统挂载时，是否具有读写权限，默认是rw</td></tr><tr><td>suid/nosuid</td><td>具有/不具有 SUID权限，设定文件系统是否具有 SUID和SGID的权限，默认是具有</td></tr><tr><td>user/nouser</td><td>允许/不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有root可以挂载分区</td></tr><tr><td>usrquota</td><td>写入代表文件系统支持用户磁盘配额，默认不支持</td></tr><tr><td>grpquota</td><td>写入代表文件系统支持组磁盘配额，默认不支持</td></tr></tbody></table><p><strong>例1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount</span><br><span class="line">#查看系统中已经挂载的文件系统，注意有虚拟文件系统</span><br><span class="line">&#x2F;dev&#x2F;sda3  on  &#x2F;  type ext4  (rw)</span><br><span class="line">proc  on  &#x2F;proc  type  proc  (rw)</span><br><span class="line">sysfs  on  &#x2F;sys  type  sysfs  (rw)</span><br><span class="line">devpts  on  &#x2F;dev&#x2F;pts  type  devpts  (rw,gid&#x3D;5,mode&#x3D;620)</span><br><span class="line">tmpfs  on  &#x2F;dev&#x2F;shm  type  tmpfs  (rw)</span><br><span class="line">&#x2F;dev&#x2F;sda1  on  &#x2F;boot  type  ext4  (rw)</span><br><span class="line">none  on  &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc  type  binfmt_misc  (rw)</span><br><span class="line">sunrpc  on  &#x2F;var&#x2F;lib&#x2F;nfs&#x2F;rpc_pipefs  type  rpc_pipefs  (rw)</span><br><span class="line">#命令结果是代表：&#x2F;dev&#x2F;sda3 分区挂载到&#x2F;目录，文件系统是ext4，权限是读写</span><br></pre></td></tr></table></figure><p><strong>例2：修改特殊权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount</span><br><span class="line">#我们查看到&#x2F;boot 分区已经被挂载，而且采用的 defaults 选项，那么我们重新挂载分区，并采用 noexec</span><br><span class="line">#权限进制执行文件执行，看看会出现说明情况（注意不要用&#x2F;分区做实验，#不然系统目录页不能执行了）。</span><br><span class="line">。。。省略部分输出。。。</span><br><span class="line">&#x2F;dev&#x2F;sdal on &#x2F;boot type ext4 (rw)</span><br><span class="line">。。。省略部分输出。。。</span><br><span class="line">[root@localhost ~]#  mount  -o  remount,noexec  &#x2F;boot</span><br><span class="line">#重新挂载&#x2F;boot分区，并使用noexec 权限</span><br><span class="line">[root@localhost ~]#  cd  &#x2F;boot&#x2F;</span><br><span class="line">[root@localhost boot]#  vi  hello.sh</span><br><span class="line">#写个shell</span><br><span class="line">#！&#x2F;bin&#x2F;bash</span><br><span class="line">echo “hello！！”</span><br><span class="line">[root@localhost boot]#  chmod  755  hello.sh</span><br><span class="line">-bash: .&#x2F;hello.sh: 权限不够</span><br><span class="line">#虽然赋予了hello.sh执行权限，但是仍然无法执行</span><br><span class="line">[root@localhost boot]#  mount  -o  remount，exec  &#x2F;boot</span><br><span class="line">#记得改回来，否则会影响系统启动  </span><br></pre></td></tr></table></figure><p><strong>例3：挂载分区</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mkdir  &#x2F;mnt&#x2F;disk1</span><br><span class="line">#建立挂载点目录</span><br><span class="line">[root@localhost ~]#  mount  &#x2F;dev&#x2F;sdb1  &#x2F;mnt&#x2F;disk1</span><br><span class="line">#挂载分区</span><br></pre></td></tr></table></figure><h3 id="光盘挂载"><a class="markdownIt-Anchor" href="#光盘挂载"></a> 光盘挂载</h3><p>光盘挂载的前提依然是指定光盘的设备文件名，不同版本的Linux，设备文件名不同：</p><ul><li>CentOS 5.x 以前的系统，光盘设备文件名是/dev/hdc</li><li>CentOS 6.x 以前的系统，光盘设备文件名是/dev/sr0<br />无论哪个系统都有软连接/dev/cdrom， 与可以作为光盘的设备文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount  -t  iso960  &#x2F;dev&#x2F;cdrom  &#x2F;mnt&#x2F;cdrom&#x2F;</span><br><span class="line">#挂载光盘,必须要用空目录。</span><br></pre></td></tr></table></figure><p>用完之后记得卸载：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  umount  &#x2F;dev&#x2F;sr0</span><br><span class="line">[root@localhost ~]#  umount  &#x2F;mnt&#x2F;cdrom</span><br><span class="line">#因为设备文件名和挂载点已经连接到一起，卸载哪一个都可以。</span><br><span class="line">#卸载的时候需要退出光盘目录，才能正常卸载。</span><br></pre></td></tr></table></figure><h3 id="光盘挂载-2"><a class="markdownIt-Anchor" href="#光盘挂载-2"></a> 光盘挂载</h3><p>U盘会和硬盘共用设备文件名，所以U盘设备文件名不是固定的，需要手工查询，查询命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  fdisk  -l</span><br><span class="line">#查询硬盘</span><br></pre></td></tr></table></figure><p>挂载U盘，命令如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount  -t  vfat  &#x2F;dev&#x2F;sdb1  &#x2F;mnt&#x2F;usb&#x2F;</span><br><span class="line">#挂载U盘。因为windows分区，所以是vfat文件系统格式</span><br></pre></td></tr></table></figure><p>如果U盘中有中文，会发现中文是乱码。Linux想要正常显示中文，需要两个条件：</p><ul><li>安装了中文编码和中文字体</li><li>操作终端需要支持中文显示（纯字符终端，是不支持中文编码的）<br />而我们当前系统是安装了中文编码和字体，而xshell远程终端是Windows下的程序，当然是支持中文显示的。那么之所以挂载U盘还出现乱码，是需要在挂载的时候，手工指定中文编码，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount  -t  vfat  -o  iocharset&#x3D;utf8  &#x2F;dev&#x2F;sdb1  &#x2F;mnt&#x2F;usb&#x2F;</span><br><span class="line">#挂载U盘，指定中文编码格式为UTF-8</span><br></pre></td></tr></table></figure><p>如果需要卸载，可以执行以下命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  umount  &#x2F;mnt&#x2F;usb&#x2F;</span><br></pre></td></tr></table></figure><h3 id="挂载-ntfs分区"><a class="markdownIt-Anchor" href="#挂载-ntfs分区"></a> 挂载 NTFS分区</h3><p><strong>linux 的驱动加载顺序</strong></p><ul><li>去顶直接放入系统内核之中。这种驱动主要是系统启动加载必须的驱动，数量较少。</li><li>驱动以模块的形式防入硬盘。大多数驱动都以这种方式保存，保存位置在/lib/modules/3.10.0-862.el7.x86_64/kemel/中。</li><li>驱动可以被Linux识别，但是系统认为这种驱动一般不常用，默认不加载。如果需要加载这种驱动，需要重新表一内核，而NTFC文件系统的驱动就属于这种情况。</li><li>硬件不能被Linux内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对Linux的驱动，否则就需要自家开发驱动了。<br /><strong>使用NTFS-3G 安装NTFS文件系统模块</strong></li><li>下载NTFS-3G 插件<br />在编译安装NTFS-3G插件之前，要保证gcc编译器已经安装。具体安装命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  tar  -zxvf  ntfs-3g_ntfsprogs-2013.1.13.tgz</span><br><span class="line">#解压</span><br><span class="line">[root@localhost ~]#  cd  ntfs-3g_ntfsprogs-2013</span><br><span class="line">#进入解压目录</span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013]#  .&#x2F;configure</span><br><span class="line">#编译器准备。没有指定安装目录，安装到默认位置种</span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013]#  make</span><br><span class="line">#编译</span><br><span class="line">[root@localhost ntfs-3g_ntfsprogs-2013]#  make  install</span><br><span class="line">#编译安装</span><br></pre></td></tr></table></figure><p>安装就完成了，已经可以挂载和使用Windows的NTFS分区了。不过需要注意挂载分区时的文件系统不是ntfs，而是ntfs-3g。挂载目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mount  -t  ntfs-3g  分区设备文件名  挂载点</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~]#  mount  -t  ntfs-3g  &#x2F;dev&#x2F;sdb1  &#x2F;mnt&#x2F;win</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--常用命令（3）</title>
      <link href="2020/07/23/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%883%EF%BC%89/"/>
      <url>2020/07/23/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="压缩和解压命令"><a class="markdownIt-Anchor" href="#压缩和解压命令"></a> 压缩和解压命令</h2><pre><code>在Linux中可以识别的常见的压缩格式有十几种，比如：&quot;.zip&quot;  &quot;.gz&quot;  &quot;.bz2&quot;  &quot;.tar&quot;  &quot;.tar.gz&quot;  &quot;.tar.bz2&quot;等。</code></pre><h3 id="zip-格式"><a class="markdownIt-Anchor" href="#zip-格式"></a> “.zip” 格式</h3><p><strong>&quot; .zip &quot;格式的压缩命令</strong><br />&quot; .zip &quot; 时Windows系统中最常见的压缩格式，Linux中也可以识别。<br /><strong>&quot; .zip &quot; 格式的压缩命令</strong></p><ul><li>命令名称：zip</li><li>英文原意：package and compress (archive) files</li><li>所在路径：/usr/bin/zip</li><li>执行权限：所有用户</li><li>功能描述：压缩文件或目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  zip [选项]  压缩包名  源文件或源目录</span><br><span class="line">选项： -r ：压缩目录</span><br><span class="line"></span><br><span class="line">例：[root@localhost ~] #  zip  cai.zip  caixunkun.cfg</span><br></pre></td></tr></table></figure><p><strong>&quot; .zip &quot; 格式的解压缩命令</strong></p><ul><li>命令名称：unzip</li><li>英文原意：list,test and extract compressed files in a ZIP archive</li><li>所在路径：/usr/bin/unzip</li><li>执行权限：所有用户</li><li>功能描述：列表、测试和提取压缩文件中的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  unzip [选项] 压缩包名</span><br><span class="line">选项：  -d：指定解压缩位置</span><br><span class="line">例：</span><br><span class="line">[root@localhost ~] #  unzip  -d  &#x2F;tmp&#x2F;   cai.zip</span><br></pre></td></tr></table></figure><h3 id="gz-格式-不能打包"><a class="markdownIt-Anchor" href="#gz-格式-不能打包"></a> &quot;.gz &quot; 格式 （不能打包）</h3><p><strong>&quot;. gzip &quot; 格式的压缩命令</strong></p><ul><li>命令名称：gzip</li><li>英文原意：compress or expand files</li><li>所在路径：/bin/gzip</li><li>执行权限：所有用户</li><li>功能描述：压缩文件或目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  gzip  [选项]  源文件</span><br><span class="line">选项：</span><br><span class="line">-c：将压缩数据输出到标准输出中，可以用于保留源文件</span><br><span class="line">-d：解压缩</span><br><span class="line">-r：压缩目录</span><br><span class="line"></span><br><span class="line">[root@localhost ~] #  gzip  -c  caixunkun.cfg  &gt;  caixunkun.cfg.gz</span><br><span class="line">#使用-c选项，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件中</span><br><span class="line">#这样可以在压缩文件的同时不删除源文件</span><br></pre></td></tr></table></figure><p><strong>&quot; .gz &quot; 格式的解压缩命令</strong></p><ul><li>命令名称：gunzip</li><li>英文原意：compress or expend files</li><li>所在路径：/bin/gunzip</li><li>执行权限：所有用户</li><li>功能描述：解压缩文件或目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压缩&quot; .gz &quot; 格式，使用&quot;gzip  -d 压缩包&quot; 和 &quot;gunzip 压缩包&quot; 命令都可以解压缩&quot;.gz&quot;格式。</span><br><span class="line">[root@localhost ~] #  gunzip  caixunkun.cfg.gz</span><br><span class="line">[root@localhost ~] #  gzip -d  caixunkun.cfg.gz</span><br></pre></td></tr></table></figure><h3 id="bz2-格式-不能压缩目录"><a class="markdownIt-Anchor" href="#bz2-格式-不能压缩目录"></a> &quot; .bz2 &quot; 格式 (不能压缩目录)</h3><p>&quot; .bz2 &quot; 格式的算法更加先进、压缩比更好；&quot; .gz &quot; 格式相对来讲压缩的时间更快。<br /><strong>&quot; .bz2 &quot; 格式的压缩命令</strong></p><ul><li>命令名称：bzip2</li><li>英文原意：a block-sorting file compressor</li><li>所在路径：/usr/bin/bzip2</li><li>执行权限：所有用户</li><li>功能描述：.bz2格式的压缩命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  bzip2  [选项]  源文件</span><br><span class="line">选项：</span><br><span class="line">-d： 解压缩</span><br><span class="line">-k： 压缩时，保留源文件</span><br><span class="line">-v： 显示压缩的详细信息</span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~] #  bzip2  caixunkun.cfg    #压缩成.bz2 格式</span><br><span class="line">[root@localhost ~] #  bzip2  -k   caixunkun.cfg   #保留源文件压缩</span><br><span class="line">** &quot; .bz2 &quot; 格式的解压缩命令**</span><br><span class="line">- 命令名称：bunzip2</span><br><span class="line">- 英文原意：a biock-sorting file compressor</span><br><span class="line">- 所在路径： &#x2F;usr&#x2F;bin&#x2F;bunzip2</span><br><span class="line">- 执行权限：所有用户</span><br><span class="line">- 功能描述： .bz2格式的解压缩命令</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">[root@localhost ~] #  bunzip2  caixunkun.cfg.bz2</span><br><span class="line">[root@localhost ~] #  bzip2  -d  caixunkun.cfg.bz2</span><br><span class="line">#两个命令都可以解压缩</span><br></pre></td></tr></table></figure><h3 id="tar-格式"><a class="markdownIt-Anchor" href="#tar-格式"></a> &quot; .tar &quot; 格式</h3><p><strong>&quot; .tar &quot;  格式的打包命令</strong></p><ul><li>目录名称：tar</li><li>英文原意：tar</li><li>所在路径：/bin/tar</li><li>执行权限：所有用户</li><li>功能描述：打包与解打包命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  tar  [选项]  [-f 压缩包名]  源文件或目录</span><br><span class="line">选项：</span><br><span class="line">-c：打包</span><br><span class="line">-f：指定压缩包的文件名。压缩包的扩展名时用来给管理员识别格式的，所以一定要正确指定扩展名。</span><br><span class="line">-v：显示打包文件过程。</span><br><span class="line"></span><br><span class="line">[root@localhost ~] # tar  -cvf  caixunkun.cfg.tar  caixunkun.cfg</span><br></pre></td></tr></table></figure><p><strong>&quot; .tar &quot; 格式的解打包命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  tar  [选项]  压缩包</span><br><span class="line">选项： </span><br><span class="line">-x：解打包</span><br><span class="line">-f：指定压缩包的文件名</span><br><span class="line">-v：显示解打包文件过程。</span><br><span class="line">-t：测试，就是不解打包，只是查看包中有哪些文件</span><br><span class="line">-C（大写）目录：指定解打包位置</span><br><span class="line"></span><br><span class="line">例如：[root@localhost ~] #  tar  -xvf  caixunkun.cfg.tar</span><br><span class="line">#解打包到当前目录下</span><br></pre></td></tr></table></figure><h3 id="targz-和-tarbz2-格式"><a class="markdownIt-Anchor" href="#targz-和-tarbz2-格式"></a> &quot; .tar.gz &quot; 和 &quot; .tar.bz2 &quot; 格式</h3><p>使用tar命令直接打包压缩，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  tar  [选项]  压缩包  源文件或目录</span><br><span class="line">选项：</span><br><span class="line">-z：压缩和解压缩&quot; .tar.gz &quot; 格式</span><br><span class="line">-j：压缩和解压缩&quot; .tar.bz2 &quot; 格式</span><br></pre></td></tr></table></figure><p><strong>&quot; .tar.gz &quot; 格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  tar   -zcvf  tmp.tar.gz  &#x2F;tmp&#x2F;</span><br><span class="line">#把 &#x2F;tmp&#x2F;  目录直接打包压缩为 &quot; .tar.gz &quot; 格式</span><br><span class="line"></span><br><span class="line">[root@localhost ~] #  tar  -zxvf  tmp.tar.gz</span><br><span class="line">#解压缩与解打包 &quot; .tar.gz &quot; 格式</span><br></pre></td></tr></table></figure><p><strong>&quot; .tar.bz2 &quot; 格式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  tar   -jcvf  tmp.tar.bz2  &#x2F;tmp&#x2F;</span><br><span class="line">#打包压缩为&quot; .tar.bz2 &quot; 格式，注意压缩包文件名</span><br><span class="line"></span><br><span class="line">[root@localhost ~] #  tar   -jxvf  tmp.tar.bz2  </span><br><span class="line">#解压缩与解打包&quot; .tar.bz2 &quot; 格式</span><br></pre></td></tr></table></figure><p><strong>其他例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  mkdir  test</span><br><span class="line">[root@localhost ~] #  touch  test&#x2F;abc</span><br><span class="line">[root@localhost ~] #  touch  test&#x2F;bcd</span><br><span class="line">[root@localhost ~] #  touch  test&#x2F;cde</span><br><span class="line">#建立测试目录和测试文件</span><br><span class="line"></span><br><span class="line">[root@localhost ~] #  tar  -zcvf  test.tar.gz  test&#x2F;</span><br><span class="line">#压缩</span><br><span class="line">[root@localhost ~] #  tar  -ztvf  test.tar.gz</span><br><span class="line">#只查看，不解压</span><br><span class="line">[root@localhost ~] #  tar  -zxvf  test.tar.gz  -C  &#x2F;tmp</span><br><span class="line">#解压缩到指定的位置</span><br><span class="line">[root@localhost ~] #  tar  -zxvf  test.tar.gz  -C  &#x2F;tmp  test&#x2F;cde</span><br><span class="line">#只解压压缩包中的特定文件，到指定位置</span><br></pre></td></tr></table></figure><h2 id="关机和重启命令"><a class="markdownIt-Anchor" href="#关机和重启命令"></a> 关机和重启命令</h2><h3 id="sync-数据同步"><a class="markdownIt-Anchor" href="#sync-数据同步"></a> sync 数据同步</h3><p>sync命令的基本信息如下：</p><ul><li>命令名称：sync</li><li>英文原意：flush file system buffers</li><li>所在路径：/bin/sync</li><li>执行权限：所有用户</li><li>功能描述：刷新文件系统缓冲区</li></ul><h3 id="shutdown-命令"><a class="markdownIt-Anchor" href="#shutdown-命令"></a> shutdown 命令</h3><p>shutdown命令基本信息如下：</p><ul><li>命令名称：shutdown</li><li>英文原意：bring the system down</li><li>所在路径：/sbin/shutdown</li><li>执行权限：超级用户</li><li>功能描述：关机和重启<br />命令格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  shutdown  [选项]  时间  [警告信息]</span><br><span class="line">选项：</span><br><span class="line">-c：取消已经执行的shutdown 命令</span><br><span class="line">-h：关机</span><br><span class="line">-r：重启</span><br></pre></td></tr></table></figure><h3 id="reboot-命令"><a class="markdownIt-Anchor" href="#reboot-命令"></a> reboot 命令</h3><p>reboot命令安全，不需要加入过多的选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  reboot</span><br><span class="line">#重启</span><br></pre></td></tr></table></figure><h3 id="half-和-poweroff-命令"><a class="markdownIt-Anchor" href="#half-和-poweroff-命令"></a> half 和 poweroff 命令</h3><p>half 和 poweroff 命令都是关机命令，直接执行即可。这两个命令不会完整关闭和保存系统的服务，不建议使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  half</span><br><span class="line">#关机</span><br><span class="line">[root@localhost ~] #  poweroff</span><br><span class="line">#关机</span><br></pre></td></tr></table></figure><h3 id="init-命令"><a class="markdownIt-Anchor" href="#init-命令"></a> init 命令</h3><p>init 是修改linux 运行级别的命令，也可以用于关机和重启。这个命令不安全，不建议使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  init 0</span><br><span class="line">#关机，也就是调用系统的0级别</span><br><span class="line">[root@localhost ~] #  init 6</span><br><span class="line">#重启，也就是调用系统的6级别</span><br></pre></td></tr></table></figure><h2 id="常用网络命令"><a class="markdownIt-Anchor" href="#常用网络命令"></a> 常用网络命令</h2><h3 id="配置ip地址"><a class="markdownIt-Anchor" href="#配置ip地址"></a> 配置IP地址</h3><p><strong>①配置IP地址的两种方法：</strong></p><ul><li>setup 工具</li><li>vi  /etc/sysconfig/network-scripts/ifcfg-eth0    #手工修改配置文件，主要方法。</li></ul><p><strong>②重启网络服务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # service  network  restart</span><br><span class="line">#重启网络服务</span><br></pre></td></tr></table></figure><p><strong>③虚拟机需要桥接到有线网卡，并重启网络服务</strong></p><p>④复制镜像有可能需要重置UUID（唯一识别符）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  vi  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br><span class="line">#删除MAC地址行</span><br><span class="line">[root@localhost ~] #  rm  -rf  &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;70-persistent-net.rules</span><br><span class="line">#删除MAC地址和UUID绑定文件</span><br><span class="line">[root@localhost ~] #  reboot</span><br><span class="line">#重启Linux</span><br></pre></td></tr></table></figure><h3 id="ifconfig-命令"><a class="markdownIt-Anchor" href="#ifconfig-命令"></a> ifconfig 命令</h3><ul><li>命令名称：ifconfig</li><li>英文原意：configure a network interface</li><li>所在路径：/sbin/ifconfig</li><li>执行权限：超级用户</li><li>功能描述：配置网络接口<br />ifconfig命令主要的作用就是查看IP地址的信息，直接输入ifconfig命令即可。</li></ul><h3 id="ping-命令"><a class="markdownIt-Anchor" href="#ping-命令"></a> ping 命令</h3><ul><li>命令名称：ping</li><li>英文原意：send ICMP ECHO_REQUEST to network hosts</li><li>所在路径：/bin/ping</li><li>执行权限：所有用户</li><li>功能描述：向网络主机发送ICMP请求<br />ping命令是常用网络命令，主要通过ICMP协议进行网络探测，测试网络中主机的通信情况。<br />命令的基本格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  ping  [选项]  IP</span><br><span class="line">选项: -b ： 后面加入广播地址，用于对整个网段进行探测</span><br><span class="line">     -c 次数 ：用于指定 ping 的次数</span><br><span class="line"> -s 字节： 指定探测包的大小</span><br><span class="line">例：在ping命令中使用&quot;-b&quot;选项，后面加入广播地址，探测整个网段。从而可以得知整个网络中有多少个主机是可以和我们通信的，而不是一个一个IP地址进项探测。</span><br><span class="line">&#96;&#96;&#96;bash</span><br><span class="line">[root@localhost ~] #  ping  -b  -c  3  192.168.103.255</span><br><span class="line">WARNING:pinging broadcast address</span><br><span class="line">PING 192.168.103.255 (192.168.103.255) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.103.199: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.95ms</span><br><span class="line">64 bytes from 192.168.103.168: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.97ms</span><br><span class="line">64 bytes from 192.168.103.252: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;1.94ms</span><br><span class="line">...省略部分内容...</span><br></pre></td></tr></table></figure><h3 id="netstat-命令"><a class="markdownIt-Anchor" href="#netstat-命令"></a> netstat 命令</h3><p>netstat是网络状态查看命令，可以查看到本机开启的端口，也可以查看有哪些客户端连接。<br />在CentOS7.x 中 netstat 命令默认没有安装，如果需要使用，需要安装net-snmp和net-tools软件包。</p><ul><li>命令名称：netstat</li><li>英文原意：Print network connections,routing tables,interface statistics,masquerade connections,and multicast memberships.</li><li>所在路径：/bin/netstat</li><li>执行权限：所有用户</li><li>功能描述：输出网络连接，路由表，接口统计、伪装连接和组播成员</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  netstat  [选项]</span><br><span class="line">选项：</span><br><span class="line">-a ：   列出所有网络状态，包括socket程序</span><br><span class="line">-c 秒数： 指定每隔几秒数显一次网络状态</span><br><span class="line">-n ：   使用IP地址和端口号显示，不使用域名与服务名</span><br><span class="line">-p ：   显示PID和程序名</span><br><span class="line">-t ：显示使用TCP协议端口的连接状况</span><br><span class="line">-u ：显示使用UDP协议端口的连接状况</span><br><span class="line">-l ：仅显示监听状态的连接</span><br><span class="line">-r ：显示路由表</span><br></pre></td></tr></table></figure><p><strong>例1：查看本机开启端口</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tuln</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto  Recv-Q   Send-Q  Local Address           Foreign Address          State      </span><br><span class="line">tcp       0       0     0.0.0.0:111              0.0.0.0:*               LISTEN      </span><br><span class="line">tcp       0       0     0.0.0.0:22               0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6      0       0     ::1:631                  :::*                    LISTEN     </span><br><span class="line">tcp6      0       0     ::1:25                   :::*                    LISTEN     </span><br><span class="line">tcp6      0       0     ::1:6010                 :::*                    LISTEN     </span><br><span class="line">tcp6      0       0     :::111                   :::*                    LISTEN     </span><br><span class="line">tcp6      0       0     :::22                    :::*                    LISTEN     </span><br><span class="line">udp       0       0     0.0.0.0:997              0.0.0.0:*                          </span><br><span class="line">udp       0       0     0.0.0.0:5353             0.0.0.0:*      </span><br><span class="line">udp6      0       0     :::997                   :::*                               </span><br><span class="line">udp6      0       0     :::111                   :::*                               </span><br><span class="line">udp6      0       0     ::1:323                  :::*  </span><br></pre></td></tr></table></figure><p>这个命令的输出较多。</p><ul><li>Proto：网络连接的协议，一般就是TCP协议或UDP协议。</li><li>Recv-Q：表示接收到的数据，已经在本地缓冲中，但是还没有被进程取走。</li><li>Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地缓冲中，一般是不具备ACK标志的数据包。</li><li>Local Address：本机的IP地址和端口号。</li><li>Foreign Address：远程主机的IP地址和端口号。</li><li>State：状态。常见的状态主要有以下几种<br />-LISTEN：监听状态，只有TCP协议需要监听，而UDP协议不需要监听。<br />-ESTABLISHED：已经建立连接的状态。如果使用 “ -l ” 选项，则看不到已经建立连接的状态。<br />-SYN-SENT：SYN发起包，就是主动发起连接的数据包。<br />-SYN-RECV：接收到主动连接的数据包。<br />-FIN_WAIT1：正在中断的连接。<br />-FIN_WAIT2：已经中断的连接，但正在等待对方主机进项确认。<br />-TIME_WAIT：连接已经中断，但是套接字依然在网络中等待结束<br />-CLOSED：套接字没有被使用<br />在这些状态中，最常见的就是 LISTEN 和 ESTABLISHED 状态，一种代表正在监听，另一种则代表已经建立连接。</li></ul><p><strong>例2：查看本机有哪些程序开启端口</strong><br />使用 “ -p ” 选项可以查看是哪个程序占用了端口，并且可以直到这个程序的PID。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  netstat -tulnp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID&#x2F;Program name   </span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1&#x2F;systemd  </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1415&#x2F;sshd  </span><br><span class="line">udp        0      0 0.0.0.0:67              0.0.0.0:*                           1965&#x2F;dnsmasq        </span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           1890&#x2F;dhclient </span><br></pre></td></tr></table></figure><h3 id="write-命令"><a class="markdownIt-Anchor" href="#write-命令"></a> write 命令</h3><ul><li>命令名称：write</li><li>英文原意：send a message to another user</li><li>所在路径：/usr/bin/write</li><li>执行权限：所有用户</li><li>功能描述：向其他用户发送信息</li></ul><p><strong>登陆终端：</strong><br />-本地字符终端（6个）：  tty1-6         alt+F1-F6<br />-本地图形终端：       tty7         ctrl+alt+F7   （按住3秒，需要安装启动图形界面）<br />-远程中端：        pts/0-255</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  write  user1  pts&#x2F;1</span><br><span class="line">hello,are you ok ?</span><br><span class="line">#向pts&#x2F;1（远程终端1）登录的user1用户发送信息，使用“ctrl+D”快捷键保存发送的数据。</span><br></pre></td></tr></table></figure><h3 id="wall-命令"><a class="markdownIt-Anchor" href="#wall-命令"></a> wall 命令</h3><p>write命令用于给指定用户发送信息，而wall命令用于给所有用户发送信息，包括你自己。执行时，在wall命令后加入需要发送的信息即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  wall  &quot;Hello,are you ok ?&quot;</span><br></pre></td></tr></table></figure><h3 id="mail-命令"><a class="markdownIt-Anchor" href="#mail-命令"></a> mail 命令</h3><p>mail是Linux的邮件客户端命令，可以利用这个命令给其他用户发送邮件。</p><ul><li>命令名称：mail</li><li>英文原意：send and receive Internet mail</li><li>所在路径：bin/mail</li><li>执行权限：所有用户</li><li>功能描述：发送和接收电子邮件</li></ul><p><strong>例1：发送邮件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mail  user1</span><br><span class="line">Subject:hello                    &lt;-  邮件标题</span><br><span class="line">Nice tu meet you !            &lt;-  邮件具体内容</span><br><span class="line">.                                        &lt;-  使用 “ . &quot; 来结束邮件输入</span><br><span class="line">#发送邮件给user1用户</span><br></pre></td></tr></table></figure><p>我们接收到的邮件都保存在”/var/spool/mail/用户名“中，每一个用户都有一个自己的用户名的邮箱。</p><p><strong>例2: 发送文件内容</strong><br />可以先把要发送的信息预先写到文件中，再把某个文件的内容发送给指定用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mail  -s  &quot;test mail&quot;  root  &lt;  &#x2F;root&#x2F;anaconda-ks.cfg</span><br><span class="line">选项：</span><br><span class="line">-s：  指定邮件标题</span><br><span class="line">#把&#x2F;root&#x2F;anaconda-ks.cfg 文件的内容发送给root用户</span><br></pre></td></tr></table></figure><p><strong>例3：查看已经接收的邮件</strong><br />在命令行中执行mail命令，进入mail交互界面，可以查看已经接收的邮件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#  mail</span><br><span class="line">Heirloom Mail version 12.5 7&#x2F;5&#x2F;10.  Type ? for help.</span><br><span class="line">&quot;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;root&quot;: 1 message 1 new</span><br><span class="line">&gt;N  1  root       Mon  Dec 5  22:45  68&#x2F;177  &quot;test mail&quot;&lt;-之前收到的邮件 </span><br><span class="line">&gt;N  2  root       Mon  Dec 5  23:08  18&#x2F;602  &quot;hello&quot;</span><br><span class="line">#未阅读  编号  发件人       时间                   标题</span><br><span class="line">&amp;                                                                   &lt;-等待用户输入命令</span><br></pre></td></tr></table></figure><p>“N” 表示未读邮件，如果是已读邮件，则前面是不会有这个”N“的，之后数字是邮件的编号，如果我们要查看第一封邮件，则只需要输入邮件的编号”1“即可。<br />在交互命令中执行 ” ? &quot; ,可以查看这个交互界面支持的命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&amp; ?</span><br><span class="line">               mail commands</span><br><span class="line">type &lt;message list&gt;             type messages</span><br><span class="line">next                            goto and type next message</span><br><span class="line">from &lt;message list&gt;             give head lines of messages</span><br><span class="line">headers                         print out active message headers</span><br><span class="line">delete &lt;message list&gt;           delete messages</span><br><span class="line">undelete &lt;message list&gt;         undelete messages</span><br><span class="line">save &lt;message list&gt; folder      append messages to folder and mark as saved</span><br><span class="line">copy &lt;message list&gt; folder      append messages to folder without marking them</span><br><span class="line">write &lt;message list&gt; file       append message texts to file, save attachments</span><br><span class="line">preserve &lt;message list&gt;         keep incoming messages in mailbox even if saved</span><br><span class="line">Reply &lt;message list&gt;            reply to message senders</span><br><span class="line">reply &lt;message list&gt;            reply to message senders and all recipients</span><br><span class="line">mail addresses                  mail to specific recipients</span><br><span class="line">file folder                     change to another folder</span><br><span class="line">quit                            quit and apply changes to folder</span><br><span class="line">xit                             quit and discard changes made to folder</span><br><span class="line">!                               shell escape</span><br><span class="line">cd &lt;directory&gt;                  chdir to directory or home if none given</span><br><span class="line">list                            list names of all available commands</span><br><span class="line"></span><br><span class="line">A &lt;message list&gt; consists of integers, ranges of same, or other criteria</span><br><span class="line">separated by spaces.  If omitted, mail uses the last message typed.</span><br></pre></td></tr></table></figure><p>这些交互命令是可以简化的，比如“headers” 命令，就可以直接输入“h”，这是列出邮件表头列表的命令。</p><p>-headers：列出邮件标题列表，直接输入 “ h ” 命令即可<br />-delete：删除指定邮件。比如想要删除第二封，可以输入“d 2”<br />-save：保存邮件。可以把指定邮件保存成文件，如“s 2 /tmp/test.mail&quot;.<br />-quit：退出，并且已经操作过的邮件进行保存。比如移除已删除邮件、保存一月读邮件等。<br />-exit： 退出，但是不保存任何操作。</p>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客定制--5.主题配置</title>
      <link href="2020/07/20/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--5.%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>2020/07/20/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--5.%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="本地搜索"><a class="markdownIt-Anchor" href="#本地搜索"></a> 本地搜索</h2><p>首先在命令行输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>然后打开butterfly.yml文件,false改为true。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Please see doc for more details: https://docs.jerryc.me/config.html#本地搜索</span></span><br><span class="line"><span class="comment"># ---------------</span></span><br><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">false</span></span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search <span class="keyword">for</span> Posts</span><br><span class="line">    hits_empty: <span class="string">&quot;We didn&#x27;t find any results for the search: <span class="variable">$&#123;query&#125;</span>&quot;</span> <span class="comment"># if there are no result</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020072011212855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="效果图" /></p><h2 id="访客地图"><a class="markdownIt-Anchor" href="#访客地图"></a> 访客地图</h2><p>此处感谢<a href="https://blog.csdn.net/weixin_42429718/article/details/105723193?utm_source=app">一百个Chocolate</a>大佬<br />进入<a href="https://clustrmaps.com/">ClustrMaps</a>网站注册一个账号，并登录。<br />登录之后，页面往下拉，点击红圈处。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720125023285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />输入你的博客网址：<strong><a href="https://xn--github-on9im33ani7aou3bged.github.io">https://你的github用户名.github.io</a></strong>点击Next<br />，这里有两种样式 Map widget 和 Globe widget 可选择（我这里选择的是第二个）在网页上找到如下代码，记住src=&quot;xxxxxxxxxxxxxxxxxxx&quot;这段内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="built_in">type</span>=<span class="string">&quot;text/javascript&quot;</span> id=<span class="string">&quot;clstr_globe&quot;</span> src=<span class="string">&quot;xxxxxxxxxxxxxxxxxxx&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 themes\butterfly\layout\includes\widget 文件下创建card_map.pug文件，文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-map</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.fa.fa-globe-asia(aria-hidden=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">      span= _p(<span class="string">&#x27;aside.card_map&#x27;</span>)</span><br><span class="line">    script<span class="comment">#clstr_globe(type=&quot;text/javascript&quot; defer=&quot;defer&quot; src=&quot;此处填入你自己的代码&quot;)</span></span><br></pre></td></tr></table></figure><p>打开 themes\Butterfly\layout\includes\widget\index.pug 文件，将以下内容插入到你相仿的位置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aside.card_map.enable</span><br><span class="line">        !=partial(<span class="string">&#x27;includes/widget/card_map&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>可参考以下（注意格式要严谨,否则会报错）<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720130956160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />编辑 butterfly.yml 文件，在 card_webinfo 下面添加如下图红圈处内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">card_map: </span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720132300926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /></p><p>如果enable就在enable的后写true，如果没有就直接在选项后边写true。<br />打开 themes\butterfly\languages\zh-CN.yml文件添加访客地图，如图：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720132201167.png" alt="" /><br />如果不显示图标就把fontawesome_v5 改为true。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720132356514.png" alt="" /><br />一定要注意格式和位置。</p><h2 id="添加日历"><a class="markdownIt-Anchor" href="#添加日历"></a> 添加日历</h2><p>安装 hexo-generator-calendar 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save git://github.com/howiefh/hexo-generator-calendar.git</span><br></pre></td></tr></table></figure><p>下载 <a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/calendar.js">calendar.js</a> 文件和 <a href="https://github.com/pengloo53/Hexo-theme-light_cn/blob/master/source/js/languages.js">languages.js</a> 文件，把这两个文件保存到themes\Butterfly\source\js 文件夹下。<br />编辑 calendar.js 文件，在文件最后添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    $(<span class="string">&#x27;#calendar&#x27;</span>).aCalendar(<span class="string">&#x27;zh-CN&#x27;</span>);//<span class="string">&#x27;zh-CN&#x27;</span>请根据自己博客的语言选择</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>位置参考如下：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720133335599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />打开butterfly.yml文件，在如下图红圈位置插入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/js/calendar.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/js/languages.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720133611885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />在themes\Butterfly\source\css\ _layout 目录下新建 calendar.styl 文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#calendar</span></span><br><span class="line">  a</span><br><span class="line">    text-decoration none</span><br><span class="line"></span><br><span class="line">.cal-head</span><br><span class="line">  margin-bottom: 15px</span><br><span class="line">  position relative</span><br><span class="line">  height 20px</span><br><span class="line">  padding 8px 6px 2px 6px</span><br><span class="line"></span><br><span class="line">.cal-prev,.cal-next</span><br><span class="line">  position absolute</span><br><span class="line">  top 9px</span><br><span class="line">  width 16px</span><br><span class="line">  height 18px</span><br><span class="line">  padding 3px 4px</span><br><span class="line">  border 1px solid transparent</span><br><span class="line">  color <span class="comment">#333</span></span><br><span class="line">  outline 0</span><br><span class="line"></span><br><span class="line">.cal-prev</span><br><span class="line">  left 8px</span><br><span class="line">  &amp;:before</span><br><span class="line">    border-right 9px solid <span class="comment">#333</span></span><br><span class="line"></span><br><span class="line">.cal-next</span><br><span class="line">  right 8px</span><br><span class="line">  &amp;:before</span><br><span class="line">    border-left 9px solid <span class="comment">#333</span></span><br><span class="line"></span><br><span class="line">.cal-prev:before,.cal-next:before</span><br><span class="line">  content <span class="string">&#x27;&#x27;</span></span><br><span class="line">  display block</span><br><span class="line">  width 0</span><br><span class="line">  height 0</span><br><span class="line">  border-top 5px solid transparent</span><br><span class="line">  border-bottom 5px solid transparent</span><br><span class="line"></span><br><span class="line">.cal-title</span><br><span class="line">  width 120px</span><br><span class="line">  margin 0 auto</span><br><span class="line">  color <span class="comment">#333</span></span><br><span class="line">  font bold 14px/18px Arial</span><br><span class="line">  text-align center</span><br><span class="line">  a</span><br><span class="line">    border 1px solid transparent</span><br><span class="line">    color <span class="comment">#9f9f9f</span></span><br><span class="line"></span><br><span class="line">.cal,</span><br><span class="line">.cal th,</span><br><span class="line">.cal td</span><br><span class="line">  border 1px solid <span class="comment">#d1d1d1</span></span><br><span class="line"></span><br><span class="line">.cal</span><br><span class="line">  display: table</span><br><span class="line">  border-collapse separate</span><br><span class="line">  border-spacing 0</span><br><span class="line">  border-width 1px 0 0 1px</span><br><span class="line">  table-layout fixed</span><br><span class="line">  width 100%</span><br><span class="line">  margin 0</span><br><span class="line">  th</span><br><span class="line">    background <span class="comment">#9f9f9f</span></span><br><span class="line">    color <span class="comment">#fff</span></span><br><span class="line">    border-width 0 1px 1px 0</span><br><span class="line">    font-weight 700</span><br><span class="line">  td</span><br><span class="line">    border-width 0 1px 1px 0</span><br><span class="line">  tbody</span><br><span class="line">    a</span><br><span class="line">      background-color <span class="comment">#007acc</span></span><br><span class="line">      color <span class="comment">#fff</span></span><br><span class="line">      display block</span><br><span class="line">      font-weight 700</span><br><span class="line">    .cal-today</span><br><span class="line">      background-color <span class="comment">#66ecfd</span></span><br><span class="line">      color <span class="comment">#fff</span></span><br><span class="line">  .cal-gray</span><br><span class="line">    color <span class="comment">#bbb8b8</span></span><br><span class="line"></span><br><span class="line">[data-theme=<span class="string">&#x27;dark&#x27;</span>] .cal .cal-gray</span><br><span class="line">  color <span class="comment">#505050</span></span><br><span class="line"></span><br><span class="line">.cal th,</span><br><span class="line">.cal td</span><br><span class="line">  font-weight normal</span><br><span class="line">  line-height 2.5625</span><br><span class="line">  padding 0</span><br><span class="line">  text-align center</span><br><span class="line"></span><br><span class="line">[data-theme=<span class="string">&#x27;dark&#x27;</span>] .cal .cal-foot</span><br><span class="line">  color <span class="comment">#9f9f9f</span></span><br><span class="line"></span><br><span class="line">.cal .cal-foot</span><br><span class="line">  color <span class="comment">#2ca6cb</span></span><br><span class="line"></span><br><span class="line">.cal-title a:hover,</span><br><span class="line">.cal-prev:hover,</span><br><span class="line">.cal-next:hover,</span><br><span class="line">.cal .cal-foot:hover,</span><br><span class="line">.cal .cal-foot:focus,</span><br><span class="line">.cal tbody a:hover,</span><br><span class="line">.cal tbody a:focus</span><br><span class="line">  background-color <span class="comment">#686868</span></span><br><span class="line">  color <span class="comment">#fff</span></span><br><span class="line">  cursor pointer</span><br></pre></td></tr></table></figure><p>在 themes\Butterfly\layout\includes\widget 文件夹新建card_calendar.pug 文件，文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.card-widget.card-calendar</span><br><span class="line">  .card-content</span><br><span class="line">    .item-headline</span><br><span class="line">      i.far.fa-calendar-alt(aria-hidden=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">      span= _p(<span class="string">&#x27;aside.card_calendar&#x27;</span>)</span><br><span class="line">    div.widget-wrap</span><br><span class="line">    div<span class="comment">#calendar.widget</span></span><br></pre></td></tr></table></figure><p>编辑themes\Butterfly\layout\includes\widget\index.pug 文件，在你想要显示的位置插入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aside.card_calendar.enable</span><br><span class="line">        !=partial(<span class="string">&#x27;includes/widget/card_calendar&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>位置参考如下：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720134906641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />编辑 butterfly.yml文件，在 card_webinfo下面添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">card_calendar: </span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720135112852.png" alt="" /><br />在 themes\Butterfly\languages\zh-CN.yml 文件（根据自己语言选择）添加一行<br />card_calendar: 日历   ，位置如下：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720135336389.png" alt="" /><br />最后访客地图和日历的效果如下：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720135536135.png" alt="" /></p><h2 id="添加卡通人物动物"><a class="markdownIt-Anchor" href="#添加卡通人物动物"></a> 添加卡通人物（动物）</h2>]]></content>
      
      
      <categories>
          
          <category> Hexo技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--常用命令（2）</title>
      <link href="2020/07/15/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%882%EF%BC%89/"/>
      <url>2020/07/15/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="搜索命令"><a class="markdownIt-Anchor" href="#搜索命令"></a> 搜索命令</h2><h3 id="whereis-命令"><a class="markdownIt-Anchor" href="#whereis-命令"></a> whereis 命令</h3><p>whereis是搜索系统命令的命令，不能搜索普通文件，只能搜索系统命令。</p><ul><li>命令名称：whereis<br />英文原意： locate the binary,source,and manual page files for a command<br />所在路径：/usr/bin/whereis<br />执行权限： 所有用户<br />功能描述：查找二进制命令、源文件和帮助文档的命令</li></ul><h3 id="which命令"><a class="markdownIt-Anchor" href="#which命令"></a> which命令</h3><ul><li>命令名称：which<br />因为原意：shows the full path of(shell) command<br />所在路径：/usr/bin/which<br />执行权限：所有用户<br />功能描述：列出命令的所在路径。<br />which与whereis的区别：①. whereis命令可以在查找二进制命令的同时，查找帮助文档位置。② which命令在查找二进制命令时，如果这个命令有别名，则还可以找到别命命令。</li></ul><h3 id="locate-命令"><a class="markdownIt-Anchor" href="#locate-命令"></a> locate 命令</h3><ul><li>命令名称：locate<br />英文原意：find files by name<br />所在路径： /usr/bin/locate<br />执行权限： 所有用户<br />功能描述：按照文件名搜索文件<ul><li>优点：按照数据库搜索，搜索速度块，消耗资源小。<strong>数据库位置/var/lib/mlocate/mlocate.db</strong> ,可以使用 updatedb 命令强制更新数据库。</li><li>缺点：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照大小、权限、修改时间等搜索文件</li></ul></li></ul><p><strong>locate命令配置文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  vi  &#x2F;etc&#x2F;updatedb.conf</span><br><span class="line">PRUNE_BIND_MOUNTS  &#x3D;  &quot;yes&quot; </span><br><span class="line">#开始搜索限制，也就是让这个配置文件生效</span><br><span class="line">PRUNEFS  &#x3D;  &quot;......&quot;</span><br><span class="line">#在 locate 执行搜索时,禁止搜索这些文件系统类型</span><br><span class="line">PRUNENAMES  &#x3D; &quot;......&quot;</span><br><span class="line">#在 locate 执行搜索时，进制搜索带有这些扩展名的文件</span><br><span class="line">PRUNEPATHS &#x3D;  &quot;......&quot;</span><br><span class="line">#在locate执行搜索时，禁止搜索这些系统目录</span><br></pre></td></tr></table></figure><h3 id="find命令"><a class="markdownIt-Anchor" href="#find命令"></a> find命令</h3><ul><li>命令名称:  find<br />英文原意:  search for files in a directory hierarchy<br />所在路径：/bin/find<br />执行权限：所有用户<br />功能描述：在目录中搜索文件</li></ul><p><strong>按照文件名搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  find  搜索路径  [选项]  搜索内容</span><br><span class="line">   选项：</span><br><span class="line">   </span><br><span class="line">          -name ：按照文件名搜索  </span><br><span class="line">          -iname ：按照文件名搜索，不区分文件名的大小写</span><br><span class="line">          -inum ：按照 I（inode）节点号搜索</span><br></pre></td></tr></table></figure><p><strong>按照文件大小搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] #  find  搜索路径  [选项]  搜索内容</span><br><span class="line">选项：-size  [ + | - ]大小： 按照指定大小搜索文件</span><br></pre></td></tr></table></figure><p>这里的&quot; + &quot; 的意思是搜索毕指定大小还要大的文件， &quot; - &quot; 的意思是搜索毕指定大小还要小的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">find命令的单位：</span><br><span class="line">[root@localhost ~] #  man  find</span><br><span class="line">      -size n[cwbkMG]</span><br><span class="line">          File uses n units of space. The following suffixes can be used:</span><br><span class="line"></span><br><span class="line">          &#39; b &#39;    for 512-byte block (this is the default if on suffix is used)</span><br><span class="line">              #这是默认单位，如果单位为b 或不写单位，则按照512 Byte搜索</span><br><span class="line">          &#39; c &#39;    for bytes</span><br><span class="line">              #搜索单位c，按照字节搜索</span><br><span class="line">          &#39; w &#39;   for two-byte words</span><br><span class="line">              #搜索单位w，按照双字节(中文）搜索</span><br><span class="line">          &#39; k &#39;    for kilobytes (units of 1024 bytes)</span><br><span class="line">              #按照kB单位搜索，必须是小写k</span><br><span class="line">          &quot; M &quot;  for Megabytes  （units of 1048576 bytes)</span><br><span class="line">              # 按照MB单位搜索，必须是大写M</span><br><span class="line">          &#39; G &#39;   for  Gigabytes（units of  1073741824）</span><br><span class="line">              #按照GB单位搜索， 必须是大写G  </span><br></pre></td></tr></table></figure><p><strong>按照修改时间搜索</strong><br />linux 中的文件有<strong>访问时间</strong>（atime）、<strong>数据修改时间</strong>（mtime）、<strong>状态修改时间</strong>（ctime）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">    -atime [ + | - ]时间：  按照文件访问时间搜索</span><br><span class="line">    -mtime [ + | - ]时间：按照文件数据修改时间搜索</span><br><span class="line">    -ctime [ + | - ]时间：按照文件状态修改时间搜索</span><br></pre></td></tr></table></figure><p>[ + | - ]时间的含义：（如图）</p><ul><li>-5：代表5天内修改的文件</li><li>5：代表前5~6天那一天修改的文件</li><li>+5：代表6天前修改的文件</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200717100923186.PNG#pic_center" alt="" /><br /><strong>按照权限搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">    -perm 权限模式：  查找文件权限刚好等于“权限模式”的文件</span><br><span class="line">    -perm -权限模式：查找文件权限全部包含“权限模式”的文件</span><br><span class="line">    -perm +权限模式：查找文件权限包含“权限模式”的任意一个权限的文件</span><br></pre></td></tr></table></figure><p><strong>按照所有者和所属组搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -uid 用户ID：  按照用户ID查找所有者是指定ID的文件</span><br><span class="line">  -gid 组ID：按照用户组ID查找所属组是指定ID的文件</span><br><span class="line">  -user 用户名：按照用户名查找所有者是指定用户的文件  </span><br><span class="line">  -group 组名：按照组名查找所属组是指定用户组的文件</span><br><span class="line">  -nouser：查找没有所有者的文件  （常用）</span><br></pre></td></tr></table></figure><p>按照所有者和所属组搜索时，&quot;nouser“选项比较长用，主要用于查找垃圾文件和外来文件（从windows系统复制到Linux系统的文件和手工源码包安装的文件都没有所有者）</p><p><strong>按照文件类型搜索</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -type d:   查找目录</span><br><span class="line">  -type f：  查找普通文件</span><br><span class="line">  -type l：  查找软连接文件</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong><br />find命令也支持逻辑运算选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">    -a :  and逻辑与</span><br><span class="line">    -o :  or逻辑或</span><br><span class="line">    -not :  not逻辑非    （也可以写成 &quot; ！&quot; ）</span><br></pre></td></tr></table></figure><p>①-a :  and逻辑与</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find . -size +2k -a type f</span><br><span class="line">#在当前目录下搜索大于2KB，并且文件类型是普通文件的文件</span><br></pre></td></tr></table></figure><p>②-o :  or逻辑或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find . -name caixunkun -o -name xiaotou</span><br><span class="line">.&#x2F;caixunkun</span><br><span class="line">.&#x2F;xiaotou</span><br><span class="line">#在当前目录下搜索文件名要么是 caixunkun 的文件要么是 xiaotou 的文件。</span><br></pre></td></tr></table></figure><p>③-not :  not逻辑非</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # find . -not -name caixunkun</span><br><span class="line">#在当前目录下搜索文件名不是caixunkun的文件。</span><br></pre></td></tr></table></figure><p><strong>其他选项</strong></p><ul><li>-exec选项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">[root@localhost ~] # find 搜索路径 [选项] 搜索内容 -exec 命令2 &#123; &#125; \;</span><br></pre></td></tr></table></figure><p>这个选项的作用其实是把find命令的结果交给由“-exec”调用的命令2来处理。“{ }”就代表find命令的查找结果。</p><ul><li>-ok选项<br />“-ok” 选项和&quot;-exec&quot;选项的作用基本一致，区别在于：&quot;-exec&quot; 的命令2会直接处理，而不询问；  “-ok” 的命令2在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。</li></ul><h3 id="grep命令补充命令"><a class="markdownIt-Anchor" href="#grep命令补充命令"></a> grep命令：补充命令</h3><ul><li>grep 的作用是在文件中提取和匹配符合条件的字符串行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # grep [选项] &quot;搜索内容&quot; 文件名</span><br><span class="line">选项：</span><br><span class="line">       -i ：     忽略大小写</span><br><span class="line">      -n：     输出行号  （搜索内容在原始位置的行号）</span><br><span class="line">      -v：     反向查找</span><br><span class="line">      --color&#x3D;auto：  搜索处关键字用的颜色</span><br></pre></td></tr></table></figure><ul><li><p>find命令与grep命令的区别<br />①find命令作用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配，<br />通配符是<strong>完全匹配</strong>（find命令可以通过-regex选项，把匹配规则转为正则表达式规则，但是不建议如此）<br />②grep命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配，正则表达式是<strong>包含匹配</strong>。</p></li><li><p>通配符与正则表达式</p></li></ul><table><thead><tr><th>通配符</th><th>作用</th></tr></thead><tbody><tr><td>？</td><td>匹配一个任意字符</td></tr><tr><td>*</td><td>匹配 0 个或任意多个字符，也就是可以匹配任意字符</td></tr><tr><td>[]</td><td>匹配中括号中任意一个字符，例如，[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c</td></tr><tr><td>[-]</td><td>匹配中括号中任意一个字符，- 代表一个范围，例如，[a-z]代表匹配一个小写字母</td></tr><tr><td>[^]</td><td>逻辑非，表示匹配不是中括号内的一个字符，例如，[ ^0-9 ]代表匹配一个不是数字的字符</td></tr></tbody></table><table><thead><tr><th>正则符</th><th>作用</th></tr></thead><tbody><tr><td>？</td><td>匹配前一个重复0次，或1次（？是扩展正则，需要使用 egrep 命令）</td></tr><tr><td>*</td><td>匹配前一个字符重复0次或任意多次</td></tr><tr><td>[]</td><td>匹配中括号中任意一个字符，例如，[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c</td></tr><tr><td>[-]</td><td>匹配中括号中任意一个字符，- 代表一个范围，例如，[a-z]代表匹配一个小写字母</td></tr><tr><td>[^]</td><td>逻辑非，表示匹配不是中括号内的一个字符，例如，[ ^0-9 ]代表匹配一个不是数字的字符</td></tr><tr><td>^</td><td>匹配行首  （限位符 ^a 表示a开头）</td></tr><tr><td>$</td><td>匹配行尾    （限位符 a$ 表示a结尾）</td></tr></tbody></table><h3 id="管道符补充命令"><a class="markdownIt-Anchor" href="#管道符补充命令"></a> 管道符：补充命令</h3><p>命令格式：    命令1 | 命令2<br />命令1的正确输出作为命令2的操作对象<br />管道符是文本流，无论命令1输出的结果是什么，导入命令2就是文本就是字符串。</p><p>① 我们经常使用“ll”命令查看文件的长格式，但是有些目录文件众多，例如：/etc/目录，文件众多只能看到最后的内容，看不到前面输出的内容。more命令是可以分屏显示文件内容，这里有一个笨方法,就是先把&quot;ll&quot;命令的输出结果保存到一个临时文件中，然后再用&quot;more&quot;命令把这个文件的内容分屏显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # ll -a &#x2F;etc&#x2F; &gt; &#x2F;root&#x2F;testfile</span><br><span class="line">#用输出重定向，吧”ll“ 命令的输出结果保存到&#x2F;root&#x2F;testfile 文件中</span><br><span class="line">[root@localhost ~] # more &#x2F;root&#x2F;testfile</span><br><span class="line">#因为testfile 是文件，当然可以用more命令分屏显示</span><br><span class="line">总用量 1600</span><br><span class="line">drwxr-xr-x. 157 root root    12288 7月  23 11:49 .</span><br><span class="line">dr-xr-xr-x.  17 root root      224 4月   5 08:06 ..</span><br><span class="line">...省略部分输出...</span><br><span class="line">-rw-r--r--.   1 root root      524 Aug  8  2019 auto.misc</span><br><span class="line">-rwxr-xr-x.   1 root root     1260 Aug  8  2019 auto.net</span><br><span class="line">--More--(6%)</span><br></pre></td></tr></table></figure><p>这样操作很不方便，这时可以使用管道符，操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # ll -a &#x2F;etc&#x2F; | more</span><br></pre></td></tr></table></figure><p>②想要再命令 ll /etc/的结果中搜索 yum  的文件名，这时我们应该用find命令还是grep命令呢？<br />答案是grep命令，虽然我们要搜索的是yum的文件名，但是管道符前命令1的结果无论是什么格式，在导入到命令2后都是字符串。并且find不支持管道符直接操作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # ll -a &#x2F;etc&#x2F; | grep yum</span><br></pre></td></tr></table></figure><p>③netstat命令 （CentOS7中，需要安装net-snmp.x86_64, net-tools.x86_64 两个包才有此命令。7.5系统中已经自动安装）格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # netstat [选项]</span><br><span class="line">选项：</span><br><span class="line">      -a ：                    列出所有网络状态，包括Socket程序</span><br><span class="line">      -c 秒数：             指定每隔几秒刷新一次网络状态</span><br><span class="line">      -n ：                   使用IP地址和端口号显示，不使用域名与服务器</span><br><span class="line">      -p :                      显示PID和程序名</span><br><span class="line">      -t ：                    显示TCP协议端口的连接状况</span><br><span class="line">      -u ：                   显示使用UDP协议端口的连接状况</span><br><span class="line">      -l ：                    仅显示监听状态的连接</span><br><span class="line">      -r ：                    显示路由表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # netstat -an | grep &quot;ESTABLISHED&quot; | wc -l</span><br><span class="line">#统计正在连接的网络连接数量。</span><br></pre></td></tr></table></figure><h3 id="命令的别命补充命令"><a class="markdownIt-Anchor" href="#命令的别命补充命令"></a> 命令的别命：补充命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">命令格式：</span><br><span class="line">[root@localhost ~] #  alias</span><br><span class="line">#查询命令别命</span><br><span class="line">[root@localhost ~] #  alias  别名 &#x3D; &#39;原命令&#39;</span><br><span class="line">#设定命令别命</span><br><span class="line">例如：</span><br><span class="line">[root@localhost ~] #  alias ser&#x3D;&#39;service network restart&#39;</span><br><span class="line">#用 ser 别命，代替service network restart 命令</span><br></pre></td></tr></table></figure><h3 id="常用快捷键补充命令"><a class="markdownIt-Anchor" href="#常用快捷键补充命令"></a> 常用快捷键：补充命令</h3><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>Tab</td><td>命令或文件补全。</td></tr><tr><td>ctrl+A</td><td>把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。</td></tr><tr><td>ctrl+E</td><td>把光标移动到命令行结尾。</td></tr><tr><td>ctrl+C</td><td>强制终止当前的命令。</td></tr><tr><td>ctrl+L</td><td>清屏，相当于clear命令。</td></tr><tr><td>ctrl+U</td><td>删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符删除，使用这个快捷键会更加方便。</td></tr><tr><td>ctrl+Y</td><td>粘贴 ctrl+U剪切的内容。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--常用命令（1）</title>
      <link href="2020/07/13/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%20%20(1)/"/>
      <url>2020/07/13/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%20%20(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="命令的基本格式"><a class="markdownIt-Anchor" href="#命令的基本格式"></a> 命令的基本格式</h2><h3 id="命令提示符"><a class="markdownIt-Anchor" href="#命令提示符"></a> 命令提示符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#</span><br><span class="line">[]:提示符的分隔符</span><br><span class="line">root：显示当前等登陆用户</span><br><span class="line">@ : 分隔符</span><br><span class="line">localhost：当前系统的简写主机名</span><br><span class="line">~：代表用户当前所在的最后一级目录，此例所在是家目录</span><br><span class="line"># #：命令提示符，超集用户是#，普通用户是$</span><br></pre></td></tr></table></figure><h3 id="命令的基本格式-2"><a class="markdownIt-Anchor" href="#命令的基本格式-2"></a> 命令的基本格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# 命令 [选项] [参数] </span><br></pre></td></tr></table></figure><p>ls是最常见 的目录操作命令</p><ul><li>命令名称：ls</li><li>英文原意：list</li><li>所在路径：/bin/ls</li><li>执行权限：所有用户</li><li>功能描述：显示目录下的内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls [选项] [文件名或目录名] </span><br><span class="line">选项：</span><br><span class="line">-a ：显示所有文件</span><br><span class="line">--color&#x3D;when ：支持颜色输出， when的默认值是always（总显示颜色），</span><br><span class="line">      也可以是never（从不显示颜色）和auto（自动）</span><br><span class="line">-d：显示目录信息</span><br><span class="line">-h：人性话显示</span><br><span class="line">-i ：显示文件的 I 节点号</span><br><span class="line">-l ：长格式显示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drw-r--r--. 2 root root    6 4月  16 16:55 caixukun</span><br><span class="line">#    权限    引用计数  所有者 所属组  大小   文件修改时间  文件名</span><br></pre></td></tr></table></figure><h2 id="目录操作命令"><a class="markdownIt-Anchor" href="#目录操作命令"></a> 目录操作命令</h2><p><strong>1. ls命令</strong><br />见上小节<br /><strong>2. cd 命令</strong><br />执行权限：所有用户<br />功能：切换所在目录<br /><strong>2.1 cd命令的简化用法</strong><br />特殊符号                                     作用<br />~                                                代表用户的家目录<br />-                                                 代表上次所在目录<br />.                         代表当前目录<br />…                                                 代表上级目录</p><p><strong>2.2绝对路径和相对路径</strong><br />绝对路径：以根目录作为参照物，从根目录开始，一级一级进入目录<br />相对路径：以当前目录作为参照物，进项目录查找</p><p><strong>3.pwd命令</strong><br />执行权限：所有用户<br />功能：查询所在的工作目录</p><p><strong>4.mkdir 命令</strong><br />执行权限：所有用户<br />功能：创建空目录<br />格式：mkdir [选项 ] 文件名<br />选项 :  -p  递归建立所需目录</p><p><strong>5.rmdir命令  （不常用，原因只能删除空目录）</strong><br />执行权限：所有用户<br />功能：删除空目录<br />格式：rmdir [选项] 目录名</p><h2 id="文件操作命令"><a class="markdownIt-Anchor" href="#文件操作命令"></a> 文件操作命令</h2><p><strong>1.touch命令</strong><br />创建空文件或修改文件时间<br />执行权限：所有用户<br />功能：修改文件的时间戳</p><p><strong>2.star命令</strong><br />查看文件详细信息的命令而且可以看见<strong>最近访问</strong>、<strong>最近更改（数据修改时间）</strong>、<br />**最近改动（状态修改时间）**这三个时间，Linux下没有创建时间。<br />执行权限：所有用户<br />功能：显示文件或文件系统的详细信息<br />![在这里ttps://img-blog.csdnimg.cn/20200928174750427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center)</p><p><strong>3.cat命令</strong><br />用来查看文件内容<br />执行权限：所有用户<br />功能：用来查看文件内容，合并文件并打印输出到标准输出<br />格式：cat [选项] 文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat  [选项]  文件名</span><br><span class="line">选项：</span><br><span class="line">-A：相当于-vET选项的整合，用于列出所有的隐藏符号</span><br><span class="line">-E：列出每行结尾的回车符$</span><br><span class="line">-n：显示行号</span><br><span class="line">-T：把Tab键用^I显示出来</span><br><span class="line">-v：列出特殊字符</span><br></pre></td></tr></table></figure><p><strong>4.more命令</strong><br />执行权限：所有用户<br />功能：分屏显示文件内容<br />交互命令：<br />空格键：向下翻页<br />b:向上翻页<br />回车键：向下滚动一行<br />/字符串：搜索指定的字符串<br />q:退出</p><p><strong>5.less命令</strong><br />于more命令类似，more是分屏显示，less是分行显示<br />执行权限：所有用户<br />功能：分行显示文件内容</p><p><strong>6.head命令</strong><br />执行权限：所有用户<br />功能：显示文件开头的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# head [选项]  文件名</span><br><span class="line">选项:  </span><br><span class="line">-n行数：从文件头开始，显示指定行数</span><br><span class="line">-v: 显示文件名</span><br></pre></td></tr></table></figure><p><strong>7.tail命令</strong><br />执行权限：所有用户<br />功能：显示文件尾的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tail [选项]  文件名</span><br><span class="line">选项： </span><br><span class="line">-n行数：从文件结尾开始，显示指定行数</span><br><span class="line">-f：监听文件的新增内容</span><br></pre></td></tr></table></figure><p><strong>8.ln命令</strong><br />执行权限：所有用户<br />功能：在文件之间建立连接<br /><strong>8.1ln命令的基本格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ln [选项]  源文件  目标文件</span><br><span class="line">选项：</span><br><span class="line">-s：建立软链接，如果不加-s，就是在建立硬链接</span><br><span class="line">-f：强制。如果目标文件已经存在，则删除目标文件后在建立链接文件</span><br></pre></td></tr></table></figure><p><strong>如果创建硬链接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch caixukun   #创建文件caixukun</span><br><span class="line">[root@localhost ~]# ln  &#x2F;root&#x2F;caixukun   &#x2F;tmp&#x2F;    #在tmp目录下创建caixukun的硬链接</span><br><span class="line">#建立硬链接文件，目标文件没有写文件名，会和原名一致</span><br><span class="line">#也就是&#x2F;root&#x2F;caixukun 和&#x2F;tmp&#x2F;caixukun是硬链接文件</span><br></pre></td></tr></table></figure><p><strong>如果创建软链接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# touch xiaotou</span><br><span class="line">[root@localhost ~]# ln -s  &#x2F;root&#x2F;xiaotou  &#x2F;tmp&#x2F;</span><br><span class="line">#创建软连接</span><br></pre></td></tr></table></figure><p><strong>8.2硬链接于软链接的特征</strong><br /><strong>硬链接的特征</strong>：<br />1.源文件和硬链接文件拥有相同的i节点（Inode）和Block<br />2.修改任意一个文件，另一个都改变<br />3.删除任意一个文件，另一个都能使用<br />4.硬链接标记不清，很难确认硬链接文件位置，不建议使用<br />5.硬链接不能链接目录<br />6.硬链接不能跨分区</p><p><strong>软链接特征：</strong><br />1.软链接和源文件用有不同的i节点和Block<br />2.两个文件修改任意一个另一个都改变<br />3.删除软链接源文件不受影响，删除源文件软链接不能使用<br />4.软链接没有实际数据，只保存源文件的i节点，不论源文件多大，软链接大小不变<br />5.软链接的权限是最大权限lrwxrwxrwx,但是由于没有实际数据，最终访问时需要惨开源文件权限<br />6.软连接可以连接目录，可以跨分区<br />7.软连接一定要写绝对路径，软连接特征明显，建议使用软连接</p><h2 id="目录和文件都能操作的命令"><a class="markdownIt-Anchor" href="#目录和文件都能操作的命令"></a> 目录和文件都能操作的命令</h2><p><strong>1.rm命令</strong><br />执行权限：所有用户<br />功能：强大的删除命令，可以删除文件也可以删除目录<br />格式：rm [选项] 文件或目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rm  [选项]  文件或目录</span><br><span class="line">选项：</span><br><span class="line">-f ：强制删除（force）</span><br><span class="line">-i：交互删除，在删除之前会先询问用户（不常用）</span><br><span class="line">-r：递归删除，可以删除目录，一般-rf一起用</span><br></pre></td></tr></table></figure><p><strong>2.cp命令</strong><br />执行权限：所有用户<br />功能：复制文件和目录<br />格式： cp  [选项]  源文件  目标文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cp  [选项]  源文件  目标文件</span><br><span class="line">选项：</span><br><span class="line">-a：相当于-dpr选项合集，这几个选项我们一 一介绍</span><br><span class="line">-d：如果源文件为软连接（对硬链接无效），则复制出的文件也为软连接</span><br><span class="line">-i: 询问，如果目标文件已经存在，则会询问示符覆盖</span><br><span class="line">-p：复制后目标文件保留源文件的属性（包括所有者、所属组、权限和时间）</span><br><span class="line">-r：递归复制，用于复制目录</span><br></pre></td></tr></table></figure><p><strong>3.mv命令</strong><br />执行权限：所有用户<br />功能：移动文件或改名<br />格式：mv [选项] 源文件 目标文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mv  [选项]  源文件  目标文件    </span><br><span class="line">选项：</span><br><span class="line">-f :强制覆盖，如果目标已经存在，则不询问，直接强制覆盖</span><br><span class="line">-i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖（默认选项）</span><br><span class="line">-v：显示详细信息</span><br></pre></td></tr></table></figure><h2 id="基本权限管理"><a class="markdownIt-Anchor" href="#基本权限管理"></a> 基本权限管理</h2><p><strong>1.权限的介绍</strong><br />drw-r–r--. 2 root root    6 4月  16 16:55 caixukun<br />-rw-r–r--. 1 root root   13 4月  17 14:42 xiaotou<br />如上所示：<br />第1位代表文件类型<br />’ - ’ ：普通文件<br />’ b ’ ：块设备文件，这是一种特殊文件，储存设备都是这种文件，如分区文件/dev/sdal<br />’ c ’ ：字符设备文件，也是特殊设备文件，输入设备一般是鼠标、键盘等<br />’ d ’ ：目录文件<br />’ l ’ ：软连接文件<br />’ p ’ ：管道符文件，一种极少见的特殊设备文件<br />’ s ’ ：套接字文件，特殊设备文件，一些支持 Socket 访问，会产生这样的文件<br />第2-4位标识文件所有者的权限<br />’ r ’ ：代表read  ，是读取权限<br />’ w ’ ：代表write ，是写权限<br />’ x ’ ：代表execute ，是执行权限<br />如果权限位是 ’ - ’ 则代表相对应用户没有该权限<br />第5-7位代表所属组的权限<br />第8-10位代表其他人权限</p><p><strong>2.基本权限命令</strong></p><ul><li>命令名称：chmod<br />英文原意：change file mode bits<br />所在路径：/bin/chmode<br />执行权限：所有用户<br />功能描述：修改文件的权限模式<br />命令格式：chmod  [选项]  权限模式  文件名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod  [选项]  权限模式  文件名</span><br><span class="line">选项： -R  递归设置权限，也就是给子目录的所有文件设定权限</span><br></pre></td></tr></table></figure><ul><li><p>权限模式<br />修改权限  chmod  [ u g o a ][ + = - ][ r w x ]   [用户身份][赋予方式][权限]<br />用户身份：<br />u ：代表所有者（user）<br />g ：代表所属组（group）<br />o ：代表其他人（other）<br />a ：代表全部身份（all）<br />赋予权限的方式<br />’ + '：加入权限<br />’ - '：去掉权限<br />’ = '：设置权限<br />权限<br />r ：读权限   代表read<br />w ：写权限  代表write<br />x ：执行权限  代表execute</p><ul><li>数字权限<br />4 ：代表  r  权限<br />2 ：代表  w  权限<br />1 ：代表   x  权限<br />修改权限  chmod  [权限数字]  [目标文件]</li></ul></li><li><p>常用权限<br />644 ：这是文件的基本权限，代表所有者有读写，所属组和其他人只拥有读权限<br />755 ：这是文件的执行权限和目录的基本权限，代表所有者有读、写、执行权限，而所属组和其他人拥有读和执行权限<br />777 ：这是最大权限，实际生产服务器要尽量避免给文件或目录赋予这样权限，危险很大</p></li></ul><p><strong>3.所有者和所属组命令</strong></p><ul><li>命令名称：chown<br />英文原意：change file owner and group<br />所在路径：/bin/chown<br />执行权限：所有用户<br />功能描述：chwon是修改文件和目录所有者和所属组的命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chown  [选项]  所有者:所属组  文件或目录</span><br><span class="line">            -R : 递归设置权限，也就是给子目录中的所有文件设置权限</span><br></pre></td></tr></table></figure><pre><code>  普通用户可以修改所有者是自己的文件的**权限** 。  普通用户不能修改所有者，即使自己是这个文件的所有者也不可以。只要超级用户才能修改所有者。</code></pre><p>-命令名称：chgrp<br />英文原意：change group ownership<br />所在路径：/bin/chgrp<br />执行权限：所有用户<br />功能描述：修改文件和目录的所属组</p><p><strong>4.基本权限的作用</strong></p><ul><li><p>权限含义的解释<br />-权限对文件的作用：<br />-读（r）：对文件有读(read)权限，代表可以读取文件中的数据。如果把权限对应到命令上，<br />那么一旦对文件有读权限，就可以对文件执行 <strong>cat、more、less、head、tail</strong> 等查看文件的命令。<br />-写（w）：对文件有写（write），代表可以修改文件中的数据。如果把权限对应到命令上，<br />那么一旦文件有写权限，就可以对文件执行<strong>vim、echo</strong>等修改文件数据的命令。注意：<br />对文件有写权限，是不能删除文件本身，只能修改文件中的数据。如果想要删除文件，则需要对文件的上级目录拥有写权限。<br />-执行（x）：对文件有执行权限，代表文件拥有了执行权限，可以运行。Linux中只要文件有执行权限，这个文件就是执行文件。但是文件既要有执行权限还要文件中的代码正确才能正确执行。所以对文件来说执行（x）权限是最高权限。</p><p>-权限对目录的作用<br />-读（r）：对目录有读（read）权限，代表可以查看目录下的内容。如果把权限对应到命令上，就可以在目录下执行<strong>ls 命令</strong>。<br />-写（w）：代表可以修改目录下的数据，就是可以在目录中新建、删除、复制、剪切子文件或子目录。可以在目录下执行 <strong>touch、rm、cp、mv命令。对目录来说写（w）是最高权限。</strong><br />-执行（x）：因为目录无法运行，则目录有执行权限，代表可以进入目录，可以通过<strong>cd 命令</strong>进入目录。</p></li><li><p>目录的可用权限<br />目录的可用权限其实只要三个：</p><ul><li>0 : 任何权限都不赋予</li><li>5 : 基本的目录浏览和进入权限</li><li>7 : 完全权限</li></ul></li></ul><p><strong>5.umask默认权限</strong><br /><strong>查看系统 的umask权限</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umask</span><br><span class="line">0022</span><br><span class="line">#用八进制数值显示umask权限</span><br><span class="line">[root@localhost ~]#  umask  -S</span><br><span class="line">u&#x3D;rwx,g&#x3D;rx,o&#x3D;rx</span><br><span class="line">#用字母表示文件和目录的初始权限</span><br></pre></td></tr></table></figure><p><strong>umask权限的计算方法</strong><br />- 对文件来讲，新建文件的默认最大权限是666，没有执行权限。这是因为执行权限对文件来说比较危险，不能在新建文件时默认赋予，必须通过手动赋予。<br />-对目录来讲，新建目录的默认最大权限是777.这是因为对目录而言，执行权限仅仅代表进入目录，所以即使建立新文件是直接默认赋予，没有声明危险。</p><ul><li><p>文件的默认权限最大只能是666，而umask的值是022<br />“-rw-rw-rw-”减去  “----w–w-”等于 “-rw-r–r—”</p></li><li><p>目录的默认权限最大可以是777，而umask的值是022<br />“drwxrwxrwx&quot; 减去  ”d----w–w-“  等于 ”drwx-r-xr-x“</p><p>注意： umask默认权限的计算不是数字直接相减。<br />例如umask是033<br />文件的默认权限最大只能是 666，而umask的值是 033<br />”-rw-rw-rw-“  减去”-----wx-wx“  等于 ”-rw-r–r—“</p></li></ul><h2 id="帮助命令"><a class="markdownIt-Anchor" href="#帮助命令"></a> 帮助命令</h2><p><strong>1. man命令</strong><br />命令名称：man<br />英文原意：format and display the on-manual pages<br />所在路径：/usr/bin/man<br />执行权限：所有用户<br />功能描述：显示联机帮助手册<br />格式：man  [选项]  命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# man  [选项]  命令</span><br><span class="line">选项：  -f : 查看命令拥有哪个级别的帮助   或whatis命令</span><br><span class="line">            -k : 查看和命令相关的所有帮助</span><br></pre></td></tr></table></figure><ul><li>man命令的快捷键</li></ul><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>上箭头</td><td>向上移动一行</td></tr><tr><td>下箭头</td><td>向下移动一行</td></tr><tr><td>PgUp</td><td>向上翻一页</td></tr><tr><td>PgDn</td><td>向下翻一页</td></tr><tr><td>g</td><td>移动到第一页</td></tr><tr><td>G</td><td>移动到最后一页</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/字符串</td><td>从当前页向下搜索字符串</td></tr><tr><td>？字符串</td><td>从当前页向上搜索字符串</td></tr><tr><td>n</td><td>当搜索字符串时，可以使用n键找到下一个字符串</td></tr><tr><td>N</td><td>当搜索字符串时，使用N键反向查询字符串</td></tr></tbody></table><p><strong>2.info命令</strong></p><pre><code>  info命令的帮助信息是一套完整的资料，每个单独的命令的帮助信息只是这套完整资料的某一章节。</code></pre><table><thead><tr><th>快捷键</th><th>作用</th></tr></thead><tbody><tr><td>上箭头</td><td>向上移动一行</td></tr><tr><td>下箭头</td><td>向下移动一行</td></tr><tr><td>PgUp</td><td>向上翻一页</td></tr><tr><td>PgDn</td><td>向下翻一页</td></tr><tr><td>Tab</td><td>在有“ * ”符号的节点进行切换</td></tr><tr><td>回车</td><td>进入有“ * ”符号的子页面，查看详细帮助信息</td></tr><tr><td>u</td><td>进入上一层信息（回车是进入下一层信息）</td></tr><tr><td>n</td><td>进入下一小节信息</td></tr><tr><td>p</td><td>进入上一小节信息</td></tr><tr><td>？</td><td>查看帮助信息</td></tr><tr><td>q</td><td>退出info信息</td></tr></tbody></table><p><strong>3.help命令</strong> (不重要)<br />help只能获取shell内置命令的帮助</p><ul><li>命令名称：help</li><li>英文原意：help</li><li>所在路径：shell内置命令</li><li>执行权限：所有用户</li><li>功能描述：显示shell内置命令的帮助，可以使用type命令来区分内置命令与外部命令<br />shell是Linux的命令解释器</li></ul><p><strong>4. --help 选项</strong></p><ul><li>格式：ls  --help</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls  --help</span><br></pre></td></tr></table></figure><ul><li>绝大多数的命令都可以使用“–help” 选项来查看帮助，这也是帮助的一种方法，这种方法比较简单。对以上四种帮助方法可以根据习惯使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--Linux安装</title>
      <link href="2020/07/12/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--Linux%E5%AE%89%E8%A3%85/"/>
      <url>2020/07/12/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--Linux%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="linux安装"><a class="markdownIt-Anchor" href="#linux安装"></a> Linux安装</h1><h2 id="vmware虚拟机安装与使用"><a class="markdownIt-Anchor" href="#vmware虚拟机安装与使用"></a> VMware虚拟机安装与使用</h2><pre><code>  1.VMware简介  VMware是一个虚拟PC的软件，可以在现有的操作系统上虚拟出一个新的硬件环境，相当于模拟出一台新的PC，一次来实现一台机器上真正同时运行两个独立的操作系统。  VMware官方网站：http://www.vmware.com  2.建议的VMware配置  3.安装VMware  4.新建虚拟机  5.虚拟机硬件设置  6.虚拟机使用技巧  7.虚拟机网络设置  </code></pre><h2 id="系统分区"><a class="markdownIt-Anchor" href="#系统分区"></a> 系统分区</h2><h3 id="磁盘分区"><a class="markdownIt-Anchor" href="#磁盘分区"></a> 磁盘分区</h3><pre><code>      两种分区表现形式：         MBR分区表：最大支持2.1TB硬盘，最多支持4个分区         GPT分区表（全局唯一标示分区表）：GPT分区支持9.4ZB硬盘（1ZB=1024PB，1PB=1024EB            1EB=1024TB）理论上支持的分区数没有限制，但Windows限制128个主导分区      分区类型：          主分区：最多只能4个          拓展分区：最多只能与一个                       主分区加扩展分区最多有4个                       不能写入数据，只能包含逻辑分区      逻辑分区</code></pre><h3 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化：</h3><pre><code>     格式化（高级格式化）又称逻辑格式化，它是指根据用户选定的文件系统（如FAT16、FAT32、NTFS、     EXT2、EXT3、EXT4等），在磁盘的额定区域写入特定的数据，在分区中划出一片用于存放文件分配表、     目录表等拥于文件管理的磁盘空间。     block=4kb   block是储存最小单位 。  Inode=128b   记录了：i节点号、时间、权限、位置。</code></pre><h3 id="硬件设备文件名-不需要背"><a class="markdownIt-Anchor" href="#硬件设备文件名-不需要背"></a> 硬件设备文件名 （不需要背）</h3><pre><code>        分区设备文件名（背）            /dev/hda1（IDE硬盘接口）            /dev/sda1（SCSI硬盘接口、SATA硬盘接口）   sd表示硬盘接口类型   a第一块硬盘abcd以此类推                1表示第1分区    5表示第一扩展分区  </code></pre><h3 id="挂载"><a class="markdownIt-Anchor" href="#挂载"></a> 挂载</h3><pre><code>    挂载点（使用已经存在的空目录作为挂载点，所有的空目录，包括新建目录都可以作为挂载点，    但是/bin/、/lib/、/etc/要和根目录在一起）       必须分区            / (根分区)            swap分区 (交换分区)没有挂载点              如果真实内存小于4GB，swap为内存的两倍              如果真实内存大于4GB，swap和内存一致              实验环境，不大于2GB      推荐分区              /boot (启动分区，1GB)      常用分区                    /home(用于文件服务器)        　　　              /www (用于Web服务器)</code></pre><h2 id="文件系统结构"><a class="markdownIt-Anchor" href="#文件系统结构"></a> 文件系统结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200928171159243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h2 id="linux系统安装"><a class="markdownIt-Anchor" href="#linux系统安装"></a> Linux系统安装</h2><h2 id="远程登陆管理工具"><a class="markdownIt-Anchor" href="#远程登陆管理工具"></a> 远程登陆管理工具</h2><p>1.配置IP地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~] # setup</span><br><span class="line">#通过setup工具设置IP地址，注意激活onboot&#x3D;yes</span><br><span class="line">[root@localhost ~] # service network restart</span><br><span class="line">#重启网络服务</span><br></pre></td></tr></table></figure><p>2.虚拟机网络配置<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200928170905537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />3.Winscp文件拷贝工具<br />4.xshell远程工具</p>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--给初学者的建议</title>
      <link href="2020/07/12/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E7%BB%99%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/"/>
      <url>2020/07/12/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--%E7%BB%99%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="给初学者的linux服务器管理建议"><a class="markdownIt-Anchor" href="#给初学者的linux服务器管理建议"></a> 给初学者的Linux服务器管理建议</h1><h2 id="学习linux的注意事项"><a class="markdownIt-Anchor" href="#学习linux的注意事项"></a> 学习Linux的注意事项</h2><pre><code>    1.Linux严格区分大小写    2.linux一切皆文件    3.Linux不靠扩展名区分文件类型    4.Linux中所有的存储设备都必须挂载后才能使用    5.Windows下单程序不能直接在Linux中使用</code></pre><h2 id="服务器管理建议"><a class="markdownIt-Anchor" href="#服务器管理建议"></a> 服务器管理建议</h2><ol><li>了解Linux目录结构</li></ol><table><thead><tr><th>目录名</th><th>目录的作用</th></tr></thead><tbody><tr><td>/bin/</td><td>存放系统命令的目录，普通用户和超级用户都可以执行。 /usr/bin/目录的软连接</td></tr><tr><td>/sbin/</td><td>存放系统命令的目录，只有超级用户才可以执行。是/usr/sbin/目录的软连接</td></tr><tr><td>/usr/bin/</td><td>存放系统命令的目录，普通用户和超级用户都可以执行。</td></tr><tr><td>/usr/sbin/</td><td>存放系统命令的目录，只有超级用户才可以执行。</td></tr><tr><td>/boot/</td><td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等。</td></tr><tr><td>/dev/</td><td>设备文件保存位置</td></tr><tr><td>/etc/</td><td>配置文件保存位置。系统内所有采用默认安装方式 (rpm) 的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等。</td></tr><tr><td>/home/</td><td>普通用户的家目录。在创建用户时，每个用户都要有一个默认登陆和保持自己数据的位置，就是用户的家目录，所有普通用户的宿主目录实在/home/下建立一个和用户名相同的目录。如用户1的家目录就是/home/uesr1/</td></tr><tr><td>/lib/</td><td>系统调用的函数库保存位置。时/usr/lib/的软连接</td></tr><tr><td>/lib64/</td><td>64位函数库保存位置是/usr/lib64/的软连接</td></tr><tr><td>/media/</td><td>挂载目录。系统建议是用来挂在媒体设备的，如软盘和光盘  不常用</td></tr><tr><td>/mnt/</td><td>最习惯的挂载目录。早期Linux只有这一个挂载点，可以挂载U盘 移动硬盘和其他操作系统的分区</td></tr><tr><td>/misc/</td><td>不用的挂载目录，跟随前浪用 /mnt/  挂载就行了</td></tr><tr><td>/opt/</td><td>第三方软件的安装位置,可以不理他。在Linux一般都会把第三方软件装在/uesr/local/下</td></tr><tr><td>/net/   /proc/   /sys/</td><td>这三个不要碰    内存的挂在目录   可以看不要改</td></tr><tr><td>/root/</td><td>超级用户的家目录</td></tr><tr><td>/run/</td><td>系统运行时产生的数据，如ssid，pid等相关数据。/var/run/是此目录的软连接</td></tr><tr><td>/srv/</td><td>服务数据目录。一些系统服务启动后，可以在这个目录中保存保存所需要的数据</td></tr><tr><td>/tmp/</td><td>临时目录。系统存放临时文件的目录，再该目录下，所有用户都可以访问和写入。建议这里不要保存重要数据。</td></tr><tr><td>/usr/</td><td>系统软件资源目录存放系统软件资源目录，系统中安装的软件大多数保存在这里  要与user区分开</td></tr><tr><td>/uesr/local/</td><td>主要的第三方软件安装位置</td></tr><tr><td>/uesr/local/src/</td><td>我们手工下载的源码包和内核源码包的保存位置</td></tr><tr><td>/uesr/share/</td><td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td></tr><tr><td>/uesr/src/</td><td>源码包保存位置 （实际工作不会用）但是我们实际工作中手工下载的源码包和内核源码包都可以保存在 /uesr/local/src/目录下</td></tr><tr><td>/uesr/src/kernels/</td><td>内核源码保存位置</td></tr><tr><td>/var/</td><td>保存动态数据的目录。主要保存缓存、日志以及软件运行所产生的文件</td></tr><tr><td>/var/www/html/</td><td>RPM包安装的Apache的网页主目录  写好的网页放在这里才会被访问到  装完Apache才会有这个目录</td></tr><tr><td>/var/lib/</td><td>程序运行中需要调用或改变的数据保存位置。如MySQL的数据库保存在/var/lb/mysql/目录中</td></tr><tr><td>/var/log/</td><td>系统日志保存位置</td></tr><tr><td>/var/run/</td><td>服务和程序运行后他们的PID ( 进程ID ) 保存位置   是/run/目录的软连接</td></tr><tr><td>/var/spool/</td><td>放置队列数据的目录</td></tr><tr><td>/var/spool/mail/</td><td>收到新邮件列队的默认保存位置</td></tr><tr><td>/var/spool/cron/</td><td>系统定时任务列队保存位置   系统的计划任务会保存在这里</td></tr></tbody></table><ol start="2"><li><p>远程服务器关机重启时的注意事项<br />远程服务器不能关机，服务器重启前要中止正在执行的服务，重启命令建议使用‘ shutdown -r now ’<br />最好在重启之前执行几次 sync  命令 ，这条命令是数据同步命令， 可以让临时储存在内存上的数据尽快存储到硬盘上</p></li><li><p>不要在服务器访问高峰运行高负载命令</p></li><li><p>远程配置防火墙时不要把自己踢出服务器<br />防火墙：  基本功能是数据包过滤  （IP、MAC地址、端口号、协议类型、数据包中数据）<br />可以先写个系统定时任务让他每5分钟清空一些防火墙规则就算写错了也有反悔的机会等测试没问题了在删除这个定时任务</p></li><li><p>指定合理的密码规范并定期更新<br />密码具有复杂性  易记忆性和时效性三原则</p></li><li><p>合理分配权限<br />服务器管理有一个简单的原则： 给予用户最小的权限</p></li><li><p>定期备份重要数据和日志<br />多备份</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统管理--Linux简介</title>
      <link href="2020/07/11/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--Linux%E7%AE%80%E4%BB%8B/"/>
      <url>2020/07/11/Linux%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86--Linux%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="linux简介"><a class="markdownIt-Anchor" href="#linux简介"></a> Linux简介</h1><p><strong>本文仅为个人笔记，相关视频资料请前往<a href="http://www.atguigu.com/">尚硅谷官网</a>或<a href="https://space.bilibili.com/302417610?from=search&amp;seid=10052146062514960450">bilibili尚硅谷官方号</a>获取。</strong></p><h2 id="unix和linux的发展史"><a class="markdownIt-Anchor" href="#unix和linux的发展史"></a> UNIX和Linux的发展史</h2><ul><li>UNIX发展史：<br />（1）1965年，美国麻省理工学院（MIT）、通用电气 公司（GE）及AT&amp;T的贝尔实验室联合开发<br />Multics工程计划， 其目标是开发一种交互式的具有多道程序处理能力的 分时操作系统，但因Multics追求的<br />目标过于庞大复杂，项目进度远远落后于计划，最后贝尔实验室宣布退出。<br />（2）1969年，美国贝尔实验室的肯 • 汤普森在DEC PDP-7机器上开发出了UNIX系统。<br />（3）1971年，肯 • 汤普森的同事丹尼斯 • 里奇发明了C语言；1973年，UNIX系统的绝大部<br />分源代码用C语言重写，这为提高UNIX系统的可 移植性打下基础。</li><li>Linux发展史：<br />Linux系统诞生于1991年，由芬兰大学生李 纳斯（Linus Torvalds）和后来陆续加入的众多 爱好者共同开发完成。<br />Linux是自由软件，源代码开放的UNIX。<br />Linux版本分类</li><li>版本分类：<br />内核版 <a href="http://www.kernel.org">www.kernel.org</a>  RHEL6.x 2.6.x  REHL7.x 3.10.x 发行版  RedHat系列 • 个人版：<br />Fedora • 服务器版：RHEL（RedHat Enterprise Linux）  Debian系列</li><li>Linux主要的发行版本：<br />Redhat  CentOS  SuSE  Debian Ubuntu  等。</li></ul><h2 id="开源软件简介"><a class="markdownIt-Anchor" href="#开源软件简介"></a> 开源软件简介</h2><ul><li><p>开源软件：<br />• Apache： web服务器<br />• Nginx： web服务器<br />• MySQL： 数据库（SQLserver ， Oracle）<br />• PHP： 脚本语言 • Samba： Linux和windows之间的内网文件服务器<br />• MongoDB： NoSQL数据库 redis<br />• Python： 脚本语言<br />• Ruby： 脚本语言<br />• Sphinx： 中文分词</p></li><li><p>支撑互联网的开源技术：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020092316465810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p></li></ul><h2 id="linux应用的领域"><a class="markdownIt-Anchor" href="#linux应用的领域"></a> Linux应用的领域</h2><pre><code>    1、基于Linux的服务器       www.netcraft.com       www.qq.com       download.microsoft.com       www.taobao.com    2、Linux在电影娱乐业             略      3、Linux在嵌入式领域        略</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux系统管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--异常和文件（1）</title>
      <link href="2020/07/10/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%87%E4%BB%B6%EF%BC%881%EF%BC%89/"/>
      <url>2020/07/10/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%87%E4%BB%B6%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2><p>程序在运行过程中，不可避免出现一些错误，比如：</p><ol><li>使用了没有赋值过的变量</li><li>使用了不存在的索引</li><li>除0<br />。。。。</li></ol><p>这些错误在程序中，称为异常<br />程序运行过程中，一旦出现异常将会导致程序立即终止，异常后的代码全部都不会执行</p><h2 id="处理异常"><a class="markdownIt-Anchor" href="#处理异常"></a> 处理异常</h2><p>程序运行时出现异常，目的并不是让我们的程序直接终止<br />python是希望出现异常时，我们可以编写代码来对异常进行处理</p><h2 id="try语句"><a class="markdownIt-Anchor" href="#try语句"></a> try语句</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> :</span><br><span class="line">代码块(可能出现错误的语句)</span><br><span class="line"><span class="keyword">except</span> 异常类型 <span class="keyword">as</span> 异常名 :</span><br><span class="line">代码块(出现错误以后的处理方式)</span><br><span class="line"><span class="keyword">except</span> 异常类型 <span class="keyword">as</span> 异常名 :</span><br><span class="line">代码块(出现错误以后的处理方式)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">代码块(没出差时执行的语句)</span><br><span class="line"><span class="keyword">finally</span> :</span><br><span class="line">代码块(该代码块总会执行)</span><br></pre></td></tr></table></figure><p>try 是必须的，else可有可无<br />except和finall至少要有一个</p><p>可以将可能出错的代码放入try语句，这样如果代码没有错误则会正常执行<br />如果出现错误，则会执行except子句中的代码，这样就可以通过代码处理异常<br />从而避免因为一个异常导致整个程序终止</p><h2 id="异常的传播抛出异常"><a class="markdownIt-Anchor" href="#异常的传播抛出异常"></a> 异常的传播（抛出异常）</h2><p>当在函数中出现异常时，如果在函数中对异常进行了处理，则异常不会继续传播<br />如果函数中没有对异常进行处理，则异常会继续向函数调用处传播，<br />如果函数调用处处理了异常，则不会再传播，如果没有处理则继续向调用处传播<br />直到传递到全局作用域（主模块）如果依然没有处理，则程序终止，并且显示异常信息</p><p>当程序运行过程中出现异常后，所有的异常信息会被保存到一个专门的异常对象中<br />而异常传播时，实际上就是异常对象抛给了调用处<br />比如 ： ZeroDivisionError类的对象专门用来表示除0的异常<br />NameError类的对象专门用来处理变量错误的异常<br />…</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;异常出现前&#x27;</span>)</span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="comment"># print(c)</span></span><br><span class="line"><span class="comment"># l[10]</span></span><br><span class="line"><span class="number">1</span> + <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">print(<span class="number">10</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> NameError :  <span class="comment">#捕获NameError异常</span></span><br><span class="line"><span class="comment">#如果except后边不跟任何的内容，则此时会捕获到所有异常</span></span><br><span class="line"><span class="comment">#如果except后边跟着一个异常的类型， 那么此时只会捕获该类型的异常</span></span><br><span class="line">print(<span class="string">&#x27;出现 NameError 异常&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError :</span><br><span class="line">print(<span class="string">&#x27;出现 ZeroDivisionError 异常&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> IndexError :</span><br><span class="line">print(<span class="string">&#x27;出现 IndexError 异常&#x27;</span>)</span><br><span class="line"><span class="comment">#Exception 是所有异常类的父类，所以如果except后跟的是Exception，它也会捕获到所有的异常</span></span><br><span class="line"><span class="comment">#可以在异常类后边跟着 as  xx  此时 xx 就是异常对象</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e :</span><br><span class="line">print(<span class="string">&#x27;未知异常&#x27;</span>,e,type(e))</span><br><span class="line"><span class="keyword">finally</span> :</span><br><span class="line">print(<span class="string">&#x27;无论是否出现异常，该句子总会执行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;异常出现后&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="抛出异常"><a class="markdownIt-Anchor" href="#抛出异常"></a> 抛出异常</h2><p>可以使用  raise  语句来抛出异常，raise语句后需要跟一个异常类 或 异常的实例</p><p>也可以自定义异常类，只需要创建一个类继承Exception即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span>(<span class="params">Exception</span>) :</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b</span>) :</span></span><br><span class="line"><span class="comment">#如果a和b中有负数，就向调用处抛出异常</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">0</span> <span class="keyword">or</span> b &lt; <span class="number">0</span> :</span><br><span class="line"><span class="comment"># raise 用于向外抛出异常，后边可以跟一个异常类，或者异常类的实例</span></span><br><span class="line"><span class="comment">#raise Exception</span></span><br><span class="line"><span class="comment">#抛出异常的目的，就是告诉调用者这里调用时出现问题，希望你自己处理一下</span></span><br><span class="line"><span class="comment">#raise Exception(&#x27;两个参数中不能有负数&#x27;)</span></span><br><span class="line"><span class="keyword">raise</span> MyError(<span class="string">&#x27;自定义的异常&#x27;</span>)</span><br><span class="line"><span class="comment">#也可以通过 if  else 来代替异常的处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">r = a+b</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">print(add(<span class="number">234</span>,<span class="number">-345</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--异常和文件（2）</title>
      <link href="2020/07/10/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%87%E4%BB%B6%EF%BC%882%EF%BC%89/"/>
      <url>2020/07/10/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BC%82%E5%B8%B8%E5%92%8C%E6%96%87%E4%BB%B6%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="文件file"><a class="markdownIt-Anchor" href="#文件file"></a> 文件（File）</h2><p>通过Python程序来对计算机中的各种文件进行增删改查的操作<br />I/O(Input / Output)<br />操作文件的步骤：</p><ol><li>打开文件</li><li>对文件进行各种操作（读、写），然后保存</li><li>关闭文件</li></ol><h2 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> 打开文件</h2><p>open(file, mode=‘r’, buffering=-1, encoding_=None, errors=None, newline=None, closefd=True, opener=None)<br />使用open函数来打开一个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">file 要打开的文件的名字(路径)</span><br><span class="line">返回值：</span><br><span class="line">返回一个对象，这个对象就代表了当前打开的文件</span><br></pre></td></tr></table></figure><p>创建一个变量，来保存文件的名字<br />如果目标文件和当前文件在同一级目录下，则直接使用文件名即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_name = <span class="string">&#x27;demo.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>在windows系统使用路径时，可以使用 / 来代替  <br />或者可以使用 \ 来代替 <br />或者也可以使用原始字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_name = <span class="string">&#x27;hello\\demo123.txt&#x27;</span></span><br><span class="line">file_name = <span class="string">r&#x27;hello\demo123.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>表示路径时可以使用  … 来返回一级目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_name = <span class="string">&#x27;../hello/demo123.txt&#x27;</span></span><br></pre></td></tr></table></figure><p>#如果目标文件距离当前文件较远，此时可以使用绝对路径<br />#绝对路径应该从磁盘根目录开始书写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file_name = <span class="string">r&#x27;C:\User\用户名\Desktop\hello.txt&#x27;</span>  <span class="comment">#假想demo.txt在桌面的hello文件夹下</span></span><br><span class="line">file_obj = open(file_name) <span class="comment">#打开 file_name  对应的文件</span></span><br><span class="line">print(file_obj)</span><br></pre></td></tr></table></figure><h2 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> 关闭文件</h2><p>先打开文件<br /><strong>file_name = 'demo.txt’</strong></p><p>调用 open( )来打开文件<br /><strong>file_obj = open(file_name)</strong></p><p>当我们获取了文件对象后，所有的对文件的操作都应该通过对象来进行<br />读取文件中的内容<br /><strong>read( ) 方法</strong>，用来读取文件中的内容，它会将内容全部保存为一个字符串返回<br /><strong>content = file_obj.read( )<br />print(content)</strong></p><p>关闭文件<br />调用 <strong>close( )方法</strong>来关闭文件<br />file_obj.close( )</p><h3 id="with-as-语句"><a class="markdownIt-Anchor" href="#with-as-语句"></a> with … as  语句</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file_name) <span class="keyword">as</span> file_obj :</span><br><span class="line"><span class="comment">#在with语句中可以直接使用file_obj来做文件操作</span></span><br><span class="line"><span class="comment">#此时这个文件只能在with中使用，一旦with结束则文件会自动close( )</span></span><br><span class="line"><span class="comment">#print(file_obj.read( ))</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">file_name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="keyword">with</span> open(file_name) <span class="keyword">as</span> file_obj :</span><br><span class="line">print(file_obj.read( ))</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">print(f&#123;file_name&#125;<span class="string">&#x27;文件不存在&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="文件读取"><a class="markdownIt-Anchor" href="#文件读取"></a> 文件读取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">file_name = <span class="string">&#x27;demo.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="comment">#调用open( ) 来打开一个文件，可以见文件分为两种类型</span></span><br><span class="line"><span class="comment">#一种时纯文本文件（使用utf-8等编码编写的文本文件）</span></span><br><span class="line"><span class="comment">#一种时二进制文件（图片、mp3、ppt等这些文件）</span></span><br><span class="line"><span class="comment">#open( ) 打开文件时，默认是以文本文件的形式打开的，但是open( )默认的编码为None</span></span><br><span class="line"><span class="comment">#所以处理文本文件时，必须要指定文件的编码</span></span><br><span class="line"><span class="keyword">with</span> open(file_name,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file_obj :</span><br><span class="line"><span class="comment">#通过 read( ) 来读取文件中的内容</span></span><br><span class="line"><span class="comment">#如果直接调用 read( ) 它会将文本文件的所有内容全部都读取出来</span></span><br><span class="line"><span class="comment">#如果要读取的文件比较大的话，会一次性将文件的内容加载到内存中，容易导致内存泄漏</span></span><br><span class="line"><span class="comment">#所以对于较大的文件，不要直接调用 read( )</span></span><br><span class="line"><span class="comment">#help(file_obj.read)</span></span><br><span class="line"><span class="comment">#read( ) 中可以接受一个size作为参数，该参数用来指定要读取的字符的数量</span></span><br><span class="line"><span class="comment">#   默认值为 -1 ，它会读取文件中的所有字符</span></span><br><span class="line"><span class="comment">#可以为size指定一个值，这样read( ) 会读取指定数量的字符</span></span><br><span class="line"><span class="comment">#每一次读取都是从上次读取的位置开始读取的</span></span><br><span class="line"><span class="comment">#如果字符的数量小于size，则会读取剩余所有单位</span></span><br><span class="line"><span class="comment">#如果已经读取到了文件最后了，则会返回空串</span></span><br><span class="line"></span><br><span class="line">content = file_obj.read( <span class="number">6</span>)</span><br><span class="line">content = file_obj.read( <span class="number">6</span>)</span><br><span class="line">print(content)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">print(f&#123;file_name&#125;<span class="string">&#x27;文件不存在&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="读取大文件"><a class="markdownIt-Anchor" href="#读取大文件"></a> 读取大文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">file_name = <span class="string">&#x27;demo.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> :</span><br><span class="line"><span class="keyword">with</span> open(file_name,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file_obj :</span><br><span class="line"><span class="comment">#定义一个变量，来指定每次读取的大小</span></span><br><span class="line">chunk = <span class="number">100</span></span><br><span class="line"><span class="comment">#创建一个循环来读取文件内容</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line"><span class="comment">#读取chunk大小的内容</span></span><br><span class="line">content = file_obj.read(chunk)</span><br><span class="line"><span class="comment">#检查是否读取到了内容</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> content</span><br><span class="line"><span class="comment">#内容读取完毕，退出循环</span></span><br><span class="line">print(content,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">print(f&#123;file_name&#125;<span class="string">&#x27;文件不存在&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;demo.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(file_name,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file_obj :</span><br><span class="line"><span class="comment">#readline( )</span></span><br><span class="line"><span class="comment">#该方法可以用来读取一行内容</span></span><br><span class="line">content = file_obj.read( )</span><br><span class="line">content = file_obj.read( )</span><br><span class="line"></span><br><span class="line"><span class="comment">#readlines( )</span></span><br><span class="line"><span class="comment">#该方法用于一行一行的读取内容，它会一次性将读取到的内容封装到一个列表中返回</span></span><br><span class="line">r = file_obj.readlines( )</span><br><span class="line">pprint.pprint(r[<span class="number">0</span>])</span><br><span class="line">pprint.pprint(r[<span class="number">1</span>])</span><br><span class="line">pprint.pprint(r[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> file_obj :</span><br><span class="line">print(t)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件的写入"><a class="markdownIt-Anchor" href="#文件的写入"></a> 文件的写入</h2><p>file_name = ‘demo.txt’</p><p>#使用open( )打开文件时必须要指定打开文件所要的操作（读、写、追加）<br />#如果不指定操作类型，则默认是 读取文件  ，而读取文件时是不能向文件中写入的<br /><strong>r 表示只读的</strong><br /><strong>w 表示可写的</strong>，使用 w 来写入文件时，如果文件不存在会创建文件，如果文件存在则会截断文件<br />截断文件指删除原来文件中的所有内容<br /><strong>x 用来新建文件</strong>，如果文件不存在会创建文件，存在则报错<br /><strong>a 表示追加内容</strong>，如果文件不存在会创建文件，如果文件存在则会向文件中追加内容<br /><strong>+ 为操作符增加功能</strong><br /><strong>r+  即可读又可写</strong>，文件不存在会报错<br /><strong>w+<br />a+</strong><br />with open(file_name,‘w’,encoding=‘utf-8’) as file_obj :<br /><strong>write( ) 来向文件中写入内容</strong><br />如果操作的时一个文件的话，则write( ) 需要传递一个字符串作为参数<br />该方法可以分多次向文件中写入内容<br />写入完成后，该方法会返回写入的字符的个数<br />file_obj.write(‘Hello Hello How are you !’)</p><p>file_name = ‘F:/r/三色绘恋原生音乐包/三色绘恋.mp3’<br />读取模式:<br />t 读取文本文件（默认值）<br />b 读取二进制文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(file_name,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file_obj :</span><br><span class="line"><span class="comment">#读取文本文件时，size是以字符为单位的</span></span><br><span class="line"><span class="comment">#读取二进制文件时，size是以字节为单位</span></span><br><span class="line"><span class="comment"># print(file_obj.read(100))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将读取到的内容写出来</span></span><br><span class="line"><span class="comment">#定义一个新的文件</span></span><br><span class="line">new_name = <span class="string">&#x27;aa.flac&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(new_name,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> new_obj :</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义每次读取的大小</span></span><br><span class="line">chunk = <span class="number">1024</span> * <span class="number">100</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line"><span class="comment">#从已有的对象中读取数据</span></span><br><span class="line">conten = file_obj.read(chunk)</span><br><span class="line"><span class="comment">#内容读取完毕，终止循环</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> content :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将读取到的数据写入到新对象中</span></span><br><span class="line">new_obj.write(content)</span><br></pre></td></tr></table></figure><h2 id="读取文件的位置"><a class="markdownIt-Anchor" href="#读取文件的位置"></a> 读取文件的位置</h2><p>with open(‘demo.txt’,‘rb’) as file_obj :<br />print(file_obj.read( ))  #读取是累加的</p><pre><code># seek( )可以修改当前读取的值file_obj.seek(55)file_obj.seek(80,0)file_obj.seek(70,1)file_obj.seek(-10,1)# print(file_obj.read(5))#seek( ) 需要两个参数#第一个，是要切换到的位置#  第二个，计算位置方式#可选值：#0  从头计算，默认值#1  从当前位置计算#2  从最后位置开始计算print(file_obj.read( ))#tell( ) 方法用来查看当前读取位置print('当前读取到了 --&gt;',file_obj.tell( ))</code></pre><h2 id="文件的其他操作"><a class="markdownIt-Anchor" href="#文件的其他操作"></a> 文件的其他操作</h2><p>import os<br />from pprint import pprint</p><h3 id="oslistdir"><a class="markdownIt-Anchor" href="#oslistdir"></a> os.listdir( )</h3><p>获取指定目录的目录结构<br />需要一个路径作为参数，会获取到该路径下的目录结构，默认路径为  .   当前目录<br />该方法会返回一个列表，目录中的每一个文件（夹）的名字都是列表中的一个元素<br />r = os.listdir( )</p><h3 id="osgetcwd"><a class="markdownIt-Anchor" href="#osgetcwd"></a> os.getcwd( )</h3><p>获取当前所在目录<br />r = os.getcwd( )</p><h3 id="oschdir"><a class="markdownIt-Anchor" href="#oschdir"></a> os.chdir( )</h3><p>切换当前所在的目录，作用相当于  cd<br />os.chdir(‘c:/’)<br />r = os.getcwd( )</p><h3 id="创建目录"><a class="markdownIt-Anchor" href="#创建目录"></a> 创建目录</h3><p>os.mkdir(‘caixukun’)<br />在当前目录下创建一个名为  caixukun  的目录</p><h3 id="删除目录"><a class="markdownIt-Anchor" href="#删除目录"></a> 删除目录</h3><p>os.rmdir(‘caixukun’)<br />open(‘xiaotou.txt’)</p><h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3><p>os.remove(‘xiaotou.txt’)</p><h3 id="重命名"><a class="markdownIt-Anchor" href="#重命名"></a> 重命名</h3><p>os.rename(‘旧名字’,‘新名字’)   可以对一个文件进行重命名，也可以用来移动一个文件<br />‘旧名字’ 和 ‘新名字’  都可以是路径 实现剪切功能</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--对象（2）</title>
      <link href="2020/07/09/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/"/>
      <url>2020/07/09/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%AF%B9%E8%B1%A1%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="继承简介"><a class="markdownIt-Anchor" href="#继承简介"></a> 继承简介</h2><p>定义一个类 Animal (动物)<br />这个类需要两种方法：run( ) sleep( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;动物在跑~~~&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;动物在睡觉zzz&#x27;</span>)</span><br></pre></td></tr></table></figure><p>再定义一个类 Dog（狗）<br />这个类需要三个方法：run( )  sleep( ) bark( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;狗在跑~~~&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;狗在睡觉zzz&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bark</span>(<span class="params">self</span>)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">&#x27;汪汪汪~~~&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure><p>上边Animal这个类能实现Dog的部分功能，但是不能实现全部功能<br />如何实现Dog这个类的全部功能：</p><ol><li>直接修改Animal这个类：在这个类中直接添加需要的功能，这种方法修改起来比较麻烦，并且会违反OCP原则</li><li>直接创建一个新的类：创建一个新的类比较麻烦，并且需要大量的复制粘贴，会出现大量的重复性代码</li><li>直接从Animal类中继承他的属性和方法：<br />继承是面向对象的三大特性之一 <br />通过继承我们可以使一个类获取到其他类中的属性方法<br />在定义类时，可以在类命后的括号中指定当前类的父类（超类、基类、super） <br />子类（衍生类）可以直接继承父类中的所有的属性方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bark</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;汪汪汪~~~&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = Dog( )</span><br><span class="line">d.run( )</span><br><span class="line">d.sleep( )</span><br><span class="line">d.bark( )</span><br><span class="line"></span><br><span class="line">r = isinstance(d,Dog) <span class="comment">#检查d是不是Dog的实例</span></span><br><span class="line">r = isinstance(d,Animal)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>在创建类时，如果省略了父类，则默认父类为object<br />object时所有类的父类，所有类都继承自object<br />class Person:     相当于  class Person(object) :</p><p><strong>issubclass( )</strong> 检查一个类是否是另一个类的子类,如果是返回True，反之返回Fals</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(issunclass(Animal,Dog))</span><br><span class="line">print(issubclass(Animal,object))</span><br></pre></td></tr></table></figure><p><strong>isinstance( )</strong> 用来检查一个对象是否是一个类的实例<br />如果这个类是这个对象的父类，也会返回True<br />所有的对象都是object的实例<br />print(isinstance(print,object))</p><h2 id="重写覆盖override"><a class="markdownIt-Anchor" href="#重写覆盖override"></a> 重写（覆盖，override）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#父类实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> :</span>    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;动物在跑~~~&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;动物在睡觉zzz&#x27;</span>)</span><br><span class="line"><span class="comment">#子类实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;狗在跑~~~&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bark</span>(<span class="params">self</span>)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">&#x27;汪汪汪~~~&#x27;</span></span>)</span></span><br><span class="line">d = Dog( )</span><br><span class="line">d.run( )</span><br></pre></td></tr></table></figure><p>如果在子类中如果有和父类同名的方法，则通过子类实例去调用方法时，<br />会调用子类的方法而不是父类的方法，这个特点称为方法的重写（覆盖，override）<br />创建Dog类的实例</p><p>当我们调用一个对象的方法时，会优先去当前对象中寻找是否具有该方法，如果有则直接调用<br />如果没有，则去当前对象的父类中寻找，如果有则直接调用父类中的方法<br />如果没有择去父类的父类去找以此类推直到找到object，如果依然没有则报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self </span>) :</span></span><br><span class="line">print(<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;BBB&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">B</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;CCC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">创建一个C的实例:</span><br><span class="line"></span><br><span class="line">c = C( )</span><br><span class="line">c.test( )</span><br></pre></td></tr></table></figure><h2 id="super"><a class="markdownIt-Anchor" href="#super"></a> super( )</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;动物会跑~~~&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;动物睡觉~~~&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property  #getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter    #setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 父类中的所有方法都会被子类继承，包括特殊方法，也可以重写特殊方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        <span class="comment"># 希望可以直接调用父类的__init__来初始化父类中定义的属性</span></span><br><span class="line">        <span class="comment"># super() 可以用来获取当前类的父类，</span></span><br><span class="line">        <span class="comment">#   并且通过super()返回对象调用父类方法时，不需要传递self</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self._age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bark</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;汪汪汪~~~&#x27;</span>) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;狗跑~~~~&#x27;</span>)   </span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self,age</span>):</span></span><br><span class="line">        self._age = name        </span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">&#x27;旺财&#x27;</span>,<span class="number">18</span>) </span><br><span class="line"></span><br><span class="line">print(d.name)       </span><br><span class="line">print(d.age)       </span><br></pre></td></tr></table></figure><h2 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self </span>) :</span></span><br><span class="line">print(<span class="string">&#x27;AAA&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">object</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>) ：</span></span><br><span class="line"><span class="function"><span class="title">print</span>(<span class="params"><span class="string">&#x27;B中的test( )方法&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">test</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;BBB&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">B</span>) :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;CCC&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在python中是支持多重继承的，就是可以为一个类同时指定多个父类<br />可以在类名的（）后边添加多个类，来实现多重继承<br />多重继承，会使子类同时拥有多个父类，并且会获取到所有父类中的方法<br />在开发中没有特殊的情况，应尽量避免使用多重继承，因为多重继承会让我们的代码过于复杂<br />如果多个父类中有同名的方法，则会出现在第一个父类中寻找，然后第二个，以此类推<br />前边父类的方法会覆盖后边父类的方法<br />class C(A,B) :<br />pass</p><p>类名.<strong>bases</strong> 这个属性可以用来获取当前类的所有父类<br />print(C.<strong>bases</strong>) (&lt;class ‘<strong>main</strong>.B’&gt;,)<br />print(B.<strong>bases</strong>) (&lt;class ‘object’&gt;,)</p><p>print(C.<strong>bases</strong>) # (&lt;class ‘<strong>main</strong>.A’&gt;, &lt;class ‘<strong>main</strong>.B’&gt;)</p><p>c = C()<br />c.test()</p><h2 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h2><p>多态是面向对象的三大特征之一<br />多态可以理解为多种形态<br />狗（狼狗、藏獒、哈士奇。。。）<br />一个对象可以以不同形态去呈现</p><p>定义两个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self,name</span>):</span></span><br><span class="line">self._name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self,name</span>):</span></span><br><span class="line">self._name = name</span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&#x27;菜寻鲲&#x27;</span>)</span><br><span class="line">b = B(<span class="string">&#x27;xiaozhan&#x27;</span>)</span><br></pre></td></tr></table></figure><p>定义一个函数<br />对于 say_hello( ) 这个函数来说，只要对象中有name属性，他就可以作为参数传递<br />这个函数并不会考虑对象的类型，只要有那么属性即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">object</span>):</span></span><br><span class="line">print(<span class="string">&#x27;你好 %s &#x27;</span>%object.name)</span><br></pre></td></tr></table></figure><p>在say_hello_2中我们做了一个类型检查，也就是只有obj是A类对象时，才可以正常使用<br />其他类型的对象都无法使用该类型，这个函数就违反了多态<br />违反了多态的函数，只适用一一种类型的对象，无法处理其他类型对象，这样导致函数的适应性很差<br />注意，向isinstance( )这种函数，在开发中一般不会使用，会违法多态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello_2</span>(<span class="params">obj</span>) :</span></span><br><span class="line"><span class="comment">#做类型检查</span></span><br><span class="line"><span class="keyword">if</span> isinstance(obj,A) :</span><br><span class="line">print(<span class="string">&#x27;你好 %s&#x27;</span>%obj.name)</span><br><span class="line"></span><br><span class="line"> say_hello(b)</span><br><span class="line"> say_hello_2(b)</span><br></pre></td></tr></table></figure><p>之所以一个对象能通过**len( )**来获取长度，是因为对象中具有一个特殊方法__len__<br />只要对象中具有__len__ 特殊方法，就可以通过len( )来获取他的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] </span><br><span class="line">k = <span class="string">&#x27;caixukun&#x27;</span></span><br><span class="line">print(len(l))</span><br><span class="line">print(len(k))</span><br></pre></td></tr></table></figure><h2 id="面向对象的三大特征"><a class="markdownIt-Anchor" href="#面向对象的三大特征"></a> 面向对象的三大特征</h2><p><strong>封装</strong><br />-确保对象中的数据安全<br /><strong>继承</strong><br />-保证了对象的可拓展性<br /><strong>多态</strong><br />-保证了程序的灵活性</p><h2 id="类中的属性和方法"><a class="markdownIt-Anchor" href="#类中的属性和方法"></a> 类中的属性和方法</h2><p>定义一个类,以下通用<br />class A(object):</p><ul><li>类属性</li><li>实例属性</li><li>类方法</li><li>实例方法</li><li>静态方法</li></ul><h3 id="类属性"><a class="markdownIt-Anchor" href="#类属性"></a> 类属性</h3><p>接在类中定义的属性是类属性<br />类属性可以通过类或类的实例访问到<br />但是类属性只能通过类对象来修改，无法通过实例对象修改<br />class A(boject) :<br />count = 0</p><pre><code>def __init__(self) :#实例属性只能通过实例对象来访问和修改，类对象无法访问和修改self.name = 'caixukun'</code></pre><h3 id="实例方法"><a class="markdownIt-Anchor" href="#实例方法"></a> 实例方法</h3><p>在类中定义，以self为第一个参数的方法都是实例方法<br />实例方法在调用时，python会将调用对象作为self传入<br />实例方法可以通过实例和类去调用<br />当通过实例调用时，会将当前调用对象作为self传入<br />当通过类调用时，不会自动传入self，此时我们必须手动传递self</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">self</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;这是test方法~~~&#x27;</span>,self)</span><br></pre></td></tr></table></figure><h3 id="类方法"><a class="markdownIt-Anchor" href="#类方法"></a> 类方法</h3><p>在类内部适用 @classmethod 来修饰的方法属于类方法<br />类方法的第一个参数是cls，也会被自动传递，cls就是当前的类对象<br />类方法和实例方法的区别，实例方法的第一个参数是self，而类方法的第一个参数是cls<br />类方法可以通过类去调用，也可以通过实例调用，没有区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_2</span>(<span class="params">cls</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;这是test_2方法，他是一个类方法~~&#x27;</span>,cls)</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h3><p>在类中使用 @staticmethod 来装饰的方法属于静态方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_3</span>( ) :</span></span><br><span class="line">print(<span class="string">&#x27;test_3执行了~~~&#x27;</span>)</span><br><span class="line">a = A( )</span><br></pre></td></tr></table></figure><h3 id="实例属性"><a class="markdownIt-Anchor" href="#实例属性"></a> 实例属性</h3><p>通过实例对象添加的属性属于实例属性<br />静态方法不需要指定任何的默认参数，静态方法可以通过类和实例去调用<br />静态方法，基本上是一个和当前类无关的方法，他只是一个保存到当前类中的函数<br />静态方法一般都是一些工具方法，和当前类无关<br />a.count = 10<br />A.count = 100<br />print(A.count)<br />print(a,count)</p><p>a.test( ) 等价于 A.test(a)<br />A.test_2( ) 等价于a.test_2( )</p><h2 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h2><p>程序运行过程中回产生垃圾<br />这些垃圾会影响到长须的运行性能。<br />在程序中没有被引用的对象就是垃圾<br />在python中有自动的垃圾回收机制，他会自动将没被引用的对象删除<br />所以不要手动出路垃圾回收</p><p>class A:<br />def <strong>init</strong>(self):<br /><a href="http://self.name">self.name</a> = ‘A类’<br />#del是一个特殊方法，他会在对象被垃圾回收前调用<br />def <strong>del</strong>(self) :<br />print(‘A( )对象被删除了~~~’,self)<br />a = A( )<br />b = a  #又使用一个变量b，来引用a对应的对象<br />print(<a href="http://a.name">a.name</a>)<br />a = None #将a设置为了None，此时没有任何的变量对A( )对象进行引导，他就是垃圾<br />input(‘回车键退出。。。’)</p><p>特殊方法，也称魔术方法<br />特殊方法都是使用__开通和结尾的<br />特殊方法一般不需要我们手动调用，需要在一些特殊情况下自动执行</p><p>定义一个Person类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;docstring for Person&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name,age</span>):</span></span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br></pre></td></tr></table></figure><pre><code>__str__( ) 这个特殊方法会在尝试将对象转换为字符串的时候调用</code></pre><p>它的作用可以来指定对象转换为字符串的结果<br />def <strong>str</strong>(self) :<br />return ‘Person [name=%s,age=%d]’%(<a href="http://self.name">self.name</a>,self.age)</p><pre><code>__repr__( ) 这个特殊方法会在对当前对象使用repr( )函数时调用它的作用是指定对象在‘交互模式’中直接输出的效果def __repr__(self) :return 'hello' object.__add__(self, other) object.__sub__(self, other) object.__mul__(self, other) object.__matmul__(self, other) object.__truediv__(self, other) object.__floordiv__(self, other) object.__mod__(self, other) object.__divmod__(self, other) object.__pow__(self, other[, modulo]) object.__lshift__(self, other) object.__rshift__(self, other) object.__and__(self, other) object.__xor__(self, other) object.__or__(self, other) object.__lt__(self, other) 小于 &lt; object.__le__(self, other) 小于等于 &lt;= object.__eq__(self, other) 等于 == object.__ne__(self, other) 不等于 != object.__gt__(self, other) 大于 &gt; object.__ge__(self, other) 大于等于 &gt;=  __len__()获取对象的长度 object.__bool__(self) 可以通过bool来指定对象转换为布尔值的情况def __bool__(self):    return self.age &gt; 17 __gt__会在对象做大于比较的时候调用，该方法的返回值将会作为比较的结果 他需要两个参数，一个self表示当前对象，other表示和当前对象比较的对象 self &gt; otherdef __gt__(self , other):    return self.age &gt; other.age</code></pre><p>创建两个Person类的实例<br />p1 = Person(‘caixukun’,18)<br />p2 = Person(‘xiaozhan’, 32)</p><p>print(p1)  #&lt;<strong>main</strong>.Person object at 0x00F2A118&gt;<br />打印p1，实际上打印店是对象中特殊方法__str__( ) 的返回值</p><p>print(p1 &gt; p2)<br />print(p2 &gt; p1)</p><p>print(bool(p1))</p><p>if p1 :<br />print(<a href="http://p1.name">p1.name</a>,‘已经成年了’)<br />else :<br />print(<a href="http://p1.name">p1.name</a>,‘还未成年了’)</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--对象（3）</title>
      <link href="2020/07/09/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%AF%B9%E8%B1%A1%EF%BC%883%EF%BC%89/"/>
      <url>2020/07/09/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%AF%B9%E8%B1%A1%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="模块-module"><a class="markdownIt-Anchor" href="#模块-module"></a> 模块( module)</h2><p>模块化，模块值将一个完整的程序分解为一个一个小的模块<br />通过模块组合，来搭建一个完整的程序<br />不采用模块化，统一将所有的代码编写到一个文件中<br />采用模块化，将程序分别编写到多个文件中<br />模块化的优点：</p><ul><li>方便开发</li><li>方便维护</li><li>模块可以复用</li></ul><p>在python中一个py文件就是一个模块，要想创建模块就是创建一个python文件<br />注意：模块名要符号标识符的规范<br />在一个模块中引入外部模块</p><ol><li>import  模块名 （模块名就是python文件的名字，注意不要py）</li><li>import  模块名  as  模块别名</li></ol><p>可以引入同一个模块多次，但是模块的实例只会创建一个<br />import可以在程序的任意位置调用，但一般情况下，import语句都会统一写在程序的开头<br />在每一个模块内部都有一个__name__属性，通过这个属性可以获取到模块的名字<br />__name__属性值为 __main__的模块时主模块，一个程序指挥一个主模块<br />主模块就是我们直接通过python执行的模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test_module <span class="keyword">as</span> test</span><br><span class="line">print(test.__name__)</span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure><h2 id="模块的使用"><a class="markdownIt-Anchor" href="#模块的使用"></a> 模块的使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问模块中的变量：模块名.变量名</span></span><br><span class="line">print(m.a , m.b)</span><br><span class="line">m.test2()</span><br><span class="line">p = m.Person()</span><br><span class="line">print(p.name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;这是主模块中的test2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">#也可以只引入模块中的部分内容</span></span><br><span class="line"> <span class="comment">#语法 from 模块名 import 变量,变量....</span></span><br><span class="line"> <span class="keyword">from</span> m <span class="keyword">import</span> Person</span><br><span class="line"> <span class="keyword">from</span> m <span class="keyword">import</span> test</span><br><span class="line"> <span class="keyword">from</span> m <span class="keyword">import</span> Person,test</span><br><span class="line"> <span class="keyword">from</span> m <span class="keyword">import</span> * <span class="comment"># 引入到模块中所有内容，一般不会使用</span></span><br><span class="line"> p1 = Person()</span><br><span class="line"> print(p1)</span><br><span class="line"> test()</span><br><span class="line"> test2()</span><br><span class="line"></span><br><span class="line"> <span class="comment">#也可以为引入的变量使用别名</span></span><br><span class="line"> <span class="comment">#语法：from 模块名 import 变量 as 别名</span></span><br><span class="line"> <span class="keyword">from</span> m <span class="keyword">import</span> test2 <span class="keyword">as</span> new_test2</span><br><span class="line"></span><br><span class="line"> test2()</span><br><span class="line"> new_test2()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> m <span class="keyword">import</span> *</span><br><span class="line"> print(_c)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">import</span> xxx</span><br><span class="line"> <span class="keyword">import</span> xxx <span class="keyword">as</span> yyy</span><br><span class="line"> <span class="keyword">from</span> xxx <span class="keyword">import</span> yyy , zzz , fff</span><br><span class="line"> <span class="keyword">from</span> xxx <span class="keyword">import</span> *</span><br><span class="line"> <span class="keyword">from</span> xxx <span class="keyword">import</span> yyy <span class="keyword">as</span> zz</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="包-package"><a class="markdownIt-Anchor" href="#包-package"></a> 包 （Package）</h2><p>包也是一个模块<br />当我们模块中代码过多时，或者一个模块需要被分解为多个模块时，这是就需要使用到包<br />普通的模块就是一个py文件，而包时一个文件夹<br />包中必须要一个一个  <strong>init</strong>.py 这个文件，这个文件中可以含有包中的主要内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> a , b</span><br><span class="line">print(a.c)</span><br><span class="line">print(b.c)</span><br></pre></td></tr></table></figure><p><strong>pycache</strong> 是模块的缓存文件<br />py代码在执行前，需要被解析器先转为机械码，然后在执行<br />所以我们在使用模块（包）时，也需要将模块的代码先转换为机器码然后再交由计算机啊执行<br />而为了提高程序运行的性能，python会在编译过异常后，将代码保存到一个缓存文件中<br />这样再下次加载这个模块（包）时，就可以不再重新编译而是直接加载缓存中编译好的代码即可</p><h2 id="python标准库"><a class="markdownIt-Anchor" href="#python标准库"></a> python标准库</h2><p>为了使用方便，python中为我们提供了一个模块的标准库<br />这个标准库中，有很多很强大的模块我们可以直接使用<br />并且标准库会随python的安装一起安装</p><p><strong>sys模块</strong><br />它里面提供了一些变量和函数，使我们可以获取到python解析器的信息<br />或者通过函数来操作python解析器<br />引入sys模块<br />import sys</p><p><strong>pprint模块</strong><br />pprint模块给我们提供了一个方法  pprint( ) 该方法可以用来打印的数据做简单的格式化<br />import pprint</p><p><strong>sys.argv</strong><br />获取执行代码时，命令行中所包含的参数<br />该属性是一个列表，列表中保存了当前命令的所有参数<br />print(sys.argv)</p><p><strong>sys.modules</strong><br />获取当前程序中引入的所有模块<br />modules是一个字典，字典的key是模块的名字，字典的value是模块对象<br />pprint.pprint(sys.modules)</p><p><strong>sys.path</strong><br />他是一个列表，列表中保存的是模块的搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#39;C:\\Users\\lilichao\\Desktop\\resource\\course\\lesson_06\\code&#39;,</span><br><span class="line">&#39;C:\\dev\\python\\python36\\python36.zip&#39;,</span><br><span class="line">&#39;C:\\dev\\python\\python36\\DLLs&#39;,</span><br><span class="line">&#39;C:\\dev\\python\\python36\\lib&#39;,</span><br><span class="line">&#39;C:\\dev\\python\\python36&#39;,</span><br><span class="line">&#39;C:\\dev\\python\\python36\\lib\\site-packages&#39;]</span><br><span class="line">pprint.pprint(sys.path)</span><br></pre></td></tr></table></figure><p><strong>sys.platform</strong><br />表示当前python运行的平台<br />print(sys.platform)</p><p><strong>sys.exit( )</strong><br />函数用来退出<br />sys.exit(‘程序出现异常，结束’)<br />print(‘hello’)</p><p><strong>os  模块</strong>让我们可以对操作系统进行访问<br />import os</p><p><strong>os.environ</strong><br />通过这个属性可以获取到系统的环境变量<br />pprint.pprint(os.environ[‘path’])</p><p><strong>os.system( )</strong><br />可以用来执行操作系统的名字</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--对象（1）</title>
      <link href="2020/07/08/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%AF%B9%E8%B1%A1(1)/"/>
      <url>2020/07/08/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%AF%B9%E8%B1%A1(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="对象object"><a class="markdownIt-Anchor" href="#对象object"></a> 对象（object）</h2><p>什么是对象<br />对象是内存中专门来存储数据的一块区域<br />对象中可以存放各种数据（比如：数字、代码。。。。）<br />对象的三部分：</p><ul><li>对象的标识 （id）</li><li>对象的类型 （type）</li><li>对象的值（value）</li></ul><h2 id="面向对象oop"><a class="markdownIt-Anchor" href="#面向对象oop"></a> 面向对象（oop）</h2><p>python是一门面向对象的编程语言<br />所谓的面向对象的语言，就是语言中所有的操作都是通过对象来进行的<br />面向过程的编程语言<br />面向过程将我们的程序的逻辑分解为一个一个的步骤，通过对每个步骤的抽象，来完成程序<br />例子：<br />孩子上学<br />妈妈起床<br />妈妈洗漱<br />妈妈做早饭<br />妈妈叫孩子起床<br />孩子洗漱<br />孩子吃早饭<br />孩子背书包去上学</p><p>面向过程的编程思想将一个功能分解为一个一个小的步骤，我们通过完成一个一个的小步骤来完成一个程序<br />这种编程方式，符合我们的思维，编写起来相对简单<br />但是这种方式编写代码的往往只适用于一个功能</p><ul><li>如果要实现其他功能，即使功能相差极小，也要重新编写代码</li><li>所有他的可复用性比较低，并且难于维护</li></ul><h3 id="面向对象的编程语言"><a class="markdownIt-Anchor" href="#面向对象的编程语言"></a> 面向对象的编程语言</h3><p>面向对象的编程语言，关注的是对象，而不是关注过程<br />对于面向对象的语言来说，一切都是对象<br />例子：</p><ul><li>孩子他妈起床叫孩子去上学</li></ul><p>面向对象的编程思想，将所有功能统一保存到对应的对象中<br />比如，妈妈功能保存到妈妈这个对象中，孩子的功能保存到孩子这个对象中<br />要是有某个功能，直接找到对应的对象即可<br />这种方式编程的代码，比较容易阅读，并且比较容易维护，容易复用<br />但是这种方式编写，不太符合常规的思维，编写起来稍微麻烦一点</p><p>归纳面向对象的思想</p><ul><li>找到对象</li><li>实现对象功能</li></ul><h2 id="类-class"><a class="markdownIt-Anchor" href="#类-class"></a> 类 （class）</h2><p>目前所学习的对象都是python的内置对象</p><p>但是内置对象不能满足所有需求，所以在开发中经常需要自定义对象<br />类，简单理解他就是一张图纸，在程序中我们需要根据类来创建对象<br />类就是对象的图纸，也称对象为类的实例（instance）</p><p>如果对象是通过一个类创建的，我们成这些对象是一类对象</p><p>例如：int( )  float( )  bool( )  str( )  …这些都是类<br />a = int(10)   #创建了一个int类的实例  等价于 a = 10<br />我们自定义的类都要使用大写字母开头，使用大驼峰命名法（帕斯卡命名法）来对类命名</p><p>类就是一个用来创建对象的对象<br />类是type类型的对象，定义类就是定义了一个type类型的对象</p><p>定义一个简单的类<br />使用class关键字来定义类，语法和函数很像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class  类命([父类]) ：</span><br><span class="line">代码块</span><br><span class="line">&lt;class &#39;__main__.MyClass&#39;&gt;</span><br><span class="line">class MyClass( ) :</span><br><span class="line">pass</span><br><span class="line">print(MyClass)  #&lt;class &#39;__main__.MyClass&#39;&gt;</span><br></pre></td></tr></table></figure><p>使用MyClass创建一个对象<br />使用类来创建对象就像调用一个函数一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mc_2 = MyClass( ) <span class="comment"># mc就是通过MyClass创建的对象，mc是MyClass的实例</span></span><br><span class="line">mc_3 = MyClass( )</span><br><span class="line">mc_4 = MyClass( )</span><br><span class="line"> mc、mc_2、mc_3、</span><br></pre></td></tr></table></figure><p>mc_4 都是MyClass的实例，他们都是一类对象</p><p><strong>isinstance( )</strong> 用来检查一个对象是否是一个类的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isinstance(mc,MyClass)</span><br><span class="line"></span><br><span class="line">result  = isinstance(mc_4,MyClass)</span><br><span class="line">print(<span class="string">&#x27;result=&#x27;</span>,result)</span><br></pre></td></tr></table></figure><h3 id="使用类创建对象的流程"><a class="markdownIt-Anchor" href="#使用类创建对象的流程"></a> 使用类创建对象的流程</h3><p>1.创建一个变量mc<br />2.在内存中创建一个新对象<br />3.将对象的id赋值给变量</p><h3 id="类的定义"><a class="markdownIt-Anchor" href="#类的定义"></a> 类的定义</h3><p>类和对象都是对现实生活中的事物或程序的内容的抽象<br />实际上所有的事物都由两部分构成：<br />1.数据（属性）<br />2.行为（方法）</p><p>在类的代码块中，可以定义变量和代码块<br />变量会成为该类实例的公告属性，所有的该类实例都可以通过“ 对象.属性名”的形式访问<br />函数会成为该类实例的公共方法，所有该类实例都可以通过“ 对象.属性名( ) ” 的形式调用方法</p><p>注意：方法调用时，第一个参数由解析器自动传递，所以定义方法时，至少要定义一个形参</p><p>实例为什么能访问到类中属性和方法<br />※类中定义的属性和方法都是公共的，任何该类都可以访问</p><h3 id="属性和方法查找流程"><a class="markdownIt-Anchor" href="#属性和方法查找流程"></a> 属性和方法查找流程</h3><p>当我们调用一个对象的属性时，解析器会现在当前对象中寻找是否含有该属性</p><ul><li>如果由，则直接返回当前对象的属性值</li><li>如果没有，则取当前对象的类对象中寻找如果有则返回类对象的属性值</li><li>如果还是没有则报错</li></ul><p>类对象和实例对象中都可以报错属性（方法）</p><ul><li>如果这个属性（方法）是所有的实例共享的，则应该将其保存在类对象中</li><li>如果这个属性（方法）是某个实例独有的，则应保存到实例对象中</li></ul><p>一般情况下，属性保存到实例对象中<br />而方法需要保存到类对象中</p><p>尝试定义一个代表人的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> :</span></span><br><span class="line"><span class="comment">#在类的代码块中，我们可以定义变量和函数</span></span><br><span class="line"><span class="comment">#在类中我们所定义的变量，将会成为所有的实例的公共属性</span></span><br><span class="line"><span class="comment">#所有实例都可以访问这些变量</span></span><br><span class="line">name = <span class="string">&#x27;cxk&#x27;</span>  <span class="comment">#公告属性，所有实例都可以访问</span></span><br></pre></td></tr></table></figure><p>在类中也可以定义函数，类中的定义的函数，称为方法<br />这些方法可以通过该类的所有实例来访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">self</span>) :</span></span><br><span class="line"><span class="comment">#方法，欸此被调用时，解析器都会自动传递一个实参</span></span><br><span class="line"><span class="comment">#第一个参数，就是调用方法的对象本身</span></span><br><span class="line"><span class="comment">#如果是P1调用的，则第一个参数就是P1对象</span></span><br><span class="line"><span class="comment">#如果是P2调用的，则第一个参数就是P2对象</span></span><br><span class="line"><span class="comment">#一般我们都会将这个参数命名为self</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#say_hello( )这个方法，可以显示如下格式的数据：</span></span><br><span class="line"><span class="comment">#你好！我是  xxx</span></span><br><span class="line"><span class="comment">#在方法中不能直接方法类中的属性</span></span><br><span class="line">print(<span class="string">&#x27;你好！我是 %s&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure><p>创建Pers的实例<br />p1 = Person( )<br />p2 = Person( )<br />调用方法，对象，方法名( )<br />方法调用和函数调用的区别</p><ul><li>如果是函数调用，则调用时传几个参，就会有几个实参</li><li>如果时方法调用，怎默认传递一个参数，所以方法中至少要定义一个形参</li></ul><p>class Person :<br />#在类中可以定义一些特殊方法（魔术方法）<br />#特殊方法都是以__开头，__结尾的方法（双下划线）<br />#特殊方法不需要我们自己调用，不要尝试调用特殊方法<br />#特殊方法将会在特殊的时刻自动调用</p><pre><code>#学习特殊方法：#1.特殊方法说明时候调用#2.特殊方法有说明作用#创建对象的流程#1.创建一个变量#2.在内存中创建一个新对象#3.__init__方法执行#  4.将对象的id赋值给变量#  init 会在对象创建后立刻执行#initial可以用来向新创建的对象中初始化属性 def __init__(self)print('大家好，我是%s'%self.name)</code></pre><p>目前来讲，对应Person类来说那么是必须的，并且每一个对象中的name属性基本上都是不同的<br />而我们现在是将name属性在定义为对象后，手动添加到对象中，这种方式很容易出现错误<br />我们希望在创建对象时，必须设置name属性，如果不设置对象将无法创建<br />并且属性的创建一个是自动完成的，而不是在创建对象以后手动完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> p1 = Person()</span><br><span class="line"> 手动向对象添加name属性</span><br><span class="line"> p1.name = <span class="string">&#x27;孙悟空&#x27;</span></span><br><span class="line"></span><br><span class="line"> p2 = Person()</span><br><span class="line"> p2.name = <span class="string">&#x27;猪八戒&#x27;</span></span><br><span class="line"></span><br><span class="line"> p3 = Person()</span><br><span class="line"> p3.name = <span class="string">&#x27;沙和尚&#x27;</span></span><br><span class="line"></span><br><span class="line"> p3.say_hello()</span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&#x27;孙悟空&#x27;</span>)</span><br><span class="line">p2 = Person(<span class="string">&#x27;猪八戒&#x27;</span>)</span><br><span class="line">p3 = Person(<span class="string">&#x27;沙和尚&#x27;</span>)</span><br><span class="line">p4 = Person(<span class="string">&#x27;唐僧&#x27;</span>)</span><br><span class="line"> p1.__init__() 不要这么做</span><br><span class="line"></span><br><span class="line"> print(p1.name)</span><br><span class="line"> print(p2.name)</span><br><span class="line"> print(p3.name)</span><br><span class="line"> print(p4.name)</span><br><span class="line"></span><br><span class="line">p4.say_hello()</span><br></pre></td></tr></table></figure><h3 id="类的基本结构"><a class="markdownIt-Anchor" href="#类的基本结构"></a> 类的基本结构</h3><p>class 类名([父类]) :</p><pre><code>     公共的属性...      # 对象的初始化方法     def __init__(self,...):         ...     # 其他的方法         def method_1(self,...):         ...     def method_2(self,...):         ...     ...- 练习：    尝试自定义一个表示狗的类（Dog）              属性：            name            age            gender            height            ...        方法：              jiao()            yao()            run()            ...</code></pre><h2 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h2><p>封装是面向对象的三大特征性之一<br />封装的是隐藏对象中一些不希望被外部所访问到的属性或方法<br />如何隐藏一个对象的属性：</p><ul><li>将对象的属性名，修改为一个外部不知道的名字(hidden_name)</li></ul><p>没有一种绝对的方式能将对象的属性名绝对隐藏<br />如何获取（修改）对象的属性?<br />需要提供一个getter和setter方法使用外部可以访问到属性</p><ul><li>getter获取对象中的指定属性（get_属性名）</li><li>setter用来设置对象的指定属性（set_属性名）</li></ul><p>使用封装，确实增加了类的定义的复杂成都，但是他也确保了数据的安全性</p><p>1.隐藏了属性名，是调用者无法随意修改对象中的属性</p><p>2.增加了getter和setter方法，很好的控制属性是否只读</p><ul><li>如果希望属性是只读的，则可以直接去掉setter方法</li><li>如果希望属性不能被外部访问，则可以直接去掉getter方法</li></ul><p>3.使用setter方法甚至属性，可以增加数据验证，确保数据的值是正确的</p><p>4.使用getter方法获取属性会有一个返回值，setter方法设置属性<br />可以在读取属性和修改属性的同时做一些其他处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   表示狗的类</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>) :</span></span><br><span class="line">self.hidden_name = name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_name</span>(<span class="params">self</span>):</span></span><br><span class="line">print(<span class="string">&#x27;大家好，我是 %s&#x27;</span>%self.hidden_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>) :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  get_name( )用来获取的name属性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">return</span> self.hidden_name</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_name</span>(<span class="params">self,name</span>)</span></span><br><span class="line">self.hidden_name = name</span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">&#x27;旺财&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d.say_hello( )</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用setter来修改那么属性</span></span><br><span class="line">d.set_name(<span class="string">&#x27;小黑&#x27;</span>)</span><br><span class="line">print(d.get_name())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        表示矩形的类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,width,height</span>):</span></span><br><span class="line">        self.hidden_width = width</span><br><span class="line">        self.hidden_height = height</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_width</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.hidden_width</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_height</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.hidden_height   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_width</span>(<span class="params">self , width</span>):</span></span><br><span class="line">        self.hidden_width = width </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_height</span>(<span class="params">self , height</span>):</span></span><br><span class="line">        self.hidden_height = height </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.hidden_width * self.hidden_height        </span><br><span class="line"></span><br><span class="line"> r = Rectangle(<span class="number">5</span>,<span class="number">2</span>)  </span><br><span class="line"> r.set_width(<span class="number">10</span>)</span><br><span class="line"> r.set_height(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"> print(r.get_area())     </span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>可以为对象的属性使用双下划线开头，__xxx<br />双下划线开头的属性，是对象的隐藏属性，隐藏属性只能在类的内部访问，无法通过对象访问<br />其实隐藏属性只不过是Python自动为属性改了一个名字<br />实际上是将名字修改为了，_类名__属性名 比如 __name -&gt; _Person__name</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span>(<span class="params">self , name</span>):</span></span><br><span class="line">        self.__name = name        </span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;孙悟空&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(p.__name) __开头的属性是隐藏属性，无法通过对象访问</span><br><span class="line">p.__name = <span class="string">&#x27;猪八戒&#x27;</span></span><br><span class="line">print(p._Person__name)</span><br><span class="line">p._Person__name = <span class="string">&#x27;猪八戒&#x27;</span></span><br><span class="line"></span><br><span class="line">print(p.get_name())</span><br></pre></td></tr></table></figure><p>使用__开头的属性，实际上依然可以在外部访问，所以这种方式我们一般不用</p><ul><li>一般我们会将一些私有属性（不希望被外部访问的属性）以_开头</li><li>一般情况下，使用_开头的属性都是私有属性，没有特殊需要不要修改私有属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span>(<span class="params">self , name</span>):</span></span><br><span class="line">        self._name = name   </span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;孙悟空&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(p._name)</span><br></pre></td></tr></table></figure><h3 id="property装饰器"><a class="markdownIt-Anchor" href="#property装饰器"></a> property装饰器</h3><p>property装饰器，用来将一个get方法，转换为对象的属性<br />添加为property装饰器以后，我们就可以向调用属性一样使用get方法<br />使用property装饰器的方法，必须和属性名是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> :</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>) :</span></span><br><span class="line">self._name = name</span><br><span class="line">self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self</span>) :</span></span><br><span class="line"><span class="keyword">return</span> self._name</span><br><span class="line">setter方法的装饰器：@属性名.setter</span><br><span class="line"><span class="meta">@name.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">self,name</span>) :</span></span><br><span class="line">self.__name = name </span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self</span>) :</span></span><br><span class="line"><span class="keyword">return</span> self._age</span><br><span class="line"><span class="meta">@age.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">age</span>(<span class="params">self,age</span>):</span></span><br><span class="line">self._age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;caixukun&#x27;</span>,<span class="number">27</span>)</span><br><span class="line">p.name = <span class="string">&#x27;xiaozhan&#x27;</span></span><br><span class="line">p.age = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">print(p.name,p.age)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--函数（2）</title>
      <link href="2020/07/07/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0(2)/"/>
      <url>2020/07/07/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0(2)/</url>
      
        <content type="html"><![CDATA[<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2><p>尝试求10的阶乘（10！）<br />1！= 1<br />2！= 1 * 2<br />3！= 1 * 2 * 3<br />…<br />10！= 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10<br />print( 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 )</p><p>创建一个变量保存结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>) :</span><br><span class="line">n *= i</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p>创建一个函数，来求任意数的阶乘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>) :</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    该函数用来求任意数的阶乘</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">        n 要求阶乘数字</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#创建一个变量来保存结果</span></span><br><span class="line">    result = n</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">        result *= i</span><br><span class="line">    <span class="keyword">return</span> resultn</span><br><span class="line">print(factorial(n))    </span><br><span class="line">print(factorial(<span class="number">3</span>))  <span class="comment">#求3的阶乘</span></span><br></pre></td></tr></table></figure><h3 id="递归式的函数"><a class="markdownIt-Anchor" href="#递归式的函数"></a> 递归式的函数</h3><ul><li>递归简单理解就是自己去引用自己。</li><li>递归式函数，在函数中自己调用自己。</li></ul><p><strong>无穷递归：</strong><br />果这个函数被调用，程序的内存会溢出，效果类似死循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>( ):</span></span><br><span class="line">    fn( )</span><br><span class="line">fn( )</span><br></pre></td></tr></table></figure><p>递归是解决问题的一中方式，它和循环很像。<br />它的整体思想是，将一个大问题分解为一个个小问题，直到问题无法分解时，再去解决问题。</p><h3 id="递归函数的两个要件"><a class="markdownIt-Anchor" href="#递归函数的两个要件"></a> 递归函数的两个要件：</h3><p><strong>1.基线条件</strong><br />问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了。<br /><strong>2.递归条件</strong><br />将问题继续分解的条件。<br />递归和循环类似，基本是可以互相代替的。</p><ul><li>循环编写起来比较容易，阅读起来稍难。</li><li>递归编写起来难，但是方便阅读。<br />10！= 10 * 9！<br />9！= 9 * 8！<br />8！= 8 * 7！<br />。。。<br />1！= 1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>) :</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        该函数用来求任意数的阶乘</span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">        n 要求阶乘数字</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#基线条件，判断n是否为1，如果为1，则此时不能再继续递归</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> :</span><br><span class="line">        <span class="comment">#1的阶乘就是1，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#递归条件</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line">print(factorial(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p><strong>练习：</strong><br />创建一个函数 power 来为任意数字做幂运算 n ** i<br />例：10 ** 5 = 10 * 10 ** 4<br />10 ** 4 = 10 * 10 ** 3<br />…<br />10 ** 1 = 10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power</span>(<span class="params">n,i</span>) :</span></span><br><span class="line"><span class="comment">#基线条件</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="number">1</span> :</span><br><span class="line"><span class="comment">#求1次幂</span></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line"><span class="comment">#递归条件</span></span><br><span class="line"><span class="keyword">return</span> n * power(n,i<span class="number">-1</span>)</span><br><span class="line">print(power(<span class="number">5</span>,<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p><strong>练习</strong><br />创建一个函数，用来检查一个任意的字符串是否是回文字符串，如果是返回True，否则返回False。<br />回文字符串，字符串从前往后念和从后往前念是一样的。<br />例如:<br />检查 abcdefgfedcba 是不是回文<br />检查 bcdefgfedcb 是不是回文<br />检查 cdefgfedc 是不是回文<br />。。。<br />检查 g 是不是回文</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hui_wen</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        该函数用来检查指定的字符串是否回文字符串，如果是返回True，否则返回False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            s：就是要检查的字符串</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 基线条件</span></span><br><span class="line">    <span class="keyword">if</span> len(s) &lt; <span class="number">2</span> :</span><br><span class="line">        <span class="comment"># 字符串的长度小于2，则字符串一定是回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> s[<span class="number">0</span>] != s[<span class="number">-1</span>]:</span><br><span class="line">        <span class="comment"># 第一个字符和最后一个字符不相等，不是回文字符串</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line">    <span class="comment"># 递归条件    </span></span><br><span class="line">    <span class="keyword">return</span> hui_wen(s[<span class="number">1</span>:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h3 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h3><p>在python中，函数是一等对象。<br />一等对象一般都会具有如下特点：<br />①对象是在运行时创建的。<br />②能赋值给变量或作为数据结构中的元素。<br />③能作为参数传递。<br />④能作为返回值返回。<br />高阶函数：<br />①接收一个或多个函数作为参数。<br />②将函数作为返回值返回。</p><h2 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h2><ul><li>接收函数作为参数，或者将函数作为返回值的函数就是高阶函数。</li><li>当我们使用一个函数作为参数时，实际上是将指定的代码传递进了目标函数<br />创建一个列表：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>定义一个函数<br />可以将指定列表中的所有偶数，保存到一个新的列表中返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个函数，用来检查一个数时否是偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">i</span>) :</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>   </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  fn( )函数可以将指定列表中的所有偶数取出来，并保存到一个新的列表中</span></span><br><span class="line"><span class="string">  参数：</span></span><br><span class="line"><span class="string">      lst:要进行筛选的列表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">#这个函数用来检查指定的数字是否大于5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn3</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">5</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">func , lst</span>) :</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        fn()函数可以将指定列表中的所有偶数获取出来，并保存到一个新列表中返回</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        参数：</span></span><br><span class="line"><span class="string">            lst：要进行筛选的列表</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 创建一个新列表</span></span><br><span class="line">    new_list = []</span><br><span class="line">    <span class="comment"># 对列表进行筛选</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> lst :</span><br><span class="line">        <span class="comment"># 判断n的奇偶</span></span><br><span class="line">        <span class="keyword">if</span> func(n) :</span><br><span class="line">            new_list.append(n)</span><br><span class="line">        <span class="comment"># if n &gt; 5 :</span></span><br><span class="line">        <span class="comment">#     new_list.append(n)         </span></span><br><span class="line">    <span class="comment"># 返回新列表</span></span><br><span class="line">    <span class="keyword">return</span> new_list</span><br><span class="line"> <span class="comment">#def fn4(i):</span></span><br><span class="line">     <span class="comment">#if i % 3 == 0:</span></span><br><span class="line">         <span class="comment">#return True    </span></span><br><span class="line">     <span class="comment">#return False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn4</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i % <span class="number">3</span> == <span class="number">0</span>        </span><br><span class="line"> print(fn(fn4 , l))</span><br></pre></td></tr></table></figure><h3 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter( )</h3><p>filter( )可以从序列中过滤出符合条件的元素，保存到一个新的序列中<br />参数：</p><ul><li>函数，根据该函数来过滤序列（可迭代的结构）</li><li>需要过滤的序列（可迭代的结构）<br />返回值：<br />过滤后的新序列（可迭代的结构）</li></ul><p>fn4是作为参数传递进filter( )函数中<br />而fn4实际上只有一个作用，就是作为fn4( )的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = filter(fn4,l)</span><br><span class="line">print(list(r))</span><br></pre></td></tr></table></figure><p>filter( ) 调用完毕后，fn4就已经没有作用</p><h3 id="匿名函数-lambda-函数表达式语法糖"><a class="markdownIt-Anchor" href="#匿名函数-lambda-函数表达式语法糖"></a> 匿名函数 lambda 函数表达式（语法糖）</h3><p>lambda函数表达式专门用来创建一些简单的函数，他是函数创建的又一只种方式<br />语法：lambda  参数列表 ：返回值<br />匿名函数一般都是作为参数使用的，其他这么地方一般不会使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn5</span>(<span class="params">a,b</span>) :</span></span><br><span class="line"><span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="keyword">lambda</span> a,b : a+b   <span class="comment">#和上边fn5等价的可以将匿名函数赋值给一个变量,一般不这么做</span></span><br><span class="line">fn6 = <span class="keyword">lambda</span> a,b : a+b</span><br><span class="line">print(fn6(<span class="number">1</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> map( )</h3><p>map( ) 函数可以对可迭代对象的所有元素做指定操作，<br />然后将其添加到一个新的对象中返回<br />l = [1,2,3,4,5,6,7,8,9,10]<br />r = map(lambda i : I+1,l)  #让l列表的每个元素都加1<br />print(list®)</p><h3 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort( )</h3><p>该方法用来对列表中的元素进行排序<br />sort( )方法默认就是直接比较列表中国的元素的大小<br />在sort( )可以接受一个关键字参数，key<br />key需要一个函数作为参数，当设置了函数作为参数<br />每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素大小<br />l = [‘aa’,‘ccccccc’,‘ddd’,‘bb’]<br />l.sort( )</p><p>l = [2,3,‘5’,‘1’,4]<br />l.sort(key=int) #先类型转换才能排序<br />print(l)</p><h3 id="sorted"><a class="markdownIt-Anchor" href="#sorted"></a> sorted( )</h3><p>这个函数和sort( )的用法基本一致，但是sorted( )可以对任意的序列进行排序<br />并且使用sorted( )排序不会影响原来的对象，而是返回一个新对象<br />l = [2,3,‘5’,‘1’,4]<br />print(‘排序前：’,l)<br />print(sorted(l,key=int))<br />print('排序后：'l)</p><p>将函数作为返回值返回，也是一种高阶函数<br />这中高阶函数也称为闭包，通过创建一些只有当前函数能访问的变量<br />可以讲一些私有的数据藏到闭包中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>( ) :</span></span><br><span class="line"><span class="comment">#函数内部再定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>():</span></span><br><span class="line">print(<span class="string">&#x27;我是fn2&#x27;</span>)</span><br><span class="line"><span class="comment">#将内部函数 inner作为返回值返回</span></span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line">r= fn( )</span><br><span class="line">r( )</span><br></pre></td></tr></table></figure><p>r是一个函数，是调用fn( )后返回的函数<br />这个函数是在fn( )内部定义，并不是全局函数<br />所以这个函数总是能访问到fn( )函数内的变量</p><p>求多个数的平均值<br />nums = [10,20,30,40]</p><h3 id="sun"><a class="markdownIt-Anchor" href="#sun"></a> sun( )</h3><p>用来求一个列表中所有数的和<br />print(sum(nums)/len(nums))</p><p>形成闭包的条件：</p><ul><li>函数嵌套</li><li>将内部函数作为返回值返回</li><li>内部函数必须要使用外部函数的变量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span>( ) :</span></span><br><span class="line"><span class="comment">#创建一个列表，用来保存数值</span></span><br><span class="line">nums = [ ]</span><br><span class="line"><span class="comment">#创建一个函数，用来计算平均值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>(<span class="params">n</span>) :</span></span><br><span class="line"><span class="comment">#将n添加到列表中</span></span><br><span class="line">nums.append(n)</span><br><span class="line"><span class="comment">#求平均值</span></span><br><span class="line"><span class="keyword">return</span> sum(nums)/len(nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> averager</span><br><span class="line">print(averager(<span class="number">15</span>))</span><br><span class="line">print(averager(<span class="number">20</span>))</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2><p>创建几个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a,b</span>) :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  求任意两个数的和</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">r = a+b</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">a*b</span>) :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  求任意两个数的积</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">r = a*b</span><br><span class="line"><span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>希望函数可以再计算前，打印“开始计算”，计算完成后打印“计算完毕”<br />可以通过直接修改函数的代码完成这个需求，但是产生一些问题<br />①如果修改的函数过多，修改起来麻烦<br />②不方便后期维护<br />③并且这样会违反开闭原则（OCP）<br />程序的设计，要求对开发程序的扩展，要关闭对程序的修改</p><p>我们希望再不修改原函数的基础下，来对函数进项扩展</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>( ) :</span></span><br><span class="line">print(<span class="string">&#x27;我是fn函数。。。。&#x27;</span>)</span><br><span class="line"><span class="comment">#只需要根据现有函数，来创建一个新的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>( ) :</span></span><br><span class="line">print(<span class="string">&#x27;函数开始执行~~&#x27;</span>)</span><br><span class="line">fn( )</span><br><span class="line">print(<span class="string">&#x27;函数执行结束~~&#x27;</span>)</span><br><span class="line"><span class="comment">#fn2( )</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_add</span>(<span class="params">a,b</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;计算开始~~&#x27;</span>)</span><br><span class="line">r = add(a,b)</span><br><span class="line">print(<span class="string">&#x27;计算结束~~&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line"> r = new_add(<span class="number">111</span>,<span class="number">222</span>)</span><br><span class="line"> print(r)</span><br></pre></td></tr></table></figure><p>上边的方式，已经可以在不修改源代码的情况下对函数进行扩展了<br />但是，这种方式要求我们每扩展一个函数就啊哟手动创建一个新的函数，实在麻烦</p><p>为了解决这个问题，我们要创建一个可以自动帮我们创建函数的函数，一般不这么用，这里只做理解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">begin_end</span>( ) :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，结束后打印执行结束 </span></span><br><span class="line"><span class="string">   参数：old  要扩展的函数对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">创建一个新函数</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">new_function</span>(<span class="params">*args,**kwargs</span>):</span>  <span class="comment">#*args,**kwargs  把参数装包成元组或字典</span></span><br><span class="line">    print(<span class="string">&#x27;开始执行~~~&#x27;</span>)</span><br><span class="line">old(*args,**kwargs)   <span class="comment">#调用被扩展的函数，*args,**kwargs  把元组拆包成位置参数，把字典拆包成关键字参数传进去</span></span><br><span class="line">print(<span class="string">&#x27;执行结束~~~&#x27;</span>)</span><br><span class="line"><span class="comment">#返回函数的执行结果</span></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">返回新函数</span><br><span class="line"><span class="keyword">return</span> new_function</span><br><span class="line">f = begin_end(fn)</span><br><span class="line">f2 = begin_end(add)</span><br><span class="line">r = f2(<span class="number">234</span>,<span class="number">345</span>)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>像begin_end( )  这种函数我们就称他为装饰器<br />通过装饰器，可以在不修改原函数的情况下来对函数进行扩展<br />在开发中，都是通过装饰器来扩展函数的功能的<br />在定义函数时，可以通过@装饰器来使用指定的装饰器，来装饰当前函数<br />可以同时为一个函数指定多个装饰器，这样函数将会安装从内向外的顺序被装饰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">begin_end</span>( ) :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，结束后打印执行结束</span></span><br><span class="line"><span class="string">   参数：old  要扩展的函数对象</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#创建一个新函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_function</span>(<span class="params">*args,**kwargs</span>):</span>  <span class="comment">#*args,**kwargs  把参数装包成元组或字典</span></span><br><span class="line">print(<span class="string">&#x27;fn3开始装饰，开始执行~~~&#x27;</span>)</span><br><span class="line">old(*args,**kwargs)   <span class="comment">#调用被扩展的函数，*args,**kwargs  把元组拆包成位置参数，把字典拆包成关键字参数传进去</span></span><br><span class="line">print(<span class="string">&#x27;fn3装饰，执行结束~~~&#x27;</span>)</span><br><span class="line"><span class="comment">#返回函数的执行结果</span></span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">返回新函数</span><br><span class="line"><span class="keyword">return</span> new_function</span><br><span class="line"><span class="meta">@fn3</span></span><br><span class="line"><span class="meta">@begin_end   #先于 @fn3这个装饰器装饰  从内向外装饰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>( ) :</span></span><br><span class="line">print(<span class="string">&#x27;大家好~~&#x27;</span>)</span><br><span class="line">say_hello( )</span><br></pre></td></tr></table></figure><p>#多理解概念   多理解概念    多理解概念</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--函数（1）</title>
      <link href="2020/07/06/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0(1)/"/>
      <url>2020/07/06/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><h2 id="函数简介"><a class="markdownIt-Anchor" href="#函数简介"></a> 函数简介</h2><ul><li>函数也是一个对象。</li><li>对象是内存中专门用来存储数据的一块区域。</li><li>函数可以用来保存一些可执行的代码，并且可以在需要时进行多次调用。</li><li>函数名必须要符号标识符的规范（可以包含字母、数字、下划线、但是不能以数字开头）。</li><li>定义函数一般都是要实现某种功能的。<br />创建函数：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">[形参<span class="number">1</span>，形参<span class="number">2</span>，.......形参n]</span>)</span></span><br><span class="line"><span class="function">代码块</span></span><br><span class="line"><span class="function">```</span></span><br><span class="line"><span class="function">函数中保存的代码不会立即执行，需要调用函数代码才会执行 ：</span></span><br><span class="line"><span class="function">```<span class="title">python</span></span></span><br><span class="line"><span class="function">调用函数：</span></span><br><span class="line"><span class="function">函数对象( )</span></span><br></pre></td></tr></table></figure><p>定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>( ) :</span></span><br><span class="line">print(<span class="string">&#x27;这是一个函数&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;这是两个函数&#x27;</span>)</span><br><span class="line">fn( )</span><br></pre></td></tr></table></figure><p>打印fn ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(fn)&lt;function fn at <span class="number">0x03D2B618</span>&gt;</span><br><span class="line">print(type(fn))  <span class="comment">#&lt;class&#x27;function&gt;</span></span><br></pre></td></tr></table></figure><p><strong>fn</strong> 是函数对象 <strong>fn( )</strong> 调用函数。<br /><strong>print</strong>是函数对象 <strong>print( )</strong> 调用函数。</p><h2 id="函数的参数"><a class="markdownIt-Anchor" href="#函数的参数"></a> 函数的参数</h2><p>在定义函数时，可以在函数名后的 ( )中定义数量不等的形参，多个形参之间使用逗号隔开。</p><ul><li>形参（形式参数），定义形参就相当于在函数内部声明了变量，但是并不赋值。</li><li>实参（实际参数），如果函数定义时，指定了形参，那么在调用函数时也必须传递实参。</li><li>实参将会赋值给对应的形参，简单来说，有几个形参就要传递几个实参</li></ul><p>定义一个函数，可以用来求任意两个数的和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>( ) :</span></span><br><span class="line"> a = <span class="number">123</span></span><br><span class="line"> b = <span class="number">456</span></span><br><span class="line"> print(a+b)</span><br><span class="line">sum( )</span><br></pre></td></tr></table></figure><p>定义函数时指定形参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">a,b</span>):</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(a,<span class="string">&#x27;+&#x27;</span>,b,<span class="string">&#x27;=&#x27;</span>,a+b)</span><br><span class="line"><span class="comment">#调用函数时，来传递实参</span></span><br><span class="line">fn2(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fn2(<span class="number">123</span>,<span class="number">345</span>)</span><br></pre></td></tr></table></figure><p><strong>练习1:</strong><br />定义一个函数，可以用来求任意三个数的乘积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">a,b,c</span>) :</span></span><br><span class="line">print(a*b*c)</span><br><span class="line">mul(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><strong>练习2：</strong><br />定义一个函数，可以根据不同的用户名显示不同的欢迎信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">welcome</span>(<span class="params">username</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;欢迎&#x27;</span>，username,<span class="string">&#x27;光临&#x27;</span>)</span><br><span class="line"></span><br><span class="line">welcome(<span class="string">&#x27;菜寻鲲&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数时指定形参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;欢迎鸡侠&#x27;</span>,a)</span><br><span class="line">    print(<span class="string">&#x27;赶紧糊吧！&#x27;</span>,b)</span><br><span class="line"><span class="comment">#调用函数时，来传递实参</span></span><br><span class="line">fn2(<span class="string">&#x27;菜寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>)</span><br></pre></td></tr></table></figure><p>定义一个函数<br />定义形参时，可以为形参指定默认值<br />指定了默认值以后，如果用户传递了参数则默认值没有任何作用<br />如果用户没有传递，则默认值就回生效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def fn(a,b,c=20) ; </span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment">#c=20无效</span></span><br><span class="line">fn(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">#c=20生效</span></span><br></pre></td></tr></table></figure><h2 id="实参的传递方式"><a class="markdownIt-Anchor" href="#实参的传递方式"></a> 实参的传递方式</h2><p><strong>位置参数：</strong><br />位置参数就是将对应位置的实参赋值给对应位置的形参。<br />第一个实参赋值给第一个形参，第二个实参赋值给第二个形参。。。<br />fn(1,2,3)</p><p><strong>关键字参数：</strong><br />关键字参数，可以不按照形参定义的顺序去传递，而直接根据参数名去传递参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fn(b=<span class="number">1</span>,c=<span class="number">2</span>,a=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span>,end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure><p>位置参数和关键字参数可以混合使用。<br />混合使用关键字和位置参数时，必须将位置参数写到前面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn(<span class="number">1</span>,c=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>函数在调用时，解析器不会检查实参的类型<br />实参可以传递任意类型的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">a</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">b=<span class="number">123</span></span><br><span class="line">b=<span class="literal">True</span></span><br><span class="line">b=<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">b=<span class="literal">None</span></span><br><span class="line">b=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">fn2(b)</span><br><span class="line"></span><br><span class="line">fn2(fn)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn3</span>(<span class="params">a,b</span>):</span></span><br><span class="line">print(a+b)</span><br><span class="line">fn3(<span class="number">123</span>+<span class="string">&#x27;456&#x27;</span>)   <span class="comment">#报错</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn4</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="comment">#在函数中对形参进行重新赋值，不会影响其他变量</span></span><br><span class="line"><span class="comment">#a=20</span></span><br><span class="line"><span class="comment">#a是一个列表，尝试修改列表中的元素</span></span><br><span class="line"><span class="comment">#如果形参执行的是一个对象，当我们通过形参去修改对象时</span></span><br><span class="line"><span class="comment">#   会影响到所有指向该对象的变量</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">30</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a,id(a))</span><br><span class="line">c=<span class="number">10</span></span><br><span class="line">c=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">fn4(c)  <span class="comment">#此时a和c指向的是同一个对象</span></span><br><span class="line">fn4(c.copy())  <span class="comment">#当希望a和c是相互独立的时，获取一个c的副本</span></span><br><span class="line">fn4(c[:])   <span class="comment">#切片c的副本</span></span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c,id(c)) </span><br></pre></td></tr></table></figure><h2 id="不定长参数"><a class="markdownIt-Anchor" href="#不定长参数"></a> 不定长参数</h2><p>定义一个函数，可以求任意个数字的和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">*a</span>):</span></span><br><span class="line"><span class="comment">#定义一个变量，来保存结果</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="comment">#遍历元组，并将元组中的数进行累加</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> nums :</span><br><span class="line">result += n</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line">sum(<span class="number">123</span>,<span class="number">345</span>)</span><br></pre></td></tr></table></figure><p>在定义函数时，可以在形参前边加上一个*，这样这个形参将会获取到所有的实参，<br />它会将所有的实参保存到一个元组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,*c = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>*<strong>a</strong>会接受所有的位置参数，并且会将这些实参统一保存到一个元组中（装包）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">*a</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a,type(a))</span><br><span class="line"> fn(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>带星号的形参只能有一个，<br />带星号的参数，可以和其他参数配合使用。<br />第一个参数给a,第二个给b，剩下的全都保存到c的元组中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">a,b,*c</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br></pre></td></tr></table></figure><p>可变参数不是必须写在最后，但是注意，带*的参数后的所有参数，必须以关键字参数的形式传递。<br />第一个参数给a，剩下的参数给b，c必须使用关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">a,*b,c</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">fn2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,c=<span class="number">5</span>)   <span class="comment">#必须给关键字参数c=5才不报错</span></span><br></pre></td></tr></table></figure><p>所有的位置参数都给a，b和c必须使用关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">*a,b,c</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">fn2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果在形参的开头直接写一个*，则要求我们的所有的参数必须以关键字参数从形式传递。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>(<span class="params">*, a, b, c</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">fn2(<span class="number">1</span>,<span class="number">2</span>,a=<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><ul><li>形参只能接受位置参数，而不能接受关键字参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn3</span>(<span class="params">*a</span>) :</span></span><br><span class="line">    print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">fn3(b=<span class="number">1</span>,d=<span class="number">2</span>,c=<span class="number">3</span>)   <span class="comment">#bdc都是关键字参数</span></span><br></pre></td></tr></table></figure><p>形参可以接收其他形式的关键字，它会将这些参数统一保存到一个字典中。<br />字典的key就是参数的名字，字典的valu就是参数的值。<br />** 形参只能有一个，并且必须写在所有参数的最后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn3</span>(<span class="params">**a</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a,type(a))</span><br><span class="line">fn3(b=<span class="number">1</span>,d=<span class="number">2</span>,c=<span class="number">3</span>,e=<span class="number">10</span>,f=<span class="number">11</span>)</span><br></pre></td></tr></table></figure><h2 id="参数的解包拆包"><a class="markdownIt-Anchor" href="#参数的解包拆包"></a> 参数的解包（拆包）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn4</span>(<span class="params"> a, b, c</span>) :</span></span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line"><span class="comment">#创建一个元组</span></span><br><span class="line">t = (<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>)</span><br><span class="line"><span class="comment">#传递实参时，也可以在序列类型的参数前添加星号 * ，这样他会自动将序列中的元素依次作为参数传递。</span></span><br><span class="line">这里要求序列中的元素个数必须和形参的个数一致。</span><br><span class="line">fn4(*t)</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个字典</span></span><br><span class="line">d = (<span class="string">&#x27;a&#x27;</span>:<span class="number">100</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">200</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">300</span>)</span><br><span class="line"><span class="comment">#通过 **  来对一个字典进行解包</span></span><br><span class="line">fn4(**d)</span><br></pre></td></tr></table></figure><h2 id="返回值返回值就是函数执行以后返回的结果"><a class="markdownIt-Anchor" href="#返回值返回值就是函数执行以后返回的结果"></a> 返回值（返回值就是函数执行以后返回的结果)</h2><p>可以通过 return 来指定函数的返回值。<br />可以直接使用函数的返回值，也可以通过一个变量来接收函数的返回值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">*nums</span>):</span></span><br><span class="line"><span class="comment">#定义一个变量，来保存结果</span></span><br><span class="line"><span class="comment"># result = 0</span></span><br><span class="line"><span class="comment">#遍历元组，并将元组中的数进行累加</span></span><br><span class="line"><span class="comment"># for n in nums :</span></span><br><span class="line"><span class="comment"># result += n</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line">sum(<span class="number">123</span>,<span class="number">345</span>)</span><br></pre></td></tr></table></figure><p>return后边跟什么值，函数就回返回什么值。<br />return 后边可以跟任意值的对象，返回值甚至可以是一个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>( ):</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">return</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">return</span>&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>() :</span></span><br><span class="line">print(<span class="string">&#x27;菜寻鲲&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span> fn2  <span class="comment">#返回值也可以是一个函数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = fn( )<span class="comment">#这个函数的执行结果就是他的返回值</span></span><br><span class="line"> result( )</span><br><span class="line"> print(result)</span><br></pre></td></tr></table></figure><p>如果 仅仅写一个return 或者不写return ，相当于return None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn2</span>( ) :</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">r = fn2</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>在函数中，return后的代码都不执行，return 一旦执行函数自动结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn3</span>( ) :</span></span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">print(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">r = fn3()</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn4</span>( ) :</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>) :</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">3</span> :</span><br><span class="line">            <span class="keyword">break</span>    <span class="comment">#用来退出当前循环</span></span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment">#跳过当次循环</span></span><br><span class="line">            <span class="keyword">return</span>  <span class="comment">#return  用来结束函数，下边的全不执行</span></span><br><span class="line">        print(i)</span><br><span class="line">    print(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">fn4( )</span><br></pre></td></tr></table></figure><p><strong>fn5 和 fn5( )的区别</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn5</span>( ):</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">print(fn5)  <span class="comment">#fn5是函数对象，打印fn5实际是在打印函数对象  &lt;function fn5 at 0x05771BB8&gt;</span></span><br><span class="line">print(fn5( )) <span class="comment">#fn5是在调用函数，打印fn5( )实际上是在打印fn5( )函数的返回值 10</span></span><br></pre></td></tr></table></figure><p><strong>help( )</strong> 是python中的内置函数<br />通过help( ) 函数可以查询python中函数的用法。<br />语法 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">help(函数对象)</span><br><span class="line">help(<span class="keyword">print</span>)  <span class="comment">#获取print( )函数的使用说明</span></span><br></pre></td></tr></table></figure><h2 id="文档字符串dos-str"><a class="markdownIt-Anchor" href="#文档字符串dos-str"></a> 文档字符串（dos str）</h2><p>在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明。<br />当我们编写了文档字符串时，就可以通过help( )函数来查看函数的说明。<br />文档字符串非常简单，其实直接在函数的第一行写一个字符串就是文档字符串。<br />在编辑多行文档字符串时要用三重引号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>(<span class="params">a,b,c</span>) :</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是一个文档字符串的示例</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">help(fn)</span><br></pre></td></tr></table></figure><h2 id="作用域与命名空间"><a class="markdownIt-Anchor" href="#作用域与命名空间"></a> 作用域与命名空间</h2><h3 id="作用域scope"><a class="markdownIt-Anchor" href="#作用域scope"></a> 作用域(scope)</h3><p><strong>作用域指的是变量生效的区域。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">20</span>   <span class="comment">#全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span>( ) :</span></span><br><span class="line">a=<span class="number">10</span>  <span class="comment"># a 定义在了函数内部，所有他的作用域就是函数内部，函数外部无法访问</span></span><br><span class="line">print(<span class="string">&#x27;函数内部：&#x27;</span>,<span class="string">&#x27;a =&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;函数内部：&#x27;</span>,<span class="string">&#x27;b =&#x27;</span>,b)</span><br><span class="line"></span><br><span class="line">fn( )</span><br><span class="line">print(<span class="string">&#x27;函数外部：&#x27;</span>,<span class="string">&#x27;a =&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;函数外部：&#x27;</span>,<span class="string">&#x27;b =&#x27;</span>,b)</span><br></pre></td></tr></table></figure><h3 id="python中的两种作用域"><a class="markdownIt-Anchor" href="#python中的两种作用域"></a> python中的两种作用域</h3><p><strong>全局作用域：</strong></p><ul><li>全局作用域在程序执行时创建，在程序执行结束时销毁。</li><li>所有函数以外的区域都是全局作用域。</li><li>在全局作用域中定义的变量，都属于全局变量，全局变量可以在程序的任意位置被访问。</li></ul><p><strong>函数作用域：</strong></p><ul><li>函数作用域在函数调用时创建，在调用结束时销毁。</li><li>函数每调用异常就回产生一个新的函数作用域。</li><li>在函数作用域中定义，都是局部变量，只能在函数内部被访问。</li></ul><h3 id="变量的查找"><a class="markdownIt-Anchor" href="#变量的查找"></a> 变量的查找</h3><p>当我们使用变量时，会优先在当前作用域中寻找该变量，如果有则使用，</p><ul><li>如果没有则继续去上一个一级作用域中寻找，如果有则使用；</li><li>如果依然没有再去上一级作用域寻找，以此类推；<br />直到找到全局作用域依然没有找到，则抛出异常。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">20</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn3</span>( ) :</span></span><br><span class="line"><span class="comment">#a=10  在函数中为变量赋值时，默认都是为局部变量赋值</span></span><br><span class="line"><span class="comment">#如果希望在函数内部修改全局变量，则需要使用global关键字，来声明变量</span></span><br><span class="line"><span class="keyword">global</span> a  <span class="comment">#声明在函数内部使用a是全局变量，此时再去修改a，就是在修改全局的a</span></span><br><span class="line">a = <span class="number">10</span>  <span class="comment">#修改全局变量</span></span><br><span class="line">print(<span class="string">&#x27;函数内部：&#x27;</span>,<span class="string">&#x27;a =&#x27;</span>,a)</span><br><span class="line">fn3( )</span><br><span class="line">print(<span class="string">&#x27;函数外部：&#x27;</span>,<span class="string">&#x27;a =&#x27;</span>,a)</span><br></pre></td></tr></table></figure><h3 id="命名空间namespace"><a class="markdownIt-Anchor" href="#命名空间namespace"></a> 命名空间（namespace）</h3><ul><li>命名空间指的是变量存储的位置，每一个变量都需要存储到指定的命名空间中。</li><li>每一个作用域都会有一个他对应的命名空间。</li><li>全局命名空间，用来保存全局变量。函数命名空间用来保存函数中的变量。</li><li>命名空间实际上就是一个字典，是一个专门用来存储变量的字典。</li></ul><p><strong>locals( )</strong> 用来获取当前最重要的命名空间<br />如果在全局作用域中调用locals( )则获取全局命名空间，如果在函数作用域中调用locals( )则获取函数命名空间。<br />返回的是一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scope = locals( )  <span class="comment">#当前命名空间</span></span><br><span class="line">print(type(scope)) </span><br><span class="line">print(a)</span><br><span class="line"><span class="keyword">print</span>（scope[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">向scope中添加一个key-value</span><br><span class="line">scope[<span class="string">&#x27;c&#x27;</span>] = <span class="number">1000</span>   <span class="comment">#向字典中添加key-value就相当于在全局中创建了一个变量（一般不建议这么做）</span></span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn4</span>( ) :</span></span><br><span class="line">scope = locals( ) <span class="comment">#在函数内部调用locals( )会获取到函数的命名空间</span></span><br><span class="line">scope[<span class="string">&#x27;b&#x27;</span>] = <span class="number">20</span> <span class="comment">#可以通过scope来操作函数的命名空间，但是也不建议这么做</span></span><br><span class="line"><span class="comment">#globals( ) 函数可以用来在任意位置获取全局命名空间</span></span><br><span class="line">global_scope = globals( )</span><br><span class="line">print(b)</span><br><span class="line">print(scope)</span><br><span class="line">fn4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--序列（2）</title>
      <link href="2020/07/05/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BA%8F%E5%88%97%EF%BC%882%EF%BC%89/"/>
      <url>2020/07/05/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BA%8F%E5%88%97%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="元组-tuple"><a class="markdownIt-Anchor" href="#元组-tuple"></a> 元组 (tuple)</h2><h3 id="元组简介"><a class="markdownIt-Anchor" href="#元组简介"></a> 元组简介</h3><p>元组是一个不可变的序列<br />它的操作的方式基本上和序列一致<br />所以你在操作元组时，就把元组当成一个不可变的列表就行了<br />一般当我们希望数据不改变时，就使用元组，其余情况都是用列表</p><h3 id="创建元组"><a class="markdownIt-Anchor" href="#创建元组"></a> 创建元组</h3><p>使用()来创建元组，不会用的太多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = ( )</span><br><span class="line">print(my_tuple,type(my_tuple))    <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line">my_tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)  <span class="comment">#创建了一个5个元素的元组</span></span><br></pre></td></tr></table></figure><p>元组是不可变对象，不能尝试为元组中的元素重新赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_tuple[<span class="number">3</span>] = <span class="number">10</span>   <span class="comment">#抛出报错</span></span><br></pre></td></tr></table></figure><p>当元组不是空元组时，括号可以省略<br />如果元组不是空元组，它里边至少要有一个逗号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">my_tuple = <span class="number">9</span>，</span><br></pre></td></tr></table></figure><h2 id="元组解包解构"><a class="markdownIt-Anchor" href="#元组解包解构"></a> 元组解包（解构）</h2><p>元组解包就是指将元组中的每一个元素都赋值给一个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">a,b,c,d = my_tuple</span><br><span class="line">print(<span class="string">&#x27;a=&#x27;</span>,a)</span><br><span class="line">print(<span class="string">&#x27;b=&#x27;</span>,b)</span><br><span class="line">print(<span class="string">&#x27;c=&#x27;</span>,c)</span><br><span class="line">print(<span class="string">&#x27;d=&#x27;</span>,d)</span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">print(a , b)</span><br><span class="line">a , b = b , a   <span class="comment">#交互a和b的值，这就是我们可以利用元组解包</span></span><br><span class="line">print(a , b)</span><br></pre></td></tr></table></figure><p>在对一个元组解包时，变量的数量必须和元组中的元素数量一致<br />也可以在变量前边添加一个 *  ，这样变量将会会获得元组中所有剩余的元素<br />不能出现两个或者以上含有的 * 变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">a , b = my_tuple   <span class="comment">#报错</span></span><br><span class="line">a , b , *c = my_tuple</span><br><span class="line">a , *b , c = my_tuple</span><br><span class="line">*a , b , c = my_tuple</span><br><span class="line">a , b , c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">a , b , c = <span class="string">&quot;mytuple&quot;</span></span><br><span class="line">print(<span class="string">&#x27;a =&#x27;</span>, a)</span><br><span class="line">print(<span class="string">&#x27;b =&#x27;</span>, b)</span><br><span class="line">print(<span class="string">&#x27;c =&#x27;</span>, c)</span><br></pre></td></tr></table></figure><h2 id="可变对象"><a class="markdownIt-Anchor" href="#可变对象"></a> 可变对象</h2><p>每个对象中都保存了三个数据：<br />id(标识)<br />type(类型)<br />value(值)</p><p>列表就是一个可变对象<br />a = [1,2,3]<br />a[0] = 10  ( 改对象)<br />这个操作是在通过变量去修改对象的值，不会改变变量所指向的对象 （只改变了id）<br />当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现</p><p>a = [4,5,6]  (改变量)<br />这个操作是在给变量重新赋值，会改变变量所指向的对象（对象的值和变量都改变了）<br />为一个变量重新赋值，不会影响其他的变量<br />一般只有在为变量赋值时才是修改变量，其余的都是修改对象</p><p><strong>&quot; == &quot;</strong>   <strong>&quot; != &quot;</strong>  和   <strong>&quot; is &quot;    &quot; is not</strong> &quot;<br /><strong>&quot; == &quot;</strong> 和 <strong>&quot; != &quot;</strong>  比较的是对象的值是否相等<br />&quot; is &quot; 和 &quot; is not &quot;   比较的是对象的id是否相等（比较两个对象是否是同一个对象）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(a,b)</span><br><span class="line">print(id(a),id(b))</span><br><span class="line">print(a == b)  <span class="comment">#a和b的值相等，使用==会返回True</span></span><br><span class="line">print(a <span class="keyword">is</span> b)    <span class="comment">#a和b不是同一个对象，内存地址不同，使用is会返回False</span></span><br></pre></td></tr></table></figure><h2 id="字典-dict"><a class="markdownIt-Anchor" href="#字典-dict"></a> 字典 （dict）</h2><h3 id="字典简介"><a class="markdownIt-Anchor" href="#字典简介"></a> 字典简介</h3><p>字典属于一种新的数据结构，称为映射 （mapping）<br />字典的作用和列表类似，都是用来存储对象的容器<br />列表的存储数据的性能很好，但是查询数据的性能很差<br />在字典中每一个元素都有一个唯一的名字，通过这个唯一的名字可以快速的查询到指定元素<br />在查询元素时，字典的效率是非常快的<br />在字典中可以保存多个对象，每个对象都会有一个唯一的名字<br />这个唯一的名字，我们称其为键（key），通过key可以快速查询value<br />这个对象，我们称其为值（value）<br />所以字典，我们也称其为键值对（key-value）结构<br />每个字典中都可以有多个键值对，而每个键值对我们称其为一项（item）</p><p>使用{ } 来创建字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; &#125;  <span class="comment">#创建一个空字典</span></span><br></pre></td></tr></table></figure><p>创建一个保护有数据的字典<br />语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;key:value,key:value,key:value&#125;</span><br></pre></td></tr></table></figure><p>字典的值可以是任意对象<br />字典的键（key）可以是任意的不可变对象 （int、str、bool、tuple。。。。）但是一般都会使用str</p><p>字典的键是不能重复的，如果出现重复的，后边的会先替换掉前边的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;菜寻鲲&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">38</span>,<span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;女&#x27;</span>&#125;</span><br><span class="line">可以多行编写</span><br><span class="line"> d = &#123;</span><br><span class="line"> <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;菜寻鲲&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;age&#x27;</span>:<span class="number">38</span>,</span><br><span class="line"> <span class="string">&#x27;gender&#x27;</span>:<span class="string">&#x27;女&#x27;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">需要根据键来获取值</span><br><span class="line">print(d[<span class="string">&#x27;name&#x27;</span>],d[<span class="string">&#x27;age&#x27;</span>],d[<span class="string">&#x27;gender&#x27;</span>])   <span class="comment">#如果使用了字典中不存在的键会报错</span></span><br></pre></td></tr></table></figure><h2 id="字典的使用"><a class="markdownIt-Anchor" href="#字典的使用"></a> 字典的使用</h2><h3 id="创建字典"><a class="markdownIt-Anchor" href="#创建字典"></a> 创建字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法 ：&#123;k1:v1,k2:v2,k3:v3&#125;</span><br></pre></td></tr></table></figure><p>使用 dict( )函数来创建字典<br />每一个参数都是一个键值对，参数名就是键，参数名就是值（这种方法创建字典，key都是字符串）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = dict(name=<span class="string">&#x27;菜寻鲲&#x27;</span>,age=<span class="number">38</span>,gender=<span class="string">&#x27;男&#x27;</span>)</span><br><span class="line">print(d,type(d))</span><br></pre></td></tr></table></figure><p>也可以将一个包含有双值子序列的序列转换为字典<br />双值序列，序列中包含只有两个值,例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>,<span class="number">3</span>)</span><br><span class="line"><span class="string">&#x27;ab&#x27;</span></span><br></pre></td></tr></table></figure><p>子序列，如果序列中元素也是序列，那么我们就称为这个元素为子序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>)]</span><br><span class="line">d = dict([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;菜寻鲲&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>)])</span><br><span class="line">print(d , type(d))</span><br></pre></td></tr></table></figure><p><strong>len( )</strong><br />获取字典中键值对的个数<br />print(len(d))</p><p><strong>&quot; in &quot;</strong> 检查字典中是否包含指定键<br /><strong>&quot; not in &quot;</strong> 检查字典中是否不包含指定键<br />print(‘hello’ in d)</p><p>获取字典中的值，根据键拉获取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法 ：d[key]</span><br><span class="line">print(d[<span class="string">&#x27;age&#x27;</span>])  </span><br></pre></td></tr></table></figure><p>通过[ ]来获取值时。如果键不存在，会抛出报错<br />get(key[,default])  该方法用来根据键来获取字典中的值<br />如果获取的键在字典中不存在，会返回None<br />也可以指定一个默认值，来作为第二个参数，这样获取不到值时将会返回默认值<br />print(d.get(‘name’))</p><h3 id="修改字典"><a class="markdownIt-Anchor" href="#修改字典"></a> 修改字典：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[key] = value    如果key存在则覆盖，不存在则添加</span><br><span class="line">d[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;caixunkun&#x27;</span>   <span class="comment">#修改字典的key-value</span></span><br><span class="line">d[<span class="string">&#x27;age&#x27;</span>] = <span class="string">&#x27;39&#x27;</span>   <span class="comment">#向字典中添加key-value</span></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><strong>setdefault(key[,default])</strong><br />可以用来向字典中添加key-value<br />如果key已经存在于字典中，则返回key值，不会对字典做任何操作<br />如果key不存在，则向字典中添加这个key，并设置value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = dict(name=<span class="string">&#x27;菜寻鲲&#x27;</span>,age=<span class="number">38</span>,gender=<span class="string">&#x27;男&#x27;</span></span><br><span class="line">result = d.setdefault(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;菜寻鲲&#x27;</span>)</span><br><span class="line">result = d.setdefault(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;菜寻鲲&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;result =&#x27;</span>,result)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><strong>update([other])</strong><br />将其他的字典中的key-value添加到当前字典中<br />如果有重复的key，则后边的会替换的当前的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span> : <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span> : <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span> : <span class="number">3</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">&#x27;d&#x27;</span> : <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span> : <span class="number">5</span>, <span class="string">&#x27;f&#x27;</span> : <span class="number">6</span>, <span class="string">&#x27;a&#x27;</span> : <span class="number">7</span>&#125;<span class="number">0</span></span><br><span class="line">d.update(d2)     <span class="comment">#将两个字典合并或者说把d2字典更新</span></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>删除，可以使用 del 来删除字典中的 key-value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p><strong>popitem( )</strong><br />随机删除字典中的一个键值对，一般都会删除最后一个键值对<br />删除之后，它会将删除的key-value作为返回值返回<br />返回的是一个元组，元组中有两个元素，第一个元素删除的key，第二个删除的value<br />当使用popitem( )删除一个空字典时会抛出异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d.popitem( )</span><br><span class="line">result = d.popitem( )</span><br></pre></td></tr></table></figure><p><strong>pop(key[,default])</strong><br />根据key删除字典中的key-value<br />会将被删除的value返回<br />如果删除不存在的key，会报错<br />如果指定了默认值，再删除不存在的key时，不会报错，而是直接返回默认值<br />d.pop( )</p><p>**clear( )**用来清空字典<br />d.clear( )</p><p><strong>copy( )</strong><br />该方法用于对字典进行浅复制<br />复制以后的对象，和原对象是独立，修改一个不会影响另一个<br />注意，浅复只会简单复制对象内部的值，如果值也可以是一个可变对象，这个可变对象不会被复制<br />d.copy( )</p><h3 id="遍历字典"><a class="markdownIt-Anchor" href="#遍历字典"></a> 遍历字典</h3><p><strong>keys( )</strong><br />该方法会返回字典的所有的key<br />该方法会返回一个序列，序列中保存有字典的所有的键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;菜寻鲲&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="string">&#x27;18&#x27;</span>,<span class="string">&#x27;gander&#x27;</span>:<span class="string">&#x27;男&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#通过遍历keys( )来获取所有的键</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys( ) :</span><br><span class="line">    print(k,d[k])</span><br></pre></td></tr></table></figure><p><strong>values( )</strong><br />该方法会返回一个序列，序列中保存有字典的左右的值<br />for v in d.value( ) :<br />print(v)</p><p><strong>items( )</strong><br />该方法会返回字典中的所有项<br />它会返回一个序列，序列中包含有双值子序列<br />双值分别是，字典中的key和value</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(d.iteam())</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.iteam( ):</span><br><span class="line">print(k,v <span class="string">&#x27;=&#x27;</span>,v)</span><br></pre></td></tr></table></figure><h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2><h3 id="集合简介"><a class="markdownIt-Anchor" href="#集合简介"></a> 集合简介</h3><p>集合和列表非常相似<br />不同点：<br />1.集合中只能存储不可变对象<br />2.集合中存储的对象是无序的（不是按照元素的插入顺序保存）<br />3.集合中不能出现重复的元素 （重复的元素只保留一个）<br />使用{ }来创建一个集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,&#125;  <span class="comment">#&lt;class &#x27;set&#x27;&gt;</span></span><br><span class="line">print(s,type(s))</span><br></pre></td></tr></table></figure><p>使用 <strong>set( )</strong> 函数来创建集合<br />s = set( ) #空集合<br />可以通过set( )来将序列和字典转换为集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  <span class="comment">#列表转集合</span></span><br><span class="line">s = set(<span class="string">&#x27;hello&#x27;</span>)   </span><br><span class="line">s = set(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;)   <span class="comment">#使用set( )将字典转换为集合时，只会包含字典中的键</span></span><br></pre></td></tr></table></figure><h3 id="创建集合"><a class="markdownIt-Anchor" href="#创建集合"></a> 创建集合</h3><p>s = {‘a’,‘b’,1,2,3}<br />使用in和not in来检查集合中的元素<br />print(‘b’ in s)<br />使用len( )来获取集合中的元素数量<br />print(len(s))</p><p><strong>add( )</strong> 向集合中添加元素<br />s.add(5)<br />print(s,type(s))</p><p><strong>update( )</strong> 将集合中的元素添加到当前集合中<br />update( ) 可以传递序列或字典作为参数，字典只会使用键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s2 = set(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">s.update(s2)</span><br><span class="line">s.update((<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>))</span><br><span class="line">s.update(&#123;<span class="number">10</span>:<span class="string">&#x27;ab&#x27;</span>,<span class="number">20</span>:<span class="string">&#x27;bc&#x27;</span>,<span class="number">100</span>:<span class="string">&#x27;cd&#x27;</span>,<span class="number">1000</span>:<span class="string">&#x27;ef&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">40</span>, <span class="string">&#x27;o&#x27;</span>, <span class="number">10</span>, <span class="number">1000</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="string">&#x27;e&#x27;</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>pop( )</strong> 随机删除并返回一个集合中的元素<br />result = s.pop()</p><p><strong>remove( )</strong> 删除集合中的指定元素</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.remove(100)</span><br><span class="line">s.remove(1000)</span><br></pre></td></tr></table></figure><p><strong>clear( )</strong> 清空集合<br />s.clear()</p><p><strong>copy( )</strong> 对集合进行浅复制</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(s , <span class="built_in">type</span>(s))</span><br></pre></td></tr></table></figure><h2 id="集合的运算"><a class="markdownIt-Anchor" href="#集合的运算"></a> 集合的运算</h2><p>创建两个集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br></pre></td></tr></table></figure><p>&quot; &amp; &quot; 交集运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = s &amp; s2  <span class="comment">#&#123;3,4,5&#125;</span></span><br></pre></td></tr></table></figure><p>&quot; <strong>|</strong> &quot;  并集运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = s | s2   <span class="comment">#&#123;1,2,3,4,5,6,7&#125;</span></span><br></pre></td></tr></table></figure><p>&quot; <strong>-</strong> &quot; 差集 （只在s集合里有，s2集合里没有的集合）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = s - s2   <span class="comment">#&#123;1,2&#125;</span></span><br></pre></td></tr></table></figure><p>&quot; <strong>^</strong> &quot; 异或集  （获取只在一个集合中出现的元素）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = s ^ s2  <span class="comment">#&#123;1,2,6,7&#125;</span></span><br></pre></td></tr></table></figure><p>&quot; <strong>&lt;=</strong> &quot; 检查一个集合是否为另一个集合的子集<br />#如果a集合中的元素全部在b集合中出现，那么a集合就是b集合的子集，b集合是a集合的超集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">result = a &lt;= b <span class="comment">#True</span></span><br><span class="line">result = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt;= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">#True</span></span><br><span class="line">result = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; &lt;= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;  <span class="comment">#False</span></span><br></pre></td></tr></table></figure><p>&quot; <strong>&lt;</strong> &quot; 检查a集合是否是b集合的真子集<br />#如果超集b中含有子集a中所有元素，并且b中还有a中没有的元素，则b就是a的真超集，a是b的真子集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; <span class="comment">#False</span></span><br><span class="line">result = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125; &lt; &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">#True</span></span><br><span class="line">print(<span class="string">&#x27;result =&#x27;</span>,result)</span><br></pre></td></tr></table></figure><p>&quot; <strong>&gt;=</strong> &quot; 检查一个集合是否是另一个的超集<br />&quot; <strong>&gt;</strong> &quot; 检查一个集合是否是另一个的真超集</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--序列（1）</title>
      <link href="2020/07/04/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BA%8F%E5%88%97%EF%BC%881%EF%BC%89/"/>
      <url>2020/07/04/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%BA%8F%E5%88%97%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="列表-list"><a class="markdownIt-Anchor" href="#列表-list"></a> 列表 （list）</h2><p>列表是python中的一个对象<br />对象 (object)就是内存中专门用来存储数据的一块区域<br />之前我们学习的对象，像数值，它只能保存一个单一的数据<br />列表中可以保存多个有序的数据<br />列表是用来存储对象的对象<br />列表的使用：<br />1.列表的创建<br />2.操作列表中的数据<br />创建列表，通过[ ]来创建列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [ ]   <span class="comment">#创建一个空列表</span></span><br><span class="line">print(my_list,type(my_list))</span><br></pre></td></tr></table></figure><pre><code>   列表中存储的数据，称为元素   一个列表可以有多个元素，也可以在创建列表时，来指定列表中的元素   my_list = [7]   #创建了一个包含一个元素的列表   当向列表中添加多个元素时，多个元素之间使用  逗号  隔开    my_list = [5,6,7,8,9 ]   #创建了一个包含多个元素的列表              👆排序:0,1,2,3,4   列表中可以保存任意的对象   列表中的对象都会按照插入的顺序储存到列表中，第一个插入的对象保存到第一个位置，第二个保存到第二个位置   我们可以通过索引（index） 来获取列表中的元素   索引是元素在列表中的位置，列表第一个位置的索引位0，第二个索引为1，以此类推   my_list = [5,6,7,8,9 ]   通过索引获取列表中的元素   语法：my_list[索引] my_list[0]   print(my_list[4])   如果使用的索引超过了最大的范围，会抛出异常   获取列表的长度，列表中的元素个数   len( )函数，通过该函数可以获取列表的长度   获取到的最大长度值，是列表的最大索引+1，索引是从0开始的</code></pre><h2 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h2><p>切片指从现有列表中，获取一个子列表<br />创建一个列表，一般创建列表时，变量的名字会使用复数<br />name = [‘蔡寻鲲’,‘肖偷’,‘鹿憨’,‘大碗宽面’,‘蒋劲夫’,‘网易宝’]<br />列表的索引可以是负数<br />如果索引是负数，则从后向前获取元素，-1表示倒数第一个，-2表示倒数第二个，以此类推<br />print(name[-2])</p><p>通过切片来获取指定元素<br />语法：获取[起始：结束]<br />通过切片获取元素，会包括起始位置元素，不会包括结束位置元素<br />做切片操作时，总会返回一个新列表，不会影响原来的列表<br />起始和结束位置的索引都可以省略不写<br />如果省略结束位置，则会一直截取到最后<br />如果省略起始位置，则会从第一个元素开始截取<br />如果起始和结束位置全省略，则相当于创建了一个列表副本  （相当于复制一遍）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(name[ :<span class="number">4</span>])</span><br><span class="line">print(name[<span class="number">2</span> : ])</span><br><span class="line">print(name[ : ])</span><br></pre></td></tr></table></figure><p>语法 ：列表[起始：结束：步长]<br />步长表示，每次获取元素的间隔，默认值是1<br />步长不能是0，但可以是负数  如果为0会抛出异常<br />如果是负数，则会从列表的后部向前边获取元素</p><p>列表的通用操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">&#x27;蔡寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>,<span class="string">&#x27;鹿憨&#x27;</span>,<span class="string">&#x27;大碗宽面&#x27;</span>,<span class="string">&#x27;蒋劲夫&#x27;</span>,<span class="string">&#x27;网易宝&#x27;</span>]</span><br><span class="line">           <span class="number">0</span>      <span class="number">1</span>      <span class="number">2</span>       <span class="number">3</span>        <span class="number">4</span>       <span class="number">5</span>          </span><br></pre></td></tr></table></figure><p><strong>&quot; + &quot;</strong>  和  <strong>&quot; * &quot;</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">&quot; + &quot;</span> 可以将两个列表片拼接为一个列表</span><br><span class="line">name = [<span class="string">&#x27;蔡寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>,<span class="string">&#x27;鹿憨&#x27;</span>] + [<span class="string">&#x27;大碗宽面&#x27;</span>,<span class="string">&#x27;蒋劲夫&#x27;</span>,<span class="string">&#x27;网易宝&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"> <span class="string">&quot; * &quot;</span> 可以将列表重复指定的次数</span><br><span class="line">name = [<span class="string">&#x27;蔡寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>,<span class="string">&#x27;鹿憨&#x27;</span>] * <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>&quot; in &quot;</strong> 和 <strong>&quot; not in &quot;</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; in &quot;</span> 用来检查指定元素是否在列表中</span><br><span class="line"> 如果存在返回<span class="literal">True</span>，如果不存在返回<span class="literal">False</span></span><br><span class="line"> print(<span class="string">&#x27;肖偷&#x27;</span> <span class="keyword">in</span> name)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; not in &quot;</span> 用来检查指定元素是否不在列表中</span><br><span class="line">     如果存在返回<span class="literal">False</span>，如果不存在返回<span class="literal">True</span> </span><br></pre></td></tr></table></figure><p><strong>len( )</strong> 获取列表中的元素个数<br /><strong>min( )</strong> 获取列表中的最小值<br /><strong>max( )</strong> 获取列表中的最大值</p><h2 id="两个方法method"><a class="markdownIt-Anchor" href="#两个方法method"></a> 两个方法（method）</h2><p><strong>index( )</strong> 和 <strong>count( )</strong><br />方法和函数基本上是一样，只不过方法必须通过 对象·dian方法( )的形式调用<br />xxx.print( )方法实际上就是和对象关系紧密的函数<br />s.index()  获取指定元素在列表中的第一次索引的位置   列表名.index( )<br />index( )的第二个参数表示查找的起始位置，第三个参数表示结束位置<br />name.index(‘肖偷’,1,4)  #获取肖偷在列表中的位置<br />如果要获取列表中没有的元素，会抛出异常</p><p>s.count( )   统计指定元素在列表中出现的次数</p><h2 id="序列sequence"><a class="markdownIt-Anchor" href="#序列sequence"></a> 序列（sequence）</h2><p>序列是python中最基本的一种数据结构<br />数据结构指计算机中数据存储的方式<br />序列用于保存一组有序的数据，所有的数据在序列当中都有唯一的位置（索引）<br />并且序列中的数据会按照添加的顺序来分配索引<br />序列分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可变序列：（序列中元素可以改变）</span><br><span class="line">    &gt; 列表（list）</span><br><span class="line">不可变序列 ：（序列中元素不能改变）</span><br><span class="line">    &gt; 字符串（str）</span><br><span class="line">    &gt;元组 （tuple）     </span><br></pre></td></tr></table></figure><p>以上的操作全是序列的通用操作</p><p>修改列表中的元素<br />直接通过索引来修改元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stus = [<span class="string">&#x27;蔡寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>,<span class="string">&#x27;鹿憨&#x27;</span>,<span class="string">&#x27;大碗宽面&#x27;</span>,<span class="string">&#x27;蒋劲夫&#x27;</span>]</span><br></pre></td></tr></table></figure><p>stus[1] = ‘xiaotou’<br />print(‘修改后:’,stus)</p><p>通过 <strong>del</strong> 来删除元素<br />del stus[2]  #删除索引为2的元素</p><p>通过切片来修改列表<br />在给切片进行赋值时，只能使用序列<br />stus[0:2] = [‘傻狗’,‘土狗’]  #使用新的元素替换之前的元素<br />stus[0:0] = [‘傻狗’]    #向索引为0的位置插入元素<br />当设置了步长时，序列中元素的隔宿必须和切片中元素的个数一致<br />stus[ : : 2] = [‘傻狗’,‘土狗’,‘高速公鹿’]  #前边从name列表取出三个元素，后边要替换前边也必须要有三个元素</p><p>通过切片来删除元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> stus[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="keyword">del</span> stus[ : : <span class="number">2</span>]</span><br><span class="line">stus[<span class="number">1</span>:<span class="number">3</span>] = [ ]</span><br></pre></td></tr></table></figure><p>以上操作只可以适用与可变序列，不可变序列无法通过索引修改</p><p>s = ‘hello’    #字符串是不可变序列 不能为其赋值<br />s[1] = ‘a’     #不可变序列无法通过索引来修改<br />可以通过 <strong>list( )</strong> 函数将其他的序列转换为list<br />s = list(s)<br />s[1] = ‘a’<br />print(s)</p><p>通过列表的方法修改列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原列表 stus = [<span class="string">&#x27;蔡寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>,<span class="string">&#x27;鹿憨&#x27;</span>,<span class="string">&#x27;大碗宽面&#x27;</span>,<span class="string">&#x27;蒋劲夫&#x27;</span>,<span class="string">&#x27;网易宝&#x27;</span>]</span><br><span class="line">  print(<span class="string">&#x27;原列表：&#x27;</span>,stus)</span><br></pre></td></tr></table></figure><p><strong>append( )</strong>    #只加一个元素用这个<br />向列表的最后添加一个元素<br />stus.append(‘土狗’)<br />print(‘修改后：’,stus)</p><p><strong>insert( )</strong><br />向列表的指定位置插入一个元素<br />参数：<br />1.要插入的元素<br />2.要插入的位置<br />stus.insert(2,‘傻狗’)  #把傻狗插入索引2位置   前边位置后边元素</p><p><strong>extend( )</strong><br />添加多个元素用这个<br />使用新的序列来扩展当前序列<br />需要一个序列作为参数，它会将该序列中的元素添加到列表当中<br />stus.extend([‘土狗’,‘傻狗’])  相当于  stus += [‘土狗’,‘傻狗’]</p><p><strong>clear( )</strong><br />清空序列<br />stus.clear( )</p><p><strong>pop( )</strong><br />根据索引删除并返回被删除的元素<br />stus.pop(2)  #删除索引为2的元素，括号内不写就是删除最后一个元素</p><p><strong>remove( )</strong><br />删除指定值的元素，如果有多个相同值的元素，只会删除第一个<br />stus.remove(‘肖偷’)</p><p><strong>reverse( )</strong><br />用来反转列表，就是颠倒列表<br />stus.reverse( )</p><p><strong>sort( )</strong><br />用来对列表中的元素进行排序，默认是升序排列<br />my_list = list(‘aavjaavjjbdvd’)<br />print(‘修改前：’,my_list)<br />print(‘修改后：’,my_list)<br />如果想要降序排列则需要传递一个reverse=True作为参数<br />my_list.sort(reverse=True)</p><h2 id="遍历列表"><a class="markdownIt-Anchor" href="#遍历列表"></a> 遍历列表</h2><p>遍历列表就是将列表中的所有元素取出来<br />创建列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stus = [<span class="string">&#x27;蔡寻鲲&#x27;</span>,<span class="string">&#x27;肖偷&#x27;</span>,<span class="string">&#x27;鹿憨&#x27;</span>,<span class="string">&#x27;大碗宽面&#x27;</span>,<span class="string">&#x27;蒋劲夫&#x27;</span>,<span class="string">&#x27;网易宝&#x27;</span>]</span><br></pre></td></tr></table></figure><p>遍历列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(stus[<span class="number">0</span>])</span><br><span class="line">print(stus[<span class="number">1</span>])</span><br><span class="line">print(stus[<span class="number">2</span>])</span><br><span class="line">print(stus[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>创建一个循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> i = <span class="number">0</span></span><br><span class="line"> <span class="keyword">while</span> i &lt; len(stus) :    <span class="comment">#这个一般不用</span></span><br><span class="line"> print(stus[i])</span><br><span class="line">    i +=  <span class="number">1</span></span><br><span class="line">通过<span class="keyword">for</span>循环来遍历列表</span><br><span class="line">语法：</span><br><span class="line">     <span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列</span><br><span class="line">         代码块  </span><br></pre></td></tr></table></figure><p>for循环的代码块回执行多次，序列中有几个元素就会执行几次<br />每执行一次就会将序列中的一个元素赋值给变量<br />所以我们可以通过变量，来获取列表中的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> stus ：</span><br><span class="line">  print(s)</span><br></pre></td></tr></table></figure><h2 id="range"><a class="markdownIt-Anchor" href="#range"></a> range( )</h2><p><strong>range( )</strong> 是一个函数，可以用来生成一个自然数序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r = range(<span class="number">5</span>) <span class="comment">#生成一个这样的序列[0,1,2,3,4]</span></span><br><span class="line">r = range(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">r = range(<span class="number">10</span>,<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line">print(list(r))</span><br></pre></td></tr></table></figure><p>该函数需要三个参数<br />1.起始位置 （可以省略，默认是0）<br />2.结束位置<br />3.步长（可以省略，默认是1）</p><p>通过range( )可以创建一个执行指定次数的for循环<br />for( )循环除了创建方式以外，其余的都和while一样，<br />包括else、包括break、 continue都可以在for循环中使用<br />并且for循环使用也更加简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>) :</span><br><span class="line">  print(i)  </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--流程控制语句</title>
      <link href="2020/07/03/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>2020/07/03/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><pre><code>    python代码在执行时是按照自上向下的顺序执行的。    通过流程控制语句，可以改变程序的执行顺序，也可以让指定的程序反复执行多次    流程控制语句分为两大类：条件判断语句，循环语句。</code></pre><h2 id="条件判断语句if语句"><a class="markdownIt-Anchor" href="#条件判断语句if语句"></a> 条件判断语句（if语句）</h2><p>语法： if  条件表达式 ：语句</p><p>执行流程：if语句在执行时，会对条件表达式进行求值判断，<br />如果为True，则执行if后的语句；<br />如果为False，则不执行。<br />if True : print(‘你是傻狗么’)</p><p>默认情况下，if语句只会控制紧随其后的那条语句，如果希望if可以控制多条语句则可以在if后跟一个代码块。</p><p>代码块:<br />代码块中保存着一组代码，同一个代码块中的代码，要么执行要么都不执行。<br />代码块就是一种为代码分组的机制。<br />如果我们要编写代码块，语句就不能紧随在冒号后边，而是要写在下一行<br />代码块以缩进开始，直到代码块恢复到之前的缩进级别时结束。<br />缩进有两种方式，一种是tab键，一种是四个空格。<br />python官方文档推荐用四个空格缩进，代码中使用缩进方式必须统一。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span> :</span><br><span class="line">print(<span class="number">123</span>)</span><br><span class="line">print(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">print(<span class="string">&#x27;傻狗&#x27;</span>)   <span class="comment">#到此结束代码块</span></span><br><span class="line">sssssss</span><br><span class="line">```</span><br><span class="line">可以使用逻辑运算符来连接多个运算符，</span><br><span class="line">    如果希望所有条件同时满足用<span class="keyword">and</span>；</span><br><span class="line">    如果希望只有一个条件满足即可用<span class="keyword">or</span> 。</span><br><span class="line">```python</span><br><span class="line"><span class="keyword">if</span> num&gt;<span class="number">10</span> <span class="keyword">and</span> num&lt;<span class="number">20</span> :</span><br><span class="line">print(<span class="string">&#x27;num比10大，num比20小&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="input-函数"><a class="markdownIt-Anchor" href="#input-函数"></a> input( )函数</h2><p>该函数用来获取用户的输入。<br />input()调用后，程序会立即暂停，等待用户输入。<br />用户输入完成内容以后，点击回车程序才会继续向下运行。户输入完成以后，其所输入的内容会以返回值的形式返回<br />注意：input( )的返回值是一个字符串。<br />a=input()<br />print(‘用户输入的内容 ：’, a )<br />input( )函数中可以设置一个字符串作为参数，这个字符串将会作为提示文字显示<br />a=input(‘请输入一个任意内容：’)<br />print(‘用户输入的内容 ：’, a )</p><p>练习：在命令行让用户输入一个用户名，获取用户名，并进行判断<br />如果用户输入的用户名是admin，则显示欢迎管理员光临<br />如果用户输入其他用户名，则什么也不显示。<br />答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取用户输入的用户名</span></span><br><span class="line">username=input(<span class="string">&#x27;请输入用户名：&#x27;</span>)</span><br><span class="line"><span class="comment">#判断用户名是否是admin</span></span><br><span class="line"><span class="keyword">if</span> username ==<span class="string">&#x27;amdin&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;欢迎管理员光临&#x27;</span>)</span><br><span class="line"><span class="comment">#input也可以用于暂时阻止程序结束</span></span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">input(<span class="string">&#x27;按回车键退出。。。&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="if-else语句"><a class="markdownIt-Anchor" href="#if-else语句"></a> if - else语句</h2><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> 条件表达式 ：</span><br><span class="line">        代码块</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">     代码块</span><br><span class="line">``` </span><br><span class="line">执行流程：</span><br><span class="line">   <span class="keyword">if</span> -<span class="keyword">else</span>语句在执行时，先对<span class="keyword">if</span>后的表达式进行求值判断</span><br><span class="line">         如果为<span class="literal">True</span>，则执行<span class="keyword">if</span>后的代码块</span><br><span class="line">         如果为<span class="literal">False</span>，则执行<span class="keyword">else</span>后的代码块</span><br><span class="line">例如：</span><br><span class="line">```python</span><br><span class="line"> <span class="comment">#获取用户输入的用户名</span></span><br><span class="line">username=input(<span class="string">&#x27;请输入用户名：&#x27;</span>)</span><br><span class="line"><span class="comment">#判断用户名是否是QQVIP8</span></span><br><span class="line"><span class="keyword">if</span> username==<span class="string">&#x27;QQVIP8&#x27;</span> :</span><br><span class="line">print(<span class="string">&#x27;欢迎超级会员&#x27;</span>)</span><br><span class="line">age=int(input(<span class="string">&#x27;请输入年龄&#x27;</span>))</span><br><span class="line"><span class="comment">#判断用户是否成年</span></span><br><span class="line"><span class="keyword">if</span> age &gt;=<span class="number">18</span> :</span><br><span class="line">print(<span class="string">&#x27;你已经成年&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">print(<span class="string">&#x27;你还未成&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="if-elif-else-语句"><a class="markdownIt-Anchor" href="#if-elif-else-语句"></a> if-elif-else 语句</h2><p>语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式：</span><br><span class="line">代码块</span><br><span class="line"><span class="keyword">elif</span> 条件表达式</span><br><span class="line">代码块</span><br><span class="line"><span class="keyword">elif</span> 条件表达式</span><br><span class="line">代码块</span><br><span class="line"><span class="keyword">elif</span> 条件表达式</span><br><span class="line">代码块</span><br></pre></td></tr></table></figure><p>执行流程：<br />if-elif-else 语句在执行时，会自上向下依次对条件表达式进行求值判断，<br />如果表达式的结果为True，则执行当前代码块，然后语句结束<br />如果表达式的结果为False，则继续向下判断，直到找到True为止<br />如果所有表达式都是False，则执行else后的代码块<br />if-elif-else中只会有一个代码块执行</p><h2 id="练习1"><a class="markdownIt-Anchor" href="#练习1"></a> 练习1：</h2><p>编写一个程序，获取一个用户输入的整数。然后通过程序显示这个数是奇数还是偶数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入的整数</span></span><br><span class="line">num = int(input(<span class="string">&#x27;请输入一个整数:&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span> :</span><br><span class="line">    print(num,<span class="string">&#x27;这个数是偶数&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(num,<span class="string">&#x27;这个数是奇数&#x27;</span>)    </span><br></pre></td></tr></table></figure><h2 id="练习2"><a class="markdownIt-Anchor" href="#练习2"></a> 练习2：</h2><p>编写一个程序，检查任意一个年份是否是闰年。<br />如果一个年份可以被4整除不能被100整除，或者可以被400整除，这个年份就是闰年</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = int(input(<span class="string">&#x27;请输入一个年份&#x27;</span>))  <span class="comment">#获取一个年份</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> num %<span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> num % <span class="number">400</span> == <span class="number">0</span> : <span class="comment">#判断年份是否是闰年</span></span><br><span class="line">    print(num,<span class="string">&#x27;这一年是闰年&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(num,<span class="string">&#x27;这一年是平年&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="练习3"><a class="markdownIt-Anchor" href="#练习3"></a> 练习3：</h2><p>编写一个程序，获取用户输入的狗的年龄，然后通过程序显示其相当于人类的年龄。<br />狗的前两年每一年相当于人类的10.5岁，然后每增加一年就增加四岁。<br />如果用户输入负数，请显示一个提示信息<br />我家的狗5岁了，5岁的狗相当于多大年龄的人呢？<br />那么5岁的狗相等于人类的年龄就应该是10.5+10.5+4+4+4 = 33岁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dog_age = float(input(<span class="string">&#x27;请输入狗的年龄：&#x27;</span>))</span><br><span class="line">like_person_age = <span class="number">0</span></span><br><span class="line"><span class="comment"># 在if也可以去嵌套if，代码块是可以嵌套的，每增加一个缩进的级别，代码块就低一级</span></span><br><span class="line"><span class="comment"># 检查用户的输入是否合法</span></span><br><span class="line"><span class="keyword">if</span> dog_age &gt; <span class="number">0</span> :</span><br><span class="line">     <span class="comment"># 如果狗的年龄在两岁以下（包含两岁）</span></span><br><span class="line">     <span class="keyword">if</span> dog_age &lt;= <span class="number">2</span> :</span><br><span class="line">         <span class="comment"># 直接将当前的年龄乘以10.5</span></span><br><span class="line">         like_person_age = dog_age * <span class="number">10.5</span></span><br><span class="line">     <span class="comment"># 如果狗的年龄在两岁以上</span></span><br><span class="line">     <span class="keyword">else</span> :</span><br><span class="line">         <span class="comment"># 计算前两岁相当于人类的年纪</span></span><br><span class="line">         like_person_age = <span class="number">2</span> * <span class="number">10.5</span></span><br><span class="line">         <span class="comment"># 计算超过两岁的部分相对于人类的年纪，并进行相加</span></span><br><span class="line">         like_person_age += ( dog_age - <span class="number">2</span> ) * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">     print(dog_age,<span class="string">&#x27;岁的狗，年纪相当于&#x27;</span>,like_person_age,<span class="string">&#x27;岁的人&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">     print(<span class="string">&#x27;请输入一个合法的年龄！&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="练习4"><a class="markdownIt-Anchor" href="#练习4"></a> 练习4：</h2><p>从键盘输入小明的期末成绩:<br />当成绩为100时，‘奖励一辆BMW’<br />当成绩为[80-99]时，‘奖励一台iphone’<br />当成绩为[60-79]时，‘奖励一本参考书’<br />其他时，什么奖励也没有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num = float(input(<span class="string">&#x27;请输入小明的期末成绩：&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> &lt;= num &lt;= <span class="number">100</span> :</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">100</span> :</span><br><span class="line">        print(<span class="string">&#x27;奖励一辆BMW&#x27;</span>) </span><br><span class="line">    <span class="keyword">elif</span> num &gt;= <span class="number">80</span> :</span><br><span class="line">        print(<span class="string">&#x27;奖励一台iphone&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> num &gt;= <span class="number">60</span> :</span><br><span class="line">        print(<span class="string">&#x27;奖励一本参考书&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> num &lt; <span class="number">60</span> :</span><br><span class="line">        print(<span class="string">&#x27;你个笨蛋，要个屁的奖励&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>  :</span><br><span class="line">        print(<span class="string">&#x27;请输入一个合法成绩&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="练习5"><a class="markdownIt-Anchor" href="#练习5"></a> 练习5：</h2><p>大家都知道，男大当婚，女大当嫁。那么女方家长要嫁女儿，当然要提出一定的条件：<br />高：180cm以上; 富:1000万以上; 帅:500以上;<br />如果这三个条件同时满足，则:‘我一定要嫁给他’<br />如果三个条件有为真的情况，则:‘嫁吧，比上不足，比下有余。’<br />如果三个条件都不满足，则:‘不嫁！’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">height = float(input(<span class="string">&#x27;请输入身高（厘米）：&#x27;</span>))</span><br><span class="line">money = float(input(<span class="string">&#x27;请输入财产（万）：&#x27;</span>))</span><br><span class="line">face = float(input(<span class="string">&#x27;请输入颜值（平方厘米）：&#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> height &gt;=<span class="number">0</span> <span class="keyword">and</span> money &gt;=<span class="number">0</span> <span class="keyword">and</span> face &gt;=<span class="number">0</span> :</span><br><span class="line">    <span class="keyword">if</span> height &gt;= <span class="number">180</span> <span class="keyword">and</span> money &gt;=<span class="number">1000</span> <span class="keyword">and</span> face &gt;=<span class="number">500</span> :</span><br><span class="line">        print(<span class="string">&#x27;我一定要嫁给他&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> height &gt;= <span class="number">180</span> <span class="keyword">or</span> money &gt;=<span class="number">1000</span> <span class="keyword">or</span> face &gt;=<span class="number">500</span> :</span><br><span class="line">        print(<span class="string">&#x27;嫁吧，比上不足，比下有余。&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> height &lt; <span class="number">180</span> <span class="keyword">or</span> money &lt; <span class="number">1000</span> <span class="keyword">or</span> face &lt; <span class="number">500</span> :</span><br><span class="line">        print(<span class="string">&#x27;不嫁！&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;请输入合法的值&#x27;</span>) </span><br></pre></td></tr></table></figure><h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2><p>循环语句可以使指定的代码块重复指定次数<br />循环语句分成两种,while循环和for循环<br />while循环<br />语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式：</span><br><span class="line">       代码块</span><br><span class="line"><span class="keyword">else</span> :    </span><br></pre></td></tr></table></figure><h2 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程：</h2><p>while语句在执行时，会先对while后的条件表达式进行求值判断，<br />如果判断结果为True，则执行循环体（代码块），<br />循环体执行完毕，继续对条件表达式进行求值判断，以此类推<br />直到判断结果为False，则循环终止 ，如果循环有对应的else，则执行else后的代码块<br />条件表达式恒为True的循环语句 ，称为死循环，它会一直运行，慎用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span> :</span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="循环的三个要件三个表达式"><a class="markdownIt-Anchor" href="#循环的三个要件三个表达式"></a> 循环的三个要件（三个表达式）</h2><p>初始化表达式，通过初始化表达式初始化一个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="comment">#条件表达式，条件表达式用来设置循环执行的条件</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span> :</span><br><span class="line">    <span class="comment">#更新表达式，修改初始化变量的值</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    print(i,<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    print(<span class="string">&#x27;循环十次&#x27;</span>)    </span><br></pre></td></tr></table></figure><h2 id="练习1-2"><a class="markdownIt-Anchor" href="#练习1-2"></a> 练习1 ：</h2><pre><code> 求100以内的所有奇数之和 </code></pre><p><strong>方法一(while循环)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span> :</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> !=<span class="number">0</span> :</span><br><span class="line">        result += i</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p><strong>方法二(for循环)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">0</span>       </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>) :</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span> :</span><br><span class="line">        result += i</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h2 id="练习2-2"><a class="markdownIt-Anchor" href="#练习2-2"></a> 练习2：</h2><pre><code>  求100以内所有7的倍数之和，以及个数</code></pre><p><strong>方法一(while循环)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">7</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span> :</span><br><span class="line">    result += i</span><br><span class="line">    count +=<span class="number">1</span></span><br><span class="line">    i += <span class="number">7</span></span><br><span class="line">print(<span class="string">&#x27;总和为：&#x27;</span> , result , <span class="string">&#x27;总数量为：&#x27;</span> ,count)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br></pre></td></tr></table></figure><p><strong>方法二(for循环):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>,<span class="number">100</span>) :</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">7</span> == <span class="number">0</span> :</span><br><span class="line">        result += i</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">print(result,count)</span><br></pre></td></tr></table></figure><h2 id="循环嵌套"><a class="markdownIt-Anchor" href="#循环嵌套"></a> 循环嵌套</h2><p>在控制台中打印如下图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>创建一个循环来控制图形的高度<br />循环嵌套时，外层循环没执行一次，内存循环就要执行一圈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>: </span><br><span class="line"><span class="comment">#创建一个内层循环来控制图形的宽度</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">5</span>: </span><br><span class="line">print(<span class="string">&quot;* &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">print()</span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*     j&lt;<span class="number">1</span>   i=<span class="number">0</span></span><br><span class="line">**    j&lt;<span class="number">2</span>   i=<span class="number">1</span>   </span><br><span class="line">***   j&lt;<span class="number">3</span>   i=<span class="number">2</span></span><br><span class="line">****  j&lt;<span class="number">4</span>   i=<span class="number">3</span></span><br><span class="line">***** j&lt;<span class="number">5</span>   i=<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*****</span><br><span class="line">****</span><br><span class="line">***</span><br><span class="line">**</span><br><span class="line">*</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">5</span>:</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; i + <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&quot;* &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    print()</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>练习1：九九乘法表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个外层循环来控制图型高度</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">9</span> :</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="comment">#创建一个内置循环来控制图形宽带</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; i :</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        print(<span class="string">f&quot;<span class="subst">&#123;j&#125;</span>*<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;i*j&#125;</span>    &quot;</span>,end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><h2 id="break和continue"><a class="markdownIt-Anchor" href="#break和continue"></a> break和continue</h2><p>break 可以用来立即退出执行（包括else）<br />continue可以用来跳过当次循环<br />break和continue都是只对离他最近的循环起作用<br />pass是用来在判断或循环语句中占位的</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--python入门</title>
      <link href="2020/07/02/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%85%A5%E9%97%A8/"/>
      <url>2020/07/02/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是计算机语言"><a class="markdownIt-Anchor" href="#什么是计算机语言"></a> 什么是计算机语言</h2><p>计算机就是一个用来计算的机器，人让计算机干什么计算机就干什么。<br />需要计算机语言来控制计算机。（编程语言）<br />计算机语言和人类语言没有本质区别，不同点就是交流的主体不同。<br />计算机语法发展经历了三个阶段：<br />机器语言<br />-机器语言通过二进制编码来编写程序<br />-执行效率好，编写起来麻烦<br />汇编语言<br />-使用符号来代替机器码<br />-编写程序时，不需要使用二进制，而是直接编写符号<br />-编写完成后，需要将符号转换为机器码，然后再由计算机执行<br />符号转换为机器码的过程称为汇编<br />-将机器码转换为符号的过程为反汇编<br />-汇编语言一般只适用于某些硬件，兼容性较差<br />高级语言<br />-高级语言的语法基本和现在英语语法类似，并且和硬件的关系没那么紧密了<br />-也就是说我们通过高级语言开发程序可以在不同的硬件系统中执行<br />-并且高级语言学习起来页更加容易,现在我们指定的语法基本都是高级语言<br />-C++ 、C# 、Java 、JAvaScript 、Python。。。。。</p><h2 id="编译型语言和解释型语言"><a class="markdownIt-Anchor" href="#编译型语言和解释型语言"></a> 编译型语言和解释型语言</h2><p>计算机 只能识别二进制编码（机器码），所以任何的语言在交由计算机执行时必须要先转换为机器码，<br />也就是像 print(‘hello’) 必须要转换为类似的10101010机器码</p><p>根据转换时机的不同，语言分为两大类：<br />编译型语言：<br />-C语言<br />-编译型语言，会在代码执行千将代码编译为机器猫，然后将机器猫交由计算机执行<br />-a（源码）----编译----&gt;b(编译后的机器码)<br />-特点：<br />执行速度特别快<br />跨平台性比较差<br />解释型语言<br />-python   JS  Java<br />-解释型语言，不会在执行前对代码进行编译，而是在执行的同时一边执行一遍编译<br />-a(源码) --解释器–&gt; 解释执行<br />-特点：<br />执行速度比较慢<br />跨平台性比较好</p><h2 id="python的介绍"><a class="markdownIt-Anchor" href="#python的介绍"></a> python的介绍</h2><pre><code>python是解释型语言      结构清晰明了 python用途：    web应用          Facebook  豆瓣 。。。。    爬虫程序    科学计算    自动化运维    大数据（数据清洗）    云计算    桌面软件/游戏               人工智能</code></pre><h2 id="python开发环境搭建"><a class="markdownIt-Anchor" href="#python开发环境搭建"></a> python开发环境搭建</h2><pre><code>开发环境搭建就是安装python的解释器python的解释器分类：   CPython（官方）：       用C语言编写的python解释器    PyPy：        用python语言编写的python解释器    Ironpython         用.net编写的python解释器    Jython：         用Java编写的Python解释器 步骤：      1.下载安装包   看好版本      2.安装      3.打开命令行窗口，输入Python，出现如下则安装成功         # C:\Users\Bana&gt;python          Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32          Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.          &gt;&gt;&gt;</code></pre><h2 id="python的交互界面"><a class="markdownIt-Anchor" href="#python的交互界面"></a> python的交互界面</h2><p>当我们通过命令行输入python，所进入到的界面就是python的交互界面<br />结构：<br />Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32<br />Type “help”, “copyright”, “credits” or “license” for more information.</p><pre><code>    命令提示符    &gt;&gt;&gt;    在命令行提示符后可以直接输入python的指令 输入完的指令将会被python的解释器立即执行。    安装python的同时，会自动安装一个python的开发工具IDLE，通过IDEL也可以进入到交互模式    但不同的是，在IDLE中可以通过tab键来查看语句的提示。    IDLE实际上就是一个交互界面，但是他也可以有一些简单的提示，并且也可以将代吗保存</code></pre><p>交互模式只能你输入一行代码，他就是写一行执行一行，所以并不适用我们日常开发。<br />仅仅可以用来做日常简单的测试。</p><p>我们一般会将python代码编写到py文件中，然后通过python指令来执行文件中的代码</p><h2 id="python和sublime的整合"><a class="markdownIt-Anchor" href="#python和sublime的整合"></a> python和Sublime的整合</h2><pre><code>1.在Sublime中执行python代吗，ctrl+b自动在Sublime内置的控制台中执行   这种执行方式，在某些版本的Sublime中对中文支持不友好，并且不能使用 input()函数2.使用 SublimeREPL来运行python代码     安装完成，设置快捷键，设置称F5来自动执行python代码</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        [</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;f5&quot;], &quot;caption&quot;: &quot;SublimeREPL:Python&quot;,&quot;command&quot;: </span><br><span class="line">&quot;run_existing_window_command&quot;, &quot;args&quot;:&#123;&quot;id&quot;: &quot;repl_python_run&quot;,&quot;file&quot;: &quot;config&#x2F;Python&#x2F;Main.sublime-menu&quot;&#125;&#125;,</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p><strong>1.表达式</strong><br />表达式就是类似于数学公式的东西<br />比如：1+2   ，2+3 。。。。。<br />表达式一般仅仅用了计算结果，不会对程序产生实质性的影响<br />如果在交互模式中输入一个表达式，解释器会对表达式的结果输出<br /><strong>2.语句</strong><br />在程序中语句一般需要完成某种功能，比如打印信息、获取信息、为变量赋值。。。。<br />比如：<br />a=10<br />print(a)<br />语句的执行一般会对程序产生影响<br />在交互模式中不一定会输出语句的执行结果<br /><strong>3.程序（program）</strong><br />程序就是有一条一条的语句和一条一条的表达式构成的。<br /><strong>4.函数（function）</strong><br />函数就是一种语句，函数专门用来完成特定功能<br />函数形如：xxx（）<br />函数分类：<br />内置函数：<br />由python解释器提供的函数，可以在python中直接使用<br />自定义函数：<br />由程序员自主的创建的函数<br />当我们需要完成某个功能时就可以去调用内置函数，或者自定义函数<br />函数的两个要素：<br />参数：<br />-（）中的内容就是函数的参数<br />函数中可以没有参数，可以有多个参数，多个参数之间使用逗号隔开返回值<br />返回值<br />返回值是函数的返回结果 ，不是所有的函数都有返回值</p><h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2><p>1.在python中严格区分大小写<br />2.python中的每一行就是一条语句，每条语句以换行符结束（一个回车一条语句）<br />3.python中每一行语句不要过长（规范中建议每行不要超过80个字符）<br />“rulers”:[80],放到首选项的设置里<br />4.一条语句可以分多行编写，多行编写时语句后边以反斜杠结尾 <br />5.python是缩进严格的语言，所以在python中不要随便写缩进<br />6.在python中使用#来表示注释，#后的内容都是注释，注释内容会被解释器忽略<br />我们可以通过注释来对程序进行解释说明，一定要养成良好的编写注释的习惯<br />注释要求简单明了，习惯上#后边会跟上一个空格</p><h2 id="字面量和变量"><a class="markdownIt-Anchor" href="#字面量和变量"></a> 字面量和变量</h2><p>字面量就是一个一个的值，比如：1，2，3，4，5，‘hello’<br />字面量所表示的意思就是它的字面的值，在程序中可以直接使用字面量<br />变量（variable）变量可以用来保存字面量，并且变量中保存的字面量是不定的<br />变量本身没有任何意思，他会根据不同的字面量表示不同的意思<br />一般我们开发时，很少直接使用字面量，都是将字面量保存到变量中，通过变量来引用字面量</p><h2 id="变量和标识符"><a class="markdownIt-Anchor" href="#变量和标识符"></a> 变量和标识符</h2><p>变量：<br />python中使用变量，不需要声明，直接为变量赋值即可<br />a=10  print(a)    输出 10<br />不能使用没有赋值过的变量<br />如果使用没有赋值的变量，会报错<br />print(10)   输出 报错  是没有意义的<br />python是一个动态类型的语言，可以为变量赋任意类型的值，也可以任意修改变量的值<br />标识符：<br />在python中所有可以自主命名的内容都属于标识符<br />比如：变量名、函数名、类名<br />标识符必须遵循标识符规范：<br /><strong>1.标识符中可以含有字母、数字、下划线，但是不能以数字开头</strong><br />例如：a_1   _a1   _a1<br /><strong>2.标识符不能是python中的关键字和保留字</strong><br />也不建议使用python中的函数名作为标识符，因为这样会导致函数被覆盖<br />如果使用不符合标识符会报错<br /><strong>3.命名规范：</strong><br />在python中主要遵循两种命名规范：<br />下划线命名法:<br />所有字母小写，单词之间使用__分割<br />max_lenght   xxx_zzz_vvv<br />帕斯卡命名法（大驼峰命名法）<br />首字母大写，每个单词开通字母大写，其余字母小写<br />MaxLenght    Xxx_Zzz_Vvv</p><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><p>数据类型指的就是变量的值的类型，也就是可以为变量赋哪些值<br />在python中数值分成了三种：整数、浮点数（小数）、复数<br />在python中所有的整数都是int类型<br />a=10   b=20<br />在python中整数的大小没有限制，可以是一个无限大的整数<br />d=999999999999999999999999999999999999999999 ** 100<br />如果数字的长度过大，可以使用下划线作为分隔符，下划线不影响值的大小，下划线会被解释器忽略</p><p>其他进制的整数，十进制的数字不能以0开头，只要是数字打印时一定是以十进制的形式显示的<br />二进制  0b开头    a=0b10   二进制的10<br />八进制  0o开头    a=0o10   八进制的10<br />十六进制 0x开头  a=0x10    十六进制的10</p><p>也可以通过运算符来对数字进行运算，表达式不会对程序产生任何影响<br />c=2                                          c=2<br />c+1    ，不产生影响                  c=c+1<br />print©  输出还是2                   print©  输出是3<br />浮点数（小数），在python中所有的小数都是float类型<br />c=1.23<br />对浮点数进行运算时，可能会得到一个不精确的结果<br />c=0.1+0.2    #0.300000000000004</p><h2 id="字符串str"><a class="markdownIt-Anchor" href="#字符串str"></a> 字符串(str)</h2><p>字符串用来表示一段文本信息，字符串是程序中使用最多的数据类型<br />python中字符串需要使用引号引起来<br />引号可以是双引号也可以是单引号，但是注意不要混着用<br />a=‘hello’       a=“hello”<br />相同的引号之间不能嵌套，长字符串中单引号和双引号不能跨行使用</p><pre><code>   s=&quot;锄禾日当午，\   汗滴禾下土。\   谁知盘中餐，\   粒粒皆辛苦。&quot;   # 打印结果是这个不带换行</code></pre><p>使用三重引号来表示一个长字符串’’'或&quot;&quot;&quot;<br />三重引号可以换行，并且会保留字符串中的格式</p><pre><code>   s='''锄禾日当午，   汗滴禾下土。   谁知盘中餐，   粒粒皆辛苦。'''</code></pre><h2 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h2><p>可以使用\作为转义字符，通过转义符可以在字符串中使用一些特殊的内容<br />s=“子曰：“学而时习之，不亦乐乎。””<br />s=“子曰：“学而时习之，不亦乐乎。””  #上下对比并运行</p><p>例子:<br />#   ’             表示  ’  表示单引号<br />#   &quot;            表示  &quot;   表示双引号<br />#   \t            表示制表符  （相当于按了一下tab）<br />#   \n           表示换行符<br />#   \            表示反斜杠    （打印出来是一个\，如果要打印出两个反斜杠，需要在程序中写4个\\<br />\uxxxx    表示Unicode编码</p><h2 id="格式化字符串"><a class="markdownIt-Anchor" href="#格式化字符串"></a> 格式化字符串</h2><p><strong>1拼串法</strong><br />字符串也可以进行加法运算<br />如果将两个字符串进行相加，则会自动及那个两个字符串拼接为一个<br />a=‘caixunkun’+‘鸡你太美’<br />print(a)   输出为  caixunkun鸡你太美<br />#字符串不能和其他的类型进行加法运算，如果做了会出现异常报错<br />print(“a=”+a)   #这种写法在python中不常见<br />a=123</p><p><strong>2传两个参数法  print(‘a=’,a)</strong></p><p><strong>3.占位符法</strong><br />在创建字符串时，可以在字符串中指定占位符<br />%s   在字符串中表示任意字符<br />%f    浮点数的占位符<br />%d   整数的占位符<br />b=‘练习生 %s’%‘菜寻鲲’<br />b=‘练习生 %s 流量明星 %s’%(‘菜寻鲲’,‘鸡你太美’)<br />b=‘练习生 %3.5s’%123456   #%3.5表示最少保留三位最多五位数<br />b=‘练习生 %.2f’ %123.456 #表示小数点后两位，会四舍五入<br />print(‘a=%s’%a)</p><p><strong>4.直接嵌入变量法</strong><br />格式化字符串，可以通过在字符串前添加一个f来创建一个格式化字符串<br />在格式化字符串中可以直接嵌入变量<br />c=f’hello {a} {b}’<br />print(f’a={a}’)<br />总结上述：<br />联系 使用四种方法来输出，练习生  xxx   鸡你太美<br />name=菜寻鲲<br /><strong>拼串</strong><br />print(‘练习生 ‘+name+’ 鸡你太美’)<br /><strong>多个参数</strong><br />print(‘练习生’,name,‘鸡你太美’)<br /><strong>占位符</strong><br />print(‘练习生 %s 鸡你太美’%name)<br /><strong>格式化字符串</strong><br />print(f’练习生 {name} 鸡你太美’)</p><h2 id="字符串的复制将字符串和数字相乘"><a class="markdownIt-Anchor" href="#字符串的复制将字符串和数字相乘"></a> 字符串的复制（将字符串和数字相乘）</h2><p>a=‘abc’<br />&quot; * &quot; 在语言中标识乘法<br />如果将字符串和数字相乘，则解释器会将字符串重复指定的次数并返回<br />a=a*2</p><h2 id="布尔值bool和空值none"><a class="markdownIt-Anchor" href="#布尔值bool和空值none"></a> 布尔值（bool）和空值（None）</h2><p>布尔值主要用来做逻辑判断<br />布尔值一共有两个<strong>True</strong>和<strong>False</strong><br />True表示真  False表示假<br />布尔值实际上也属于整型，True相当于1，False相当于0</p><p>空值（None）<br />None专门用来表示不存在</p><h2 id="类型检查"><a class="markdownIt-Anchor" href="#类型检查"></a> 类型检查</h2><p>通过类型检查，可以检查指定值（变量）的类型<br />a=123 #数值<br />b=‘123’ #字符串<br />print(‘a=’,a)<br />print(‘b=’,b)</p><p>type( ) 用来检查值的类型<br />该函数会将检查的结果作为返回值返回，可以通过变量来接受函数值的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="number">1</span>))           <span class="comment">#&lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line">print(type(<span class="number">1.5</span>))        <span class="comment">#&lt;class &#x27;float&#x27;&gt;</span></span><br><span class="line">print(type(<span class="literal">True</span>))      <span class="comment">#&lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line">print(type(<span class="string">&#x27;hello&#x27;</span>))   <span class="comment">#&lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">print(type(<span class="literal">None</span>))    <span class="comment">#&lt;class &#x27;NoneType&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对象object"><a class="markdownIt-Anchor" href="#对象object"></a> 对象（object）</h2><p>python是一门面向对象的语言<br />一切皆对象<br />程序运行当中，所有的数据都是储存到内存当中然后在运行。<br />对象就是内存中专门来存储指定数据的一块区域<br />对象实际就是一个容器，专门来存储数据<br />数值、字符串、布尔值、None都是对象</p><h2 id="对象的结构"><a class="markdownIt-Anchor" href="#对象的结构"></a> 对象的结构</h2><p>每一个对象中都要保存三种数据<br />id<br />id用来标识对象的唯一性，每一个对象都有位于的id<br />可以通过id( )函数来查看对象的id<br />id是由解析器生成的，在Cpython中，id就是对象的内存地址<br />对象一旦创建，他的id永远不能改变<br />type（类型）<br />类型用来标识当前对象所属的类型比如：int str float bool。。。。<br />类型决定了对象有哪些功能<br />通过type( )函数来查看对象的类型<br />python是一门强类型语言，对象一旦创建便不能修改<br />value( 值 )<br />值就是对象中存储的具体数据<br />对于有些对象值是可以改变的<br />对象可以分为两大类，可变对象  不可变对象<br />可变对象的字可以改变<br />不可变对象的值不能改变，之前血的对象都是不可变对象 int str float bool。。。。</p><h2 id="变量和对象的关系"><a class="markdownIt-Anchor" href="#变量和对象的关系"></a> 变量和对象的关系</h2><p>对象并没有直接存储到变量中，在python中变量更像是给对象起了一个别名<br />变量中存储的不是对象的值，而是对象的id（内存地址）<br />当我们使用变量时就是通过对象的id来查找对象<br />对象中保存的对象id，只有在为变量重新赋值时才会改变<br />变量和变量之间是相互独立的，修改一个变量不会影响另一个变量</p><h2 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h2><p>所谓的类型转换，将一个类型的对象转换为其他对象<br />类型转换不是改变对象本身的类型，而是根据当前对象的值转创建一个新对象<br />类型转换四个函数 int( ) float( ) str( ) bool( )<br />int( )可以用来将其他的对象转换为整型<br />a=True<br />调用int( )将啊转换为整型<br />int( )函数不会对原来的变量产生影响，他是对象转换为指定的类型并将其作为返回值返回<br />如果希望修改原来的变量，则需要对变量进行重新赋值<br />int(a)<br />print(‘a=’,a)<br />print(‘a的类型是’,type(a))</p><p>规则：<br />布尔值：True -&gt;1   False -&gt;0<br />浮点数：直接取整，省略小数点以后的内容  （不四舍五入）a=11.6   a=int(a)   输出11<br />字符串：合法的整数字符串，直接转换为对应数字<br />如果不是合法的整数字符串，则报错   a=‘11.5’   a=int(a)    异常<br />对于其他不可转换为整型的对象，则直接抛异常ValueError       例如：None<br />float( ) 和 int( )基本一致，不同的是它会将对象转换为浮点数<br />str( ) 可以将对象转换为字符串<br />True  -&gt; ‘True’   123 -&gt; ‘123’   …<br />bool( ) 可以将对象转换为布尔值，任何对象都可以转换为布尔值<br />规则：对于所有表示空性的对象都会转换为False，其余全部转换True<br />那些表示空性：0、None、 &quot; &quot; 、 ’ '、  这四种</p><h2 id="运算符操作符"><a class="markdownIt-Anchor" href="#运算符操作符"></a> 运算符（操作符）</h2><p>运算符可以对一个值或多个值进行运算或各种操作<br />比如+、-、=都属于运算符<br />运算符分类：<br /><strong>1.算术运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ 加法运算符（如果是两个字符串进行加法运算，则会进行拼串操作）</span><br><span class="line">      a&#x3D;10+5  计算    或       a&#x3D;&#39;hello&#39;+&#39;  &#39;+&#39;world&#39;   拼串    运行 👉print(&#39;a&#x3D;&#39;,a)</span><br><span class="line"> - 减法运算符（字符串和字符串不能相减</span><br><span class="line"> a&#x3D;10-5       a&#x3D;5-Ture     计算  </span><br><span class="line"> a&#x3D;a-2    用变量a的值减去2，然后再给赋值给a</span><br><span class="line"> * 乘法运算符（如果将字符串和数字相乘，则会对字符串进行赋值操作，将字符串乘法指定次数）</span><br><span class="line"> a&#x3D;5*2</span><br><span class="line"> &#x2F; 除法运算符（运算时结构总会返回一个浮点类型，分母不能为零）</span><br><span class="line"> a&#x3D;10&#x2F;2    </span><br><span class="line"> a&#x3D;5&#x2F;0    报错</span><br><span class="line"> &#x2F;&#x2F; 整除，指挥保留计算和的整数位数，总会返回一个整数型</span><br><span class="line"> a&#x3D;10&#x2F;&#x2F;3  输出a&#x3D;3   输出的值不会四舍五入</span><br><span class="line"> ** 幂运算，就一个值的几次幂</span><br><span class="line"> a&#x3D;2&quot;**&quot;3  (2的3次幂)   print(a)   输出8</span><br><span class="line"> a&#x3D;16&quot;**&quot;0.5    #求16的平方根，相当于根号16  16的二分之一次幂</span><br><span class="line"> % 取模，求两个数相除的余数</span><br><span class="line"> a&#x3D;10%5  #0</span><br><span class="line"> a&#x3D;10%4  #2</span><br><span class="line"> a&#x3D;10%3  #1</span><br><span class="line"> a&#x3D;10%2  #0</span><br></pre></td></tr></table></figure><p><strong>2.赋值运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;可以将等号右侧的值赋值给等号左侧的变量</span><br><span class="line">       a&#x3D;10 </span><br><span class="line"> +&#x3D;     a+&#x3D;5 相当于 a&#x3D;a+5     （以下几个全部类似）         </span><br><span class="line"> -&#x3D;     a-&#x3D;5 相当于 a&#x3D;a-5</span><br><span class="line"> *&#x3D;     a*&#x3D;5 相当于 a&#x3D;a*5</span><br><span class="line"> **&#x3D;   a**&#x3D;5 相当于 a&#x3D;a**5   （a的5次方）</span><br><span class="line"> &#x2F;&#x3D;     a&#x2F;&#x3D;5 相当于 a&#x3D;a&#x2F;5    （在对浮点数做算术运算时结果也会返回一个浮点数）</span><br><span class="line"> &#x2F;&#x2F;&#x3D;     a&#x2F;&#x2F;&#x3D;5 相当于 a&#x3D;a&#x2F;&#x2F;5</span><br><span class="line"> %&#x3D;     a%&#x3D;5 相当于 a&#x3D;a%5</span><br></pre></td></tr></table></figure><p><strong>3.比较运算符（关系运算符）</strong><br />关系运算符用来比较两个值之间的关系，总会返回一个布尔值，如果关系成立返回True否则返回False<br />&gt;     比较左侧之是否大于右侧值    result=5&gt;3    print(‘result =’,result)    #True<br />&gt;=   比较左侧值是否大于或等于右侧值       result=5&gt;=5   #True<br />&lt;       比较右侧之是否大于左侧值<br />&lt;=    比较右侧值是否大于或等于左侧值<br />==    比较两个对象的值是否相等    两个值相等返回True<br />!=     比较两个对象的值是否不相等，两个值不相等返回True<br />相等和不等比较的是对象的值，而不是id<br />i s  比较两个对象是否是同一个对象，比较的是对象的id<br />i s not  比较两个对象是否不是同一个对象，比较的是对象的id<br />在python中可以对两个字符串进行大于 (等于)或小于(等于)的运算<br />当对字符串进行比较时，实际上比较的是字符串的Unicode编码<br />result=‘a’&gt;‘b’  相当于   0061&gt;0062   False<br />比较两个字符串的Unicode编码时，是逐位比较的<br />result=‘abc’&gt;‘bcd’    比较规则是逐位比较  左a和右b比较，从第一位比较能比出大小就不再向后比较<br />利用该特性可以对字符串按照字母顺序进行排序，但是对于中文来说意义不是特别大<br />主要：如果不希望比较两个字符串的Unicode编码，则需要将其转换为数字在比较</p><p><strong>4.逻辑运算符</strong><br />逻辑运算符主要用来做一些逻辑判断<br /><strong>not 逻辑非</strong><br />not可以对符号右侧的值进行非运算<br />对于布尔值，非运算会对其进行取反操作，True变False ，False变True<br />对于非布尔值，非运算会将其先转换为布尔值，然后在取反<br />a=True         a=not a   #对a进行取反<br /><strong>and 逻辑与</strong><br />and可以对符号两边的值进行与运算<br />只有在符号两侧的值都为True时，才会返回True，只要有一个False就返回False<br />与运算时找False，有false不会执行<br />python中的与运算是短路的与，如果第一个值为false，则不会再看第二个值<br />result=True and True    #True<br />result=True and  False  #False<br />result=False and True   #False<br />result=False and False   #False<br />True and print(‘你猜我出来吗？’) 第一个值是True，会看第二个值，所以print()会执行<br />False and print(‘你猜我出来吗？’)第一个值是False，不会看第二个值，所以print()不会执行<br /><strong>or 逻辑或</strong><br />or可以对符号两侧的值进行或运算<br />或运算是找True的<br />Python中的或运算是短路的或，如果第一个值为True，则不再看第二个值<br />result=True or True    #True<br />result=True or  False  #True<br />result=False or True   #True<br />result=False or False  #False<br />print(result)<br />False or print(‘你猜我出来吗？’) 第一个值为False，继续看第二个，所以打印语句执行<br />True or print(‘你猜我出来吗？’) 第一个值为True，不看第二个，所以打印语句不执行</p><p><strong>非布尔值的与或运算</strong><br />当我们对非布尔值进行与或运算时，python会将其当做布尔值运算，最终会返回原值<br />与运算的规则<br />与运算是找False的，如果第一个值是False，则不看第二个值<br />如果第一个值是False，则直接返回第一个值，否则返回第二个值</p><p>或运算时找True的，如果第一个值是True，则不看第二个值<br />如果第一个值是True，则直接返回第一个值，否则返回第二个值<br />逻辑运算符（补充）<br />逻辑运算符可以连着使用<br />result = 1 &lt; 2 &lt; 3 # 相当于 1 &lt; 2 and 2 &lt; 3<br />result = 10 &lt; 20 &gt; 15  #相当于 10&lt;20  and  15&lt;20<br />print(result)</p><p><strong>5.条件运算符（三元运算符）</strong><br />语法：语句1  if  条件表达式  else  语句2<br />执行流程：<br />条件运算符在执行时，会先对条件表达式进行求值判断<br />如果判断结果为True，则执行语句1，并返回执行结果<br />如果判断结果为False，则执行语句2，并返回执行结果</p><pre class="highlight"><code class="python">a=<span class="hljs-number">40</span>   b=<span class="hljs-number">20</span>c=<span class="hljs-number">30</span>max=a <span class="hljs-keyword">if</span> a&gt;b <span class="hljs-keyword">else</span> bmax=max <span class="hljs-keyword">if</span>  max&gt;c <span class="hljs-keyword">else</span> cprint(max)</code></pre><h2 id="运算符的优先级"><a class="markdownIt-Anchor" href="#运算符的优先级"></a> 运算符的优先级</h2><p>和数学中一样，在python运算也有优先级，比如先乘除后加减<br />运算符的优先级可以根据优先级的表格来查询<br />在表格中位置越靠下的运算符优先等级越高，优先级越高就越优先计算<br />如果优先级一样则自左向右计算<br />关于优先级的表格只知道有就行不用特意全背下来<br />在开发中如果遇到优先级不清楚的，可以通过小括号来改变运算顺序</p><p><strong>and</strong>的优先级高，则应该先计算与运算<br />则运算结果是1<br />a = 1 or 2 and 3</p><p>print(a)</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习--计算机基础知识</title>
      <link href="2020/07/01/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>2020/07/01/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0--%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="课程介绍"><a class="markdownIt-Anchor" href="#课程介绍"></a> 课程介绍</h2><p>课程名称：python基础教程<br />本文为个人笔记，相关视频请看<a href="http://www.atguigu.com/">尚硅谷官网</a>或<a href="https://space.bilibili.com/302417610?from=search&amp;seid=10052146062514960450">bilibili尚硅谷官方号</a><br />学习方法：认真听讲，多敲代码。<br />必备技能：<br />①计算机基础操作<br />②打字速度<br />③英语（能阅读基本的英文文档）</p><h2 id="计算机是什么"><a class="markdownIt-Anchor" href="#计算机是什么"></a> 计算机是什么</h2><p>电脑  笔记本电脑  手机  游戏机  智能电视。。。。<br />计算机就是一个用来计算的机器。<br />目前来讲，计算机只能根据人类的指令来完成各种操作<br />所以我们学习计算机，就是学习如何控制计算机。</p><h2 id="计算机的组成"><a class="markdownIt-Anchor" href="#计算机的组成"></a> 计算机的组成</h2><p>计算机的组成：硬件和软件<br />硬件包括：CPU  显卡  硬盘  内存  主板。。。<br />硬件是看得见摸得着的<br />软件包括：系统软件（Linux  Windows。。）和应用软件（steamoffice  sublime。。。）<br />软件负责控制计算机的硬件</p><h2 id="计算机的使用方式"><a class="markdownIt-Anchor" href="#计算机的使用方式"></a> 计算机的使用方式</h2><p>用户必须要通过软件来对计算机完成各种操作<br />但不是所有的功能都会对用户开放<br />用户需要调用软件提供的接口（interface 交互界面）来操作计算机</p><pre><code>用户界面分为两种：TUI（文本交互界面）和GUI（图形花交互界面）         </code></pre><h2 id="windows的命令行"><a class="markdownIt-Anchor" href="#windows的命令行"></a> Windows的命令行</h2><p>命令行就是文本交换界面，通过命令行可以使用指令来操作计算机<br />任何计算机都包含命令行<br />命令行有多个不同名字：<br />命令行、命令行窗口、DOS窗口、命令提示符、终端。。。。<br />1.如何进入到命令行<br />略。。。：）<br />2.命令行结构（没什么用）<br />-版本及版本声明<br />Microsoft Windows [版本 10.0.18363.535]<br />© 2019 Microsoft Corporation。保留所有权利。<br />-命令提示符<br />C:\Users\用户名&gt;<br />C:<br />-当前所在的磁盘根目录<br />-可以通过x：来切换盘符（x：表示你的盘符）<br />\Users\用户名&gt;<br />-所在磁盘的路径，当前所在文件夹<br />&gt;<br />-命令提示符，在大于号后边可以直接输入指令<br />3.常用的DOS命令<br />dir  查看当前目录下的文件或夹<br />cd进入到指定的目录<br />rd删除一个目录<br />cls清除屏幕<br />del删除一个文件<br />tab键命令自动补全</p><pre><code>                命令的语法                 命令 [参数]  [选项]</code></pre><h2 id="环境变量enviroment-variable"><a class="markdownIt-Anchor" href="#环境变量enviroment-variable"></a> 环境变量(enviroment variable)</h2><p>环境变量指的是操作系统中的一些变量。<br />可以通过修改环境变量，来对计算机进行配置（主要来配置一些路径）<br />1.查看环境变量<br />&gt;右键  计算机，选择属性<br />&gt;系统界面左侧选择  高级系统设置<br />&gt;选择环境变量<br />环境变量界面分成了两部分，上边是用户环境变量，下边是系统环境变量<br />建议只修改用户环境变量，不要修改系统环境变量。</p><p>2.添加环境变量<br />&gt;通过新建  输入变量和值<br />&gt;一个环境变量可以有很多值，值与值之间用  ;(英文)隔开<br />3.修改环境变量<br />&gt;通过编辑按钮来修改环境变量<br />4.删除环境变量<br />&gt;通过删除按钮来删除环境变量</p><h2 id="path环境变量"><a class="markdownIt-Anchor" href="#path环境变量"></a> path环境变量</h2><p>path环境变量中保存的是一个一个的路径。<br />当我们在命令行中输入一个命令（或访问一个文件），<br />系统会首先在当前目录下寻找，如果找到了则直接打开或执行<br />如果没有找到，则会依次去path环境变量的路径中寻找，直到找到为止<br />如果path环境变量中的路径都没找到则会报错<br />我们可以将经常用到的文件的路径添加到path环境变量中，这样就可以在任意位置访问这些文件</p><pre><code> 注意事项：   1.如果环境变量中没有path，可以手动添加   2.path环境变量不区分大小写  PATH  Path  path   3.修改完环境变量必须重新启动命令行窗口   4.多个路径之间使用 ; (英文)隔开</code></pre><h2 id="进制"><a class="markdownIt-Anchor" href="#进制"></a> 进制</h2><p>-十进制(最常用的)<br />-十进制就是满十进一的进制<br />-十进制中共有10个数字<br />0 1 2 3 4 5 6 7 8 9</p><p>-二进制(计算机底层使用的进制)<br />-满二进一<br />-二进制中一共有两个数字<br />0 1<br />-二进制如何计数<br />0  1  10  11  100  101  110  111<br />-计算机只认识二进制<br />-bit是计算机中的最小的单位1bit（1位）<br />byte是我们最小的可操作的单位</p><pre><code>       8bit=1byte（字节）       1024byte=1kb（千字节）                       。                       。                       。👇↓</code></pre><p>-八进制（一般不用）<br />-满八进一<br />-八进制中一共有8个数字<br />0 1 2 3 4 5 6 7<br />-八进制如何计数<br />0  1  2  3  4  5  6  7  10  11 。。。17  20  21</p><p>-十六进制<br />-满十六进一<br />-十六进制中共有16个数字<br />0 1 2 3 4 5 6 7 8 9 a b c d e f<br />-十六进制如何计数<br />。。。。7 8 9 a b c d e f</p><p>##文本文件和字符集<br />-文本分为两种，一种叫纯文本，还有一种叫富文本<br />-纯文本中只能保存单一的文本内容，无法报仇呢内容无关的东西（字体 颜色  图片。。）<br />-富文本中可以保存文本以外的内容（word文档）<br />-在开发时，编写程序使用的全都是纯文本<br />-纯文本在计算机底层也会转换为二进制保存，<br />将字符转换为二进制码的过程称为编码<br />将二进制码转换为字符的过程称为解码<br />编码和解码时所采用的规则称为字符集<br />-常见字符集<br />ASCII<br />-美国人编码，使用7位来对美国常用的字符进行编码<br />-包含128个字符<br />ISO-8859-1<br />-欧洲的编码，使用8位<br />-包含128个字符<br />GB2312<br />GBK<br />-国标码，中国的编码<br />Unicode<br />-万国码，包含世界上 所有的语言符号，在编谢程序时一般都会用Unicode编码<br />Unicode编码有多种实现，UTF-8 、UTF-16 、UTF-32<br />-乱码<br />编写程序时，如果发现程序代码出现乱码的情况，就要马上去检查字符集是否正确</p><h2 id="sublime-text-3"><a class="markdownIt-Anchor" href="#sublime-text-3"></a> Sublime Text 3</h2><p>-软件安装，根据系统类型安装相应版本，路径尽量减少应用中文<br />-纯文本编辑器<br />-Package Control （Sublime的爆管理器，可见视频009）<br />-Sublime Text 3中的插件，通过该插件可以向Sublime中安装的包<br />-安装主题（尚硅谷视频010）</p>]]></content>
      
      
      <categories>
          
          <category> python基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客定制--4.主题配置</title>
      <link href="2020/06/30/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--4.%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>2020/06/30/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--4.%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="语言设置"><a class="markdownIt-Anchor" href="#语言设置"></a> 语言设置</h2><p>修改博客根目录下的_config.yml文件,修改language为zh-CN：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Site</span></span><br><span class="line">title: 一本正经</span><br><span class="line">subtitle: <span class="string">&#x27;&#x27;</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span></span><br><span class="line">keywords:</span><br><span class="line">author: The Kun</span><br><span class="line">language: zh-CN   <span class="comment">#有三种语言可选英文en、简中zh-CN、繁中zh-TW</span></span><br><span class="line">timezone: <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>不过在修改为简体中文后，hexo gen生成博客时命令行或出现一处报错，这个没有影响。<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711223632547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h2 id="代码复制"><a class="markdownIt-Anchor" href="#代码复制"></a> 代码复制</h2><p>配置主题配置文件，highlight_copy 设置为true。</p><h2 id="社交图标"><a class="markdownIt-Anchor" href="#社交图标"></a> 社交图标</h2><p>配置主题配置文件，fontawesome_v5 的 enable 改为 true。<br />继续找到social，前面蓝绿色的为图标名，例如：iconfont icon-bilibili card_icon<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711224315104.png#pic_center" alt="" /><br />图标可以去<a href="https://www.iconfont.cn/">阿里矢量图标库</a>去找自己喜欢的图标。</p><h2 id="阿里矢量图标库"><a class="markdownIt-Anchor" href="#阿里矢量图标库"></a> 阿里矢量图标库</h2><h3 id="下载图标"><a class="markdownIt-Anchor" href="#下载图标"></a> 下载图标</h3><p>进入<a href="https://www.iconfont.cn/">阿里矢量图标库</a>，点击图标库搜索需要的图标，例如：bilibili。找到喜欢的添加入库，可以一次添加多个。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200712160100673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />然后点浏览器右上角的购物车选择添加项目（没有项目就创建一个），进入项目选择<br />Font class 再点击查看在线连接，然后点击“暂无代码，点此生成”<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020071216212048.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />复制代码到浏览器，下边红圈就是要引入的样式。<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200712162607348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />选中复制所有代码保存到\themes\butterfly\source\css\iconfont.css文件下（iconfont.css要自己创建），就如红圈内所示，可以修改图标颜色和大小。我这里是添加了三个。<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200712163350178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h3 id="引入图标"><a class="markdownIt-Anchor" href="#引入图标"></a> 引入图标</h3><p>在butterfly.yml文件里找到inject，输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/css/iconfont.css&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200712164206589.png#pic_center" alt="" /><br />最后在使用这个图标的地方输入图标名就可以了，格式：<strong>iconfont 图标名 card_icon:</strong><br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200712164700624.png#pic_center" alt="" /><br />效果图：<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200712164849669.png#pic_center" alt="" /></p><h2 id="主页文章节选"><a class="markdownIt-Anchor" href="#主页文章节选"></a> 主页文章节选</h2><p>本主题只支持自动节选和文章页description</p><ul><li>description 只显示description</li><li>both 优先选择description，如果没有配置description，则显示自动节选的內容</li><li>auto_excerpt 只显示自动节选<br />配置butterfly.yml</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index_post_content:</span><br><span class="line">  method: 3</span><br><span class="line">  length: 500 <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><p>然后再需要节选的文章的front-matter里添加description。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711230310379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h2 id="顶部图"><a class="markdownIt-Anchor" href="#顶部图"></a> 顶部图</h2><p>下图可以看到我只设置了三个图片路径，首页和时间轴的顶部图可以在butterfly.yml文件设置。如果页面的front-matter里没设置top_img，那么没设置top_img的页面全部显示default_top_img设置的图片。可以参考上个图片的di8行。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711230641526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /></p><h2 id="文章封面"><a class="markdownIt-Anchor" href="#文章封面"></a> 文章封面</h2><p>参考上面主页文章节选的插图，在front-matter添加一个cover并配置图片路径。<br />如果不想再首页展示封面图，可以在butterfly.yml配置cover改为false。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否顯示文章封面</span></span><br><span class="line">index_enable: <span class="literal">true</span></span><br><span class="line">aside_enable: <span class="literal">true</span></span><br><span class="line">archives_enable: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 封面顯示的位置</span></span><br><span class="line"><span class="comment"># 三個值可配置 left , right , both</span></span><br><span class="line">position: both</span><br><span class="line"><span class="comment"># 當沒有設置cover時，默認的封面顯示</span></span><br><span class="line">default_cover:   <span class="comment">#配置多张图片时添加</span></span><br><span class="line">    - https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg</span><br></pre></td></tr></table></figure><h2 id="文章版权"><a class="markdownIt-Anchor" href="#文章版权"></a> 文章版权</h2><h3 id="文章版权-2"><a class="markdownIt-Anchor" href="#文章版权-2"></a> 文章版权</h3><p>配置butterfly.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  decode: <span class="literal">true</span></span><br><span class="line">  license: CC BY-NC-SA 4.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/</span><br><span class="line">  copyright_text: 作者拥有版权，请注明出处转载。</span><br></pre></td></tr></table></figure><p>如果有文章被转载不需要提示版权，可以在文章的Front-matter单独设置.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyright: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="文章打赏"><a class="markdownIt-Anchor" href="#文章打赏"></a> 文章打赏</h3><p>配置butterfly.yml文件，img写上保存好的收款码图片的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reward:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  QR_code:</span><br><span class="line">    - img: /image/wechat.jpg</span><br><span class="line">      link:</span><br><span class="line">      text: 微信</span><br><span class="line">    - img: /image/alipay.jpg</span><br><span class="line">      link:</span><br><span class="line">      text: 支付宝</span><br></pre></td></tr></table></figure><h2 id="footer-设置"><a class="markdownIt-Anchor" href="#footer-设置"></a> Footer 设置</h2><h3 id="博客年份"><a class="markdownIt-Anchor" href="#博客年份"></a> 博客年份</h3><p>配置butterfly.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">since: 2020</span><br></pre></td></tr></table></figure><p>效果图：（红心和第三行的英文是后加的）<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711233457732.png#pic_center" alt="" /></p><h3 id="跳动的小红心"><a class="markdownIt-Anchor" href="#跳动的小红心"></a> 跳动的小红心</h3><p>打开 <strong>/themes/butterfly/layout/includes/footer.pug</strong> 文件<br />①将以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;<span class="variable">$&#123;theme.since&#125;</span> - <span class="variable">$&#123;nowYear&#125;</span> By <span class="variable">$&#123;config.author&#125;</span></span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;<span class="variable">$&#123;theme.since&#125;</span> - <span class="variable">$&#123;nowYear + &#x27; &#x27;&#125;</span> &lt;i id=<span class="string">&quot;heartbeat&quot;</span> class=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;&lt;/i&gt; <span class="variable">$&#123;config.author&#125;</span></span><br></pre></td></tr></table></figure><p>②将以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;<span class="variable">$&#123;nowYear&#125;</span> By <span class="variable">$&#123;config.author&#125;</span> </span><br></pre></td></tr></table></figure><p>更改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;<span class="variable">$&#123;nowYear + &#x27; &#x27;&#125;</span> &lt;i id=<span class="string">&quot;heartbeat&quot;</span> class=<span class="string">&quot;fa fas fa-heartbeat&quot;</span>&gt;&lt;/i&gt; <span class="variable">$&#123;config.author&#125;</span></span><br></pre></td></tr></table></figure><p>③将以下内容添加到代码最下边</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css&quot;</span>&gt;&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>参考下图：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020072012245134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />最终效果：<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720122519404.png" alt="" /></p><h3 id="footer_custom_text"><a class="markdownIt-Anchor" href="#footer_custom_text"></a> footer_custom_text</h3><p>在butterfly.yml文件里找到footer_custom_text ，在冒号后输入（内容自选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">footer_custom_text: Hi, welcome to my blog</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200720122755448.png" alt="效果图" /></p><h2 id="右下角设置"><a class="markdownIt-Anchor" href="#右下角设置"></a> 右下角设置</h2><h3 id="简繁转换"><a class="markdownIt-Anchor" href="#简繁转换"></a> 简繁转换</h3><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711233638696.png#pic_center" alt="" /><br />配置butterfly.yml文件,改为下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####   右下角按鈕  ####</span></span><br><span class="line"><span class="comment">#----------------------------------------------</span></span><br><span class="line"><span class="comment"># 簡繁轉換</span></span><br><span class="line">translate:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 默認按鈕顯示文字</span></span><br><span class="line">  default: 简</span><br><span class="line">  <span class="comment">#網站默認語言，1: 繁體中文, 2: 簡體中文</span></span><br><span class="line">  defaultEncoding: 2</span><br><span class="line">  <span class="comment">#延遲時間,若不在前, 要設定延遲翻譯時間, 如100表示100ms,默認為0</span></span><br><span class="line">  translateDelay: 0</span><br><span class="line">  <span class="comment">#博客網址</span></span><br><span class="line">  cookieDomain: <span class="string">&#x27;https://xxx/&#x27;</span></span><br><span class="line">  <span class="comment">#當文字是簡體時，按鈕顯示的文字</span></span><br><span class="line">  msgToTraditionalChinese: <span class="string">&#x27;繁&#x27;</span></span><br><span class="line">  <span class="comment">#當文字是繁體時，按鈕顯示的文字</span></span><br><span class="line">  msgToSimplifiedChinese: <span class="string">&#x27;简&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="夜间模式和阅读模式"><a class="markdownIt-Anchor" href="#夜间模式和阅读模式"></a> 夜间模式和阅读模式</h3><p>配置butterfly.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阅读模式</span></span><br><span class="line">readmode:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dark mode  （夜间模式）</span></span><br><span class="line">darkmode:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># dark mode和 light mode切換按鈕</span></span><br><span class="line">  button: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 自動切換 dark mode和 light mode</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 1  跟隨系統而變化，不支持的瀏覽器/系統將按照時間晚上6點到早上6點之間切換為 dark mode</span></span><br><span class="line">  <span class="comment"># autoChangeMode: 2  只按照時間晚上6點到早上6點之間切換為 dark mode</span></span><br><span class="line">  <span class="comment"># autoChangeMode: false 取消自動切換</span></span><br><span class="line">  autoChangeMode: 1</span><br></pre></td></tr></table></figure><h2 id="侧边栏设置"><a class="markdownIt-Anchor" href="#侧边栏设置"></a> 侧边栏设置</h2><h3 id="侧边栏排版"><a class="markdownIt-Anchor" href="#侧边栏排版"></a> 侧边栏排版</h3><p>配置butterfly.yml,可以调整代码上下顺序来改变页面显示的上下顺序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">aside:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  mobile: <span class="literal">true</span>    <span class="comment"># 手機頁面（ 顯示寬度 &lt; 768px ）是否顯示aside內容</span></span><br><span class="line">  position: right   <span class="comment"># 设置在左边还是右边 </span></span><br><span class="line">  card_author:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    description:</span><br><span class="line">  card_announcement:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    content: This is my Blog</span><br><span class="line">  card_recent_post:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="built_in">limit</span>: 5 <span class="comment"># if set 0 will show all</span></span><br><span class="line">  card_categories:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="built_in">limit</span>: 8 <span class="comment"># if set 0 will show all</span></span><br><span class="line">    expand: none <span class="comment"># none/true/false</span></span><br><span class="line">  card_tags:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="built_in">limit</span>: 40 <span class="comment"># if set 0 will show all</span></span><br><span class="line">    color: <span class="literal">false</span></span><br><span class="line">  card_archives:</span><br><span class="line">    <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="built_in">type</span>: monthly <span class="comment"># yearly or monthly</span></span><br><span class="line">    format: MMMM YYYY <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    order: -1 <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="built_in">limit</span>: 8 <span class="comment"># if set 0 will show all</span></span><br><span class="line">  card_webinfo: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="访问人数"><a class="markdownIt-Anchor" href="#访问人数"></a> 访问人数</h3><p>配置butterfly.yml。<a href="http://busuanzi.ibruce.info/">不蒜子官网</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">busuanzi:</span><br><span class="line">  site_uv: <span class="literal">true</span></span><br><span class="line">  site_pv: <span class="literal">true</span></span><br><span class="line">  page_pv: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="运行时间"><a class="markdownIt-Anchor" href="#运行时间"></a> 运行时间</h3><p>配置butterfly.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtimeshow:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  publish_date: 6/7/2018 00:00:00  </span><br><span class="line">  <span class="comment">##網頁開通時間</span></span><br><span class="line">  <span class="comment">#格式: 月/日/年 時間</span></span><br><span class="line">  <span class="comment">#也可以寫成 年/月/日 時間</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客定制--3.主题页面</title>
      <link href="2020/06/29/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--3.%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2/"/>
      <url>2020/06/29/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--3.%E4%B8%BB%E9%A2%98%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="导航栏菜单"><a class="markdownIt-Anchor" href="#导航栏菜单"></a> 导航栏菜单</h2><p>打开butterfly.yml,这里的文字可以自行修改。<br />格式：菜单名: 路径 || 图标名 （图标可以去<a href="https://www.iconfont.cn/">阿里矢量图库</a>找自己喜欢的，怎么添加后边会讲）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  Home: / || fa fa-home</span><br><span class="line">  Archives: /archives/ || fa fa-archive</span><br><span class="line">  Tags: /tags/ || fa fa-tags</span><br><span class="line">  Categories: /categories/ || fa fa-folder-open</span><br><span class="line">  Link: /link/ || fa fa-link</span><br><span class="line">  About: /about/ || fa fa-heart</span><br><span class="line">  List||fa fa-list:</span><br><span class="line">    - Music || /music/ || fa fa-music</span><br><span class="line">    - Movie || /movies/ || fa fa-film</span><br></pre></td></tr></table></figure><p>自行修改汉化为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首页: / || fa fa-home</span><br><span class="line">  时间轴: /archives/ || fa fa-archive</span><br><span class="line">  标签: /tags/ || fa fa-tags</span><br><span class="line">  分类: /categories/ || fa fa-folder-open</span><br><span class="line">  清单||fa fa-heartbeat:</span><br><span class="line">    - 音乐 || /music/ || fa fa-music</span><br><span class="line">    - 照片 || /Gallery/ || fa fa-picture-o</span><br><span class="line">    - 电影 || /movies/ || fa fa-film</span><br><span class="line">  友链: /link/ || fa fa-link</span><br><span class="line">  关于: /about/ || fa fa-heart</span><br></pre></td></tr></table></figure><h2 id="front-matter"><a class="markdownIt-Anchor" href="#front-matter"></a> Front-matter</h2><p>Front-matter是文档最上方以 — 分隔的区域，用于指定个别档案的变数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated: </span><br><span class="line"><span class="built_in">type</span>: </span><br><span class="line">comments: </span><br><span class="line">description: </span><br><span class="line">keywords: </span><br><span class="line">top_img: </span><br><span class="line">mathjax: </span><br><span class="line">katex: </span><br><span class="line">aside: </span><br><span class="line">aplayer：</span><br><span class="line">highlight_shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】页面标题</td></tr><tr><td>date</td><td>【必需】页面创建日期</td></tr><tr><td>type</td><td>【必需】标签、分类和友情链接三个页面需要配置</td></tr><tr><td>updated</td><td>【可选】页面更新日期</td></tr><tr><td>description</td><td>【可选】页面描述</td></tr><tr><td>keywords</td><td>【可选】页面关键字</td></tr><tr><td>comments</td><td>【可选】显示页面评论模块(默认true)</td></tr><tr><td>top_img</td><td>【可选】页面顶部图片</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认false)</td></tr><tr><td>aside</td><td>【可选】显示侧边栏(默认true)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音樂配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h2 id="post-front-matter"><a class="markdownIt-Anchor" href="#post-front-matter"></a> Post Front-matter</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">updated: </span><br><span class="line">tags: </span><br><span class="line">categories: </span><br><span class="line">keywords: </span><br><span class="line">description: </span><br><span class="line">top_img: </span><br><span class="line">comments：</span><br><span class="line">cover:   </span><br><span class="line">toc:   </span><br><span class="line">toc_number: </span><br><span class="line">auto_open: </span><br><span class="line">copyright: </span><br><span class="line">mathjax: </span><br><span class="line">katex: </span><br><span class="line">aplayer：</span><br><span class="line">highlight_shrink：</span><br><span class="line">---</span><br></pre></td></tr></table></figure><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>【必需】文章标题</td></tr><tr><td>date</td><td>【必需】文章创建日期</td></tr><tr><td>updated</td><td>【可选】文章更新日期</td></tr><tr><td>tags</td><td>【可选】文章标签</td></tr><tr><td>categories</td><td>【可选】文章分类</td></tr><tr><td>keywords</td><td>【可选】文章关键字</td></tr><tr><td>description</td><td>【可选】文章描述</td></tr><tr><td>top_img</td><td>【可选】文章顶部图片</td></tr><tr><td>cover</td><td>【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</td></tr><tr><td>comments</td><td>【可选】显示文章评论模块(默认true)</td></tr><tr><td>toc</td><td>【可选】显示文章TOC(默认为设置中toc的enable配置)</td></tr><tr><td>toc_number</td><td>【可选】显示toc_number(默认为设置中toc的number配置)</td></tr><tr><td>auto_open</td><td>【可选】是否自动打开TOC(默认为设置中toc的auto_open配置)</td></tr><tr><td>copyright</td><td>【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)</td></tr><tr><td>mathjax</td><td>【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认false)</td></tr><tr><td>katex</td><td>【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认false)</td></tr><tr><td>aplayer</td><td>【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音樂配置</td></tr><tr><td>highlight_shrink</td><td>【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置)</td></tr></tbody></table><h2 id="创建页面"><a class="markdownIt-Anchor" href="#创建页面"></a> 创建页面</h2><p>打开 gitbash 并切换到你的博客根目录下.<br />可以根据自己需求自行添加、删除或修改页面。</p><h3 id="时间轴页"><a class="markdownIt-Anchor" href="#时间轴页"></a> 时间轴页</h3><ol><li>在命令行输入 hexo new page archives</li><li>你会在source/archives/index.md</li><li>手动修改这个文件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 时间轴</span><br><span class="line">date: 2020/7/9</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;archives&quot;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="标签页"><a class="markdownIt-Anchor" href="#标签页"></a> 标签页</h3><ul><li>在命令行输入hexo new page tags</li><li>找到source/tags/index.md文件</li><li>修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">title:标签</span><br><span class="line">date: 2020/7/9</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span> </span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="友情链接"><a class="markdownIt-Anchor" href="#友情链接"></a> 友情链接</h3><h4 id="创建界面"><a class="markdownIt-Anchor" href="#创建界面"></a> 创建界面</h4><ul><li>在命令行输入hexo new page link</li><li>找到source/link/index.md文件</li><li>修改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--- </span><br><span class="line">title:友情链接</span><br><span class="line">date: 2020/7/9</span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;link&quot;</span> </span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="友情链接添加"><a class="markdownIt-Anchor" href="#友情链接添加"></a> 友情链接添加</h4><p>打开你的博客根目录下的source文件夹内打开_data ,创建一个link.yml文件，把下面的文字复制进去，根据需求自行修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- class_name: 友情链接</span><br><span class="line">  class_desc: 那些人，那些事</span><br><span class="line">  link_list:</span><br><span class="line">    - name: JerryC</span><br><span class="line">      link: https://jerryc.me/</span><br><span class="line">      avatar: https://jerryc.me/image/avatar.png</span><br><span class="line">      descr: 今日事,今日毕</span><br><span class="line">    - name: Hexo</span><br><span class="line">      link: https://hexo.io/zh-tw/</span><br><span class="line">      avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span><br><span class="line">      descr: 快速、简单且强大的网络框架</span><br><span class="line"></span><br><span class="line">- class_name: 网站</span><br><span class="line">  class_desc: 值得推广的网站</span><br><span class="line">  link_list:</span><br><span class="line">    - name: Youtube</span><br><span class="line">      link: https://www.youtube.com/</span><br><span class="line">      avatar: https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span><br><span class="line">      descr: 视频网站</span><br><span class="line">    - name: Weibo</span><br><span class="line">      link: https://www.weibo.com/</span><br><span class="line">      avatar: https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span><br><span class="line">      descr: 中国最大社交分享平台</span><br><span class="line">    - name: Twitter</span><br><span class="line">      link: https://twitter.com/</span><br><span class="line">      avatar: https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span><br><span class="line">      descr: 社交分享平台</span><br></pre></td></tr></table></figure><h3 id="音乐"><a class="markdownIt-Anchor" href="#音乐"></a> 音乐</h3><h4 id="页面创建"><a class="markdownIt-Anchor" href="#页面创建"></a> 页面创建</h4><ul><li>直接在命令行输入：<strong>hexo new page music</strong></li></ul><p>命令行输入以下代码，安装<a href="https://github.com/MoePlayer/hexo-tag-aplayer">aplayer插件</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711213308789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />enable改为true，id输入你的网易云id，用浏览器登陆就能看见，其他设置根据自己喜好。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200711213533627.png#pic_center" alt="" /></p><h3 id="电影"><a class="markdownIt-Anchor" href="#电影"></a> 电影</h3><ul><li>安装豆瓣插件 <a href="https://github.com/mythsman/hexo-douban">hexo-douban</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure><ul><li>更新豆瓣插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-douban --update --save</span><br></pre></td></tr></table></figure><p>然后修改主题配置文件的douban,改为true：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 如果你有使用hexo-douban，可配置這個</span><br><span class="line">douban:</span><br><span class="line">  meta: true</span><br><span class="line">  movies_img: </span><br><span class="line">  books_img: </span><br><span class="line">  # games_img: </span><br></pre></td></tr></table></figure><p>将下面的配置写入_config.yml文件（不是主题配置文件）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">douban:</span><br><span class="line">  user: mythsman  <span class="comment">#你的豆瓣id，位置和音乐的一样</span></span><br><span class="line">  <span class="built_in">builtin</span>: <span class="literal">false</span>   <span class="comment">#改为true</span></span><br><span class="line">  book:</span><br><span class="line">    title: <span class="string">&#x27;This is my book title&#x27;</span></span><br><span class="line">    quote: <span class="string">&#x27;This is my book quote&#x27;</span></span><br><span class="line">  movie:</span><br><span class="line">    title: <span class="string">&#x27;This is my movie title&#x27;</span></span><br><span class="line">    quote: <span class="string">&#x27;This is my movie quote&#x27;</span></span><br><span class="line">  game:     </span><br><span class="line">    title: <span class="string">&#x27;This is my game title&#x27;</span></span><br><span class="line">    quote: <span class="string">&#x27;This is my game quote&#x27;</span></span><br><span class="line">  timeout: 10000 </span><br></pre></td></tr></table></figure><p>注意：通常大家都喜欢用hexo d来作为hexo deploy命令的简化，但是当安装了hexo douban之后，就不能用hexo d了，因为hexo douban跟hexo deploy的前缀都是hexo d。<br />可以使用hexo gen 、 hexo se 、hexo de来操作。<br />可以通过hexo help来查询命令全称。</p><h3 id="404界面"><a class="markdownIt-Anchor" href="#404界面"></a> 404界面</h3><p>在主题配置文件里找到 error_404,把false改为true<br />图片在themes\butterfly\source\img文件夹下</p><h3 id="修改头像"><a class="markdownIt-Anchor" href="#修改头像"></a> 修改头像</h3><p>在主题配置文件里找到 avatar ，在img处输入图片路径。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客定制--2.主题安装</title>
      <link href="2020/06/28/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--2.%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85/"/>
      <url>2020/06/28/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--2.%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="安装主题"><a class="markdownIt-Anchor" href="#安装主题"></a> 安装主题</h2><p>安装准备：<br />打开git bash 切换到你的博客根目录。</p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><h6 id="稳定版建议"><a class="markdownIt-Anchor" href="#稳定版建议"></a> 稳定版（建议）</h6><p>在命令行里输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> master https://github.com/jerryc127/hexo<span class="literal">-theme</span><span class="literal">-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><h6 id="测试版"><a class="markdownIt-Anchor" href="#测试版"></a> 测试版</h6><p>如果想要安装比较新的dev分支，可以：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone <span class="literal">-b</span> dev https://github.com/jerryc127/hexo<span class="literal">-theme</span><span class="literal">-butterfly</span>.git themes/butterfly</span><br><span class="line">```powershell</span><br><span class="line">git clone <span class="literal">-b</span> dev https://github.com/jerryc127/hexo<span class="literal">-theme</span><span class="literal">-butterfly</span>.git themes/butterfly</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h3><p>安装完主题后，在你的博客根目录的themes文件夹下会多一个hexo-theme-butterfly文件夹，把这给文件夹改名为butterfly。然后把butterfly文件夹下的_config.yml文件复制到博客根目录的source/_data文件夹下（_data文件夹没有要自己创建）并把复制过来的_config.yml改名为butterfly，如图：<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/2020071021285687.PNG#pic_center" alt="              " /><br />#以后大部分的主题修改全是修改这个文件。</p><h3 id="应用主题"><a class="markdownIt-Anchor" href="#应用主题"></a> 应用主题</h3><p>打开博客根目录的_config.yml文件（不是主题目录的，也不是上面复制到的），<br />往下拉找到<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200710213736512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70#pic_center" alt="" /><br />repo后边填写你的GitHub的用户名，其他按照图上改就可以<br />注意：所有的冒号后边要带空格，否则不生效。如果在http://localhost:4000 无法正常渲染请安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客定制--1.开始搭建</title>
      <link href="2020/06/27/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--1.%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA/"/>
      <url>2020/06/27/Hexo%E5%8D%9A%E5%AE%A2%E5%AE%9A%E5%88%B6--1.%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>Hexo是一款基于Node.js的静态博客框架。这个框架比较成熟，网上的各种主题安装和美化的教程也比较多。本文是以Hexo框架搭建、butterfly主题美化的。也可以先参考作者大大的文档：<a href="https://demo.jerryc.me">https://demo.jerryc.me</a></p><h2 id="博客环境搭建"><a class="markdownIt-Anchor" href="#博客环境搭建"></a> 博客环境搭建</h2><h3 id="安装git和nodejs"><a class="markdownIt-Anchor" href="#安装git和nodejs"></a> 安装Git和Node.js。</h3><p>我这里是win10系统和谷歌浏览器，编译修改配置文件用的是Sublime。<br />在Gitg<a href="https://git-scm.com/downloads">官网下载</a>Git，安装在自己知道的文件夹。<br />在Node.js<a href="https://nodejs.org/en/">官网下载</a>下载Node.js,点击左边的大绿块下载。</p><h3 id="安装hexo"><a class="markdownIt-Anchor" href="#安装hexo"></a> 安装Hexo</h3><p>安装完Git和Node.js以后，找到安装完的Gitbash,以后就回用Gitbash配置博客。注意要以管理员身份运行。</p><h3 id="安装并初始化hexo"><a class="markdownIt-Anchor" href="#安装并初始化hexo"></a> 安装并初始化Hexo</h3><p>右键管理员打开Gitbash，先安装淘宝源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>安装后在Gitbash命令行输入 cnpm -v 指令查看是否安装成功。<br />出现版本号证明安装成功，接下来安装hexo博客框架。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>创建一个文件夹blog，之后所有的博客东西全在这个目录生成。<br />然后再gitbash命令行输入blog路径切换到blog目录（我是在C盘创建的所以直接<br />cd blog/）以下操作全都是在blog目录或blog的子目录下进行的。<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702163603442.png#pic_center" alt="" /><br />进到blog目录后输入hexo init 生成博客（初始化博客），网不好可能下载时间稍微长一点。<br />安装完毕就可以输入hexo s（server）来启动博客。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702164529312.png#pic_center" alt="" /><br />这时可以复制红圈处的https://localhost:4000到浏览器来查看本地博客。</p><h2 id="把博客部署到github"><a class="markdownIt-Anchor" href="#把博客部署到github"></a> 把博客部署到Github</h2><p>把博客部署到Github是很多人的选择，其优点简单、不用购买域名和服务器，缺点就是打开比较慢，博客上传完数据不会立马变更，耐心一点就好。</p><h3 id="注册github账号"><a class="markdownIt-Anchor" href="#注册github账号"></a> 注册Github账号</h3><p>浏览器打开<a href="https://github.com/">Github官网</a>注册一个账号，推荐用自带翻译插件的浏览器。我这里就用英文版来演示。</p><h3 id="为github配置sshkey"><a class="markdownIt-Anchor" href="#为github配置sshkey"></a> 为Github配置SSHKEY</h3><p>在gitbash命令行依次输入以下两行命令并回车,配置用户名和邮箱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>如果报错就检查是否输入有误，没有报错就继续输入这个命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入下面命令，使Github与本地连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -c <span class="string">&quot;你的注册邮箱“</span></span><br></pre></td></tr></table></figure><p>输入完回车，在C:/Users/“你电脑的用户名”  下找到.ssh文件夹，打开里面有两个文件id_rsa.pub和id_rsa 。用自己喜欢的编辑器打开（命令行VIM也可以）id_rsa.pub这个文件并复制内容，接着打开浏览器的Github点击右上角头像选择Settings再选SSH and GPG keys，再点击New SSH key，<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702190620866.png" alt="" /><br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702190720691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />Title随意写，把刚才复制的内容复制到标题下边的key框里，再点击AddSSHkey就可以了。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702191030356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /><br />最后在命令行里输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>回车后会出现一段询问的内容，输入yes继续回车，等待出现你的用户名就完成了。</p><h3 id="创建一个仓库"><a class="markdownIt-Anchor" href="#创建一个仓库"></a> 创建一个仓库</h3><p>点击右上角头像选择第二个进入你的储存库。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702171737936.png" alt="" /><br />新建一个库<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702171942469.png" alt="" /><br />新建库的命名一定要是 &lt;用户名&gt;.github.io ，例如我的就是<a href="https://kthxbi4.github.io/">kthxbi4.github.io</a> 。<br /><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702172039361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /></p><h3 id="将hexo部署到github"><a class="markdownIt-Anchor" href="#将hexo部署到github"></a> 将hexo部署到Github</h3><p>打开博客根目录blog，找到_config.yml这个配置文件，用编辑器打开，修改最后几行配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/你的用户名/你的用户名.github.io.git</span><br><span class="line">  branch: master   </span><br></pre></td></tr></table></figure><p>配置完保存关闭，然后依次输入以下命令：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>hexo clean  #hexo c  的全称作用清除之前生成的东西<br />hexo generate  #hexo g 的全称，作用生成静态文章<br />hexo deploy    #hexo d 的全称，把生成的文章部署到github<br />注意：在向GitHub部署文章或博客的过程中会先后出现两个对话框，分别是输入用户名和密码。<br />部署完毕，在浏览器输入 <a href="http://xn--6qqv7i14ofosyrb.github.io">你的用户名.github.io</a> 进入出现以下这个界面就部署完毕了。  <img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200702210927478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MTUwODEw,size_16,color_FFFFFF,t_70" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> Hexo技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/06/26/HelloWorld/"/>
      <url>2020/06/26/HelloWorld/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
